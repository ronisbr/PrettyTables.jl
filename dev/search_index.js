var documenterSearchIndex = {"docs":
[{"location":"man/markdown/markdown_examples/#Markdown-Backend-Examples","page":"Examples","title":"Markdown Backend Examples","text":"This page contains examples of markdown tables generated by PrettyTables.jl. \n\nThe A object, when referenced, is defined as:\n\njulia> A = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n]","category":"section"},{"location":"man/markdown/markdown_examples/#Basic-Table","page":"Examples","title":"Basic Table","text":"First, we create a basic markdown table using the pretty_table function with  the backend keyword set to :markdown.\n\ntable = pretty_table(String, A; backend = :markdown)\nMarkdown.parse(table) # hide\n\nWe can add custom column labels by passing a vector of strings to the column_labels  keyword.\n\ntable = pretty_table(\n    String,\n    A;\n    backend = :markdown,\n    column_labels = [\"ID\", \"Flag\", \"Value\", \"Hex\"]\n)\nMarkdown.parse(table) # hide","category":"section"},{"location":"man/markdown/markdown_examples/#Column-Label-Style","page":"Examples","title":"Column Label Style","text":"The style of the column labels can be customized by passing a MarkdownTableStyle   to the style keyword. In the first example, we set the first_line_column_label field  of the style to a MarkdownStyle with the bold field set to true to obtain  bold column labels.\n\ndetails: **bold** Column Labels\ntable = pretty_table(\n    String,\n    A;\n    backend = :markdown,\n    style = MarkdownTableStyle(first_line_column_label = MarkdownStyle(bold = true))\n)\n\nprint(table) # hide\n\nMarkdown.parse(table) # hide\n\nIn the second example we use italic column labels:\n\ndetails: *italic* Column Labels\ntable = pretty_table(\n    String,\n    A;\n    backend = :markdown,\n    style = MarkdownTableStyle(first_line_column_label = MarkdownStyle(italic = true))\n)\n\nprint(table) # hide\n\nMarkdown.parse(table) # hide","category":"section"},{"location":"man/markdown/markdown_examples/#Custom-Alignment","page":"Examples","title":"Custom Alignment","text":"The alignment of each column can be specified by passing a vector of symbols to the  alignment keyword. The supported alignment values are:\n\n:l: Left alignment\n:c: Center alignment\n:r: Right alignment\n\nThe default alignment is left alignment (:l).\n\ndetails: Example code\ntable = pretty_table(\n    String,\n    A;\n    backend = :markdown,\n    column_labels = [\"Left\", \"Center\", \"Right\", \"Default\"],\n    alignment = [:l, :c, :r, :l]\n)\n\nprint(table) # hide\n\nMarkdown.parse(table) # hide","category":"section"},{"location":"man/markdown/markdown_examples/#Row-and-Column-Labels","page":"Examples","title":"Row and Column Labels","text":"Additional row and column labels can be added to the table by passing the row_labels  and column_labels keywords to the pretty_table function. The stubhead_label keyword  can be used to specify the label of the stubhead (corner cell).\n\ndetails: Example code\ndata = [\n    10.0 6.5\n    3.0 3.0\n    0.1 1.0\n]\n\nrow_labels = [\n    \"Atmospheric drag\"\n    \"Gravity gradient\"\n    \"Solar radiation pressure\"\n]\n\ncolumn_labels = [\n    \"Torque [10⁻⁶ Nm]\",\n    \"Angular Momentum [10⁻³ Nms]\"\n]\n\ntable = pretty_table(\n    String,\n    data;\n    backend = :markdown,\n    column_labels,\n    row_labels,\n    stubhead_label = \"Effect\",\n    summary_row_labels = [\"Total\"],\n    summary_rows = [(data, i) -> sum(data[:, i])],\n)\n\nprint(table) # hide\n\nMarkdown.parse(table) # hide","category":"section"},{"location":"man/markdown/markdown_examples/#Markdown-Highlighters","page":"Examples","title":"Markdown Highlighters","text":"A markdown highlighter is defined using an object of type MarkdownHighlighter. Two types of highlighters are supported: italic and bold.\n\ndetails: Example code\nt = 0:1:20\n\ndata = hcat(t, ones(length(t)), t, 0.5.*t.^2)\n\ncolumn_labels = [\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [\"[s]\", \"[m / s²]\", \"[m / s]\", \"[m]\"]\n]\n\nhl_p = MarkdownHighlighter(\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),\n    MarkdownStyle(italic = true)\n)\n\nhl_v = MarkdownHighlighter(\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),\n    MarkdownStyle(bold = true)\n)\n\ntable = pretty_table(\n    String,\n    data;\n    backend = :markdown,\n    column_labels = column_labels,\n    highlighters = [hl_p, hl_v],\n)\n\nprint(table) # hide\n\nMarkdown.parse(table) # hide","category":"section"},{"location":"man/typst/typst_backend/#Typst-Backend","page":"Typst Backend","title":"Typst Backend","text":"The Typst backend can be selected by passing the keyword backend = :typst to the function pretty_table. In this case, we have the following additional keywords to configure the output:","category":"section"},{"location":"man/typst/typst_backend/#Keywords","page":"Typst Backend","title":"Keywords","text":"annotate::Bool: Boolean indicating whether Typst code should be annotated.\ncaption::Union{Nothing, String, TypstCaption}: Table caption to be used by the Typst #figure function. The user can provide additional configuration to the caption by using the TypstCaption structure.\ndata_column_widths::Union{Nothing, String, Vector{String}, Vector{Pair{Int, String}}}: Column widths for the data columns. The information must be a valid length information in Typst, such as \"10fr\" or \"30pt\". If a single string is provided, it will be repeated for all columns. If a vector of strings is provided, its length must be equal to or larger than the number of printed columns. Alternatively, a vector of pairs can be provided, where the first element of the pair is the column index and the second element is the width for that column. In this case, columns that are not specified will have width auto. (Default = nothing)\nhighlighters::Vector{TypstHighlighter}: Highlighters to apply to the table. For more information, see the section Typst Highlighters in the Extended Help. (Default = TypstHighlighter[])\nminify::Bool: If true, the generated Typst code will be minified by ignoring wrap_column and printing the table columns in the same line. (Default = false)\nstyle::TypstTableStyle: Style of the table. For more information, see the section Typst Table Style in the Extended Help. (Default = TypstTableStyle())\nwrap_column::Integer: Indicates the column where the output will be wrapped. (Default = 92)\n\nnote: Note\nThe content in the cells is always escaped. If you want to use a raw Typst component as cell, load the package Typstry.jl and pass the cell content as a TypstString. In this case, the content will not be escaped and will be treated as a raw Typst component.","category":"section"},{"location":"man/typst/typst_backend/#Typst-Highlighters","page":"Typst Backend","title":"Typst Highlighters","text":"A set of highlighters can be passed as a Vector{TypstHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure TypstHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j), which should return true if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j), where h is the highlighter. This function must return a Vector{Pair{String, String}} with properties compatible with the style field that will be applied to the highlighted cell.\n\nA Typst highlighter can be constructed using three helpers:\n\nTypstHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nTypstHighlighter(f::Function, decorations::NTuple{N, Pair{String, String}})\n\nTypstHighlighter(f::Function, fd::Function)\n\nThe first applies a fixed decoration to the highlighted cell specified in decoration, the second allows specifying decorations as a Tuple, and the third lets the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for element (i, j), the applied style is the first match according to the order in the vector highlighters.\n\nnote: Note\nIf highlighters are used together with Formatters, formatting changes will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with values greater than 5 in red, and all the cells with values less than 5 in blue, we can define:\n\nhl_gt5 = TypstHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"text-fill\" => \"red\"]\n)\n\nhl_lt5 = TypstHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"text-fill\" => \"blue\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]\n\nEach cell with properties is rendered with one call to #text inside a table.cell function, as shown below:\n\ntable.cell()[#text()[Cell Content]]\n\nnote: Note\nSince table.cell and #text() share some attribute names, attributes used by the #text function must be defined with the text- prefix. For example, to create a table style (or highlighter) that sets a blue background and white font color:[\"fill\" => \"blue\", \"text-fill\" => \"white\"]","category":"section"},{"location":"man/typst/typst_backend/#Typst-Table-Style","page":"Typst Backend","title":"Typst Table Style","text":"The Typst table style is defined using an object of type TypstTableStyle that contains the following fields:\n\ntable::Vector{TypstPair}: Style for the table.\ntitle::Vector{TypstPair}: Style for the title.\nsubtitle::Vector{TypstPair}: Style for the subtitle.\nrow_number_label::Vector{TypstPair}: Style for the row number label.\nrow_number::Vector{TypstPair}: Style for the row number.\nstubhead_label::Vector{TypstPair}: Style for the stubhead label.\nrow_label::Vector{TypstPair}: Style for the row label.\nrow_group_label::Vector{TypstPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for the first line of the column labels. If a vector of Vector{TypstPair} is provided, each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for the rest of the column labels. If a vector of Vector{TypstPair} is provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::Vector{TypstPair}: Style for the merged cells at the first column label line.\nmerged_column_label::Vector{TypstPair}: Style for the merged cells at the rest of the column labels.\nsummary_row_cell::Vector{TypstPair}: Style for the summary row cell.\nsummary_row_label::Vector{TypstPair}: Style for the summary row label.\nfootnote::Vector{TypstPair}: Style for the footnote.\nsource_notes::Vector{TypstPair}: Style for the source notes.\n\nEach field is a vector of TypstPair, i.e. Pair{String, String}, describing properties and values compatible with the Typst style attribute.\n\nFor example, if we want the stubhead label to be bold and red, we must define:\n\nstyle = TypstTableStyle(\n    stubhead_label = [\"text-weight\" => \"bold\", \"fill\" => \"red\", \"text-fill\" => \"white\"]\n)\n\nThe user can pass any property compatible with the Typst style attribute. If the prefix text- is used, the property will be applied to the text of the cell. Otherwise, it will be applied to the cell itself.","category":"section"},{"location":"man/latex/latex_backend/#LaTeX-Backend","page":"LaTeX Backend","title":"LaTeX Backend","text":"The LaTeX backend can be selected by passing the keyword backend = :latex to the function pretty_table. In this case, we have the following additional keywords to configure the output.","category":"section"},{"location":"man/latex/latex_backend/#Keywords","page":"LaTeX Backend","title":"Keywords","text":"highlighters::Vector{LatexHighlighter}: Highlighters to apply to the table. For more   information, see the section [LaTeX Highlighters]@(ref).\nstyle::LatexTableStyle: Style of the table. For more information, see the section   LaTeX Table Style.\ntable_format::LatexTableFormat: LaTeX table format used to render the table. For more   information, see the section LaTeX Table Format.","category":"section"},{"location":"man/latex/latex_backend/#LaTeX-Highlighters","page":"LaTeX Backend","title":"LaTeX Highlighters","text":"A set of highlighters can be passed as a Vector{LatexHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure LatexHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return a Vector{String} with the LaTeX environments to   be applied to the cell.\n\nA LaTeX highlighter can be constructed using two helpers:\n\nLatexHighlighter(f::Function, envs::Vector{String})\n\nwhere it will apply recursively all the LaTeX environments in envs to the highlighted text, and\n\nLatexHighlighter(f::Function, fd::Function)\n\nwhere the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the vector highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to make the cells with value greater than 5 bold, and all the cells with value less than 5 small, we can define:\n\nhl_gt5 = LatexHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"textbf\"]\n)\n\nhl_lt5 = LatexHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"small\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]","category":"section"},{"location":"man/latex/latex_backend/#LaTeX-Table-Format","page":"LaTeX Backend","title":"LaTeX Table Format","text":"The LaTeX table format is defined using an object of type LatexTableFormat that contains the following fields:\n\nborders::LatexTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the   beginning of the table.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn on bottom of the merged column labels using \\\\cline.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn   after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each data row index listed in this vector. If the symbol :all is passed, a   horizontal line will be drawn after every data column. If the symbol :none is passed,   no horizontal lines will be drawn after the data rows.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be   drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be   drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn   after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there are no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn   after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the   beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn   after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn   after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will be   drawn after each data column index listed in this vector. If the symbol :all is   passed, a vertical line will be drawn after every data column. If the symbol :none is   passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after   the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be   drawn after the continuation column.\n\nWe provide a few helpers to configure the table format. For more information, see the documentation of the following macros:\n\n@latex__all_horizontal_lines.\n@latex__all_vertical_lines.\n@latex__no_horizontal_lines.\n@latex__no_vertical_lines.","category":"section"},{"location":"man/latex/latex_backend/#LaTeX-Table-Style","page":"LaTeX Backend","title":"LaTeX Table Style","text":"The LaTeX table style is defined using an object of type LatexTableStyle that contains the following fields:\n\ntitle::LatexEnvironments: Latex environments with the style for the title.\nsubtitle::LatexEnvironments: Latex environments with the style for the subtitle.\nrow_number_label::LatexEnvironments: Latex environments with the style for the row   number label.\nrow_number::LatexEnvironments: Latex environments with the style for the row numbers.\nstubhead_label::LatexEnvironments:  Latex environments with the style for the stubhead   label.\nrow_label::LatexEnvironments: Latex environments with the style for the row labels.\nrow_group_label::LatexEnvironments: Latex environments with the style for the row group   label.\nfirst_line_column_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex   environments with the style for the first line of the column labels. If a vector of   LatexEnvironments is provided, each column label in the first line will use the   corresponding style.\ncolumn_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex environments   with the style for the rest of the column labels. If a vector of LatexEnvironments is   provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::LatexEnvironments: Latex environments with the style for   the merged cells at the first column label line.\nmerged_column_label::LatexEnvironments: Latex environments with the style for the merged   cells at the rest of the column labels.\nsummary_row_cell::LatexEnvironments: Latex environments with the style for the summary   row cell.\nsummary_row_label::LatexEnvironments: Latex environments with the style for the summary   row label.\nfootnote::LatexEnvironments: Latex environments with the style for the footnotes.\nsource_note::LatexEnvironments: Latex environments with the style for the source notes.\nomitted_cell_summary::LatexEnvironments: Latex environments with the style for the   omitted cell summary.\n\nEach field is a LatexEnvironments object, which is a vector of strings with the LaTeX environments to be applied to the corresponding element.\n\nFor example, if we want to make the stubhead label bold and red, we must define:\n\nstyle = LatexTableStyle(\n    stubhead_label = [\"textbf\", \"color{red}\"]\n)","category":"section"},{"location":"man/text/predefined_formats/#Pre-defined-Formats","page":"Pre-defined Formats","title":"Pre-defined Formats","text":"The text backend has some predefined borders and formats to print tables.","category":"section"},{"location":"man/text/predefined_formats/#Borders","page":"Pre-defined Formats","title":"Borders","text":"We can change the printed table borders using the parameter borders in the structure TextTableFormat passed to the keyword table_format.\n\ntext_table_borders__ascii_dots\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__ascii_dots)\n)\n\ntext_table_borders__ascii_rounded\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__ascii_rounded)\n)\n\ntext_table_borders__borderless\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__borderless)\n)\n\ntext_table_borders__compact\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__compact)\n)\n\ntext_table_borders__matrix\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__matrix)\n)\n\ntext_table_borders__mysql\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__mysql)\n)\n\ntext_table_borders__simple\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__simple)\n)\n\ntext_table_borders__unicode_rounded\n\npretty_table(\n  data;\n  backend = :text,\n  table_format = TextTableFormat(borders = text_table_borders__unicode_rounded)\n)","category":"section"},{"location":"man/text/predefined_formats/#Formats","page":"Pre-defined Formats","title":"Formats","text":"The text backend also defines some pre-defined formats to print tables that can be used through the keyword table_format in pretty_table.\n\ntext_table_format__matrix\n\npretty_table(\n  ones(3, 3);\n  backend = :text,\n  show_column_labels = false,\n  table_format = text_table_format__matrix\n)","category":"section"},{"location":"man/markdown/markdown_backend/#Markdown-Backend","page":"Markdown Backend","title":"Markdown Backend","text":"The markdown backend can be selected by passing the keyword backend = :markdown to the function pretty_table. In this case, we have the following additional keywords to configure the output.","category":"section"},{"location":"man/markdown/markdown_backend/#Keywords","page":"Markdown Backend","title":"Keywords","text":"allow_markdown_in_cells::Bool: If true, the content of the cells can contain markdown code. (Default: false)\nhighlighters::Vector{MarkdownHighlighter}: Highlighters to apply to the table. For more information, see the section Markdown Highlighters.\nline_breaks::Bool: If true, line breaks in the content of the cells (\\\\n) are replaced by <br>. (Default: false)\nstyle::MarkdownTableStyle: Style of the table. For more information, see the section Markdown Table Style.\ntable_format::MarkdownTableFormat: Markdown table format used to render the table. For more information, see the section Markdown Table Format.","category":"section"},{"location":"man/markdown/markdown_backend/#Markdown-Highlighters","page":"Markdown Backend","title":"Markdown Highlighters","text":"A set of highlighters can be passed as a Vector{MarkdownHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure MarkdownHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the highlighter. This function must return the MarkdownStyle to be applied to the cell that must be highlighted.\n\nThe function f has the following signature:\n\n  f(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type MarkdownStyle that contains the decoration to be applied to the cell.\n\nA markdown highlighter can be constructed using two helpers:\n\nMarkdownHighlighter(f::Function, decoration::MarkdownStyle)\n\nMarkdownHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"section"},{"location":"man/markdown/markdown_backend/#Markdown-Table-Format","page":"Markdown Backend","title":"Markdown Table Format","text":"The markdown table format is defined using an object of type MarkdownTableFormat that contains the following fields:\n\ntitle_heading_level::Int: Title heading level.\nsubtitle_heading_level::Int: Subtitle heading level.\nhorizontal_line_char::Char: Character used to draw the horizontal line.\nline_before_summary_rows::Bool: Whether to draw a line before the summary rows.\ncompact_table::Bool: If true, the table is printed in a compact format without extra spaces between columns.","category":"section"},{"location":"man/markdown/markdown_backend/#Markdown-Table-Style","page":"Markdown Backend","title":"Markdown Table Style","text":"The markdown table style is defined using an object of type MarkdownTableStyle that contains the following fields:\n\nrow_number_label::MarkdownStyle: Style for the row number label.\nrow_number::MarkdownStyle: Style for the row number.\nstubhead_label::MarkdownStyle: Style for the stubhead label.\nrow_label::MarkdownStyle: Style for the row label.\nrow_group_label::MarkdownStyle: Style for the row group label.\nfirst_line_column_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the first line of the column label. If a vector of MarkdownStyle is provided, each column label in the first line will use the corresponding style.\ncolumn_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the column label. If a vector of MarkdownStyle is provided, each column label will use the corresponding style.\nsummary_row_label::MarkdownStyle: Style for the summary row label.\nsummary_row_cell::MarkdownStyle: Style for the summary row cell.\nfootnote::MarkdownStyle: Style for the footnote.\nsource_note::MarkdownStyle: Style for the source note.\nomitted_cell_summary::MarkdownStyle: Style for the omitted cell summary.\n\nEach field is an instance of the structure MarkdownStyle describing the style to be applied to the corresponding element.\n\nFor example, if we want that the stubhead label is bold and italic, we must define:\n\nstyle = MarkdownTableStyle(\n    stubhead_label = MarkdownStyle(bold = true, italic = true)\n)","category":"section"},{"location":"man/text/text_backend/#Text-Backend","page":"Text Backend","title":"Text Backend","text":"The text backend can be selected by passing the keyword backend = :text to the function pretty_table. In this case, we have the following additional keywords to configure the output.","category":"section"},{"location":"man/text/text_backend/#Keywords","page":"Text Backend","title":"Keywords","text":"alignment_anchor_fallback::Symbol: This keyword controls the line alignment when using the regex alignment anchors if a match is not found. If it is :l, the left of the line will be aligned with the anchor. If it is :c, the line center will be aligned with the   anchor. Otherwise, the end of the line will be aligned with the anchor. (Default = :l)\nalignment_anchor_regex::Union{Vector{Regex}, Vector{Pair{Int, Vector{Regex}}}}: This This keyword can be used to provide regexes to align the data values in the table columns. If it is Vector{Regex}, the regexes will be used to align all the columns. If it is Vector{Pair{Int, Vector{Regex}}}, the Int element specifies the column to which the regexes in Vector{Regex} will be applied. The regex match is searched in the same order as the regexes appear on the vector. The regex matching is applied after the cell conversion to string, which includes the formatters. If no match is found for a specific line, the alignment of this line depends on the options alignment_anchor_fallback. Example: [2 => [r\"\\\\.\"]] aligns the decimal point of the cells in the second column. (Default = Regex[])\napply_alignment_regex_to_summary_rows::Bool: If true, the alignment regexes in   alignment_anchor_regex will also be applied to the summary rows.   (Default = false)\nauto_wrap::Bool: If true, the text will be wrapped on spaces to fit the column. Notice that this function requires line_breaks = true and the column must have a fixed size (see fixed_data_column_widths). (Default = false)\ncolumn_label_width_based_on_first_line_only::Bool: If true, the column label width is based on the first line of the column. Hence, if the other column labels have a text width larger than the computed column width, they will be cropped to fit. (Default = false)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the display size (num. of rows, num. of columns) that is available to print the table. It is used to crop the data depending on the value of the keyword crop. Notice that if a dimension is not positive, it will be treated as unlimited. (Default = displaysize(io))\nequal_data_column_widths::Bool: If true, the data columns will have the same width. (Default = false)\nfit_table_in_display_horizontally::Bool: If true, the table will be cropped to fit the display horizontally. (Default = true)\nfit_table_in_display_vertically::Bool: If true, the table will be cropped to fit the display vertically. (Default = true)\nfixed_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this vector specifies the width of each column. If it is a Int, this number will be used as the width of all columns. If the width is equal or lower than 0, it will be automatically computed to fit the large cell in the column. (Default = 0)\nhighlighters::Vector{TextHighlighter}: Highlighters to apply to the table. For more information, see the section Text Highlighters.\nline_breaks::Bool: If true, a new line character will break the line inside the cells. (Default = false)\nmaximum_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this vector specifies the maximum width of each column. If it is a Int, this number will be used as the maximum width of all columns. If the maximum width is equal or lower than 0, it will be ignored. Notice that the parameter fixed_data_column_widths has precedence over this one. (Default = 0)\nminimum_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this vector specifies the minimum width of each column. If it is an Int, this number will be used as the minimum width of all columns. If the minimum width is equal or lower than 0, it will be ignored. Notice that the parameter fixed_data_column_widths has precedence over this one. (Default = 0)\noverwrite_display::Bool: If true, the same number of lines in the printed table will be deleted from the output io. This can be used to update the table in the display continuously. (Default = false)\nreserved_display_lines::Int: Number of lines to be left at the beginning of the printing when vertically cropping the output. (Default = 0)\nshrinkable_column_minimum_width::Int: If it is a positive integer (> 0), this is the minimum width of the shrinkable column (see shrinkable_data_column). (Default = 0)\nshrinkable_data_column::Int: If it is a positive integer, this column will be shrinkable. This means that if the table does not fit in the display, this column will be shrunk to fit the table in the display. If it is 0 or negative, no column will be shrinkable. (Default = 0)\nstyle::TextTableStyle: Style of the table. For more information, see the section Text Table Style.\ntable_format::TextTableFormat: Text table format used to render the table. For more   information, see the section Text Table Format.","category":"section"},{"location":"man/text/text_backend/#Text-Highlighters","page":"Text Backend","title":"Text Highlighters","text":"A set of highlighters can be passed as a Vector{TextHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure TextHighlighter. It contains three fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the highlighter. This function must return the Crayon to be applied to the cell that must be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd is used.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the cell (i, j) will be highlighted.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.\n\nA highlighter can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with value greater than 5 in red, and all the cells with value less than 5 in blue, we can define:\n\nhl_gt5 = TextHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    crayon\"red\"\n)\n\nhl_lt5 = TextHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    crayon\"blue\"\n)\n\nhighlighters = [hl_gt5, hl_lt5]","category":"section"},{"location":"man/text/text_backend/#Text-Table-Format","page":"Text Backend","title":"Text Table Format","text":"The text table format is defined using an object of type TextTableFormat that contains the following fields:\n\nborders::TextTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the beginning of the table.\nhorizontal_lines_at_column_labels::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each column label row index listed in this vector. If the symbol :all is   passed, a horizontal line will be drawn after every column label. If the symbol :none   is passed, no horizontal lines will be drawn.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn at the merged column labels. Notice that the horizontal line drawn using the   option horizontal_lines_at_column_labels has precedence over this one.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be drawn after each data row index listed in this vector. If the symbol :all is passed, a horizontal line will be drawn after every data column. If the symbol :none is passed, no horizontal lines will be drawn.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there are no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will be drawn after each data column index listed in this vector. If the symbol :all is passed, a vertical line will be drawn after every data column. If the symbol :none is passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be drawn after the continuation column.\nellipsis_line_skip::Integer: Number of lines to skip when printing an ellipsis.\n\nWe provide a few helpers to configure the table format. For more information, see the documentation of the following macros:\n\n@text__all_horizontal_lines.\n@text__all_vertical_lines.\n@text__no_horizontal_lines.\n@text__no_vertical_lines.","category":"section"},{"location":"man/text/text_backend/#Text-Table-Style","page":"Text Backend","title":"Text Table Style","text":"The text table style is defined using an object of type TextTableStyle that contains the following fields:\n\ntitle::Crayon: Crayon with the style for the title.\nsubtitle::Crayon: Crayon with the style for the subtitle.\nrow_number_label::Crayon: Crayon with the style for the row number label.\nrow_number::Crayon: Crayon with the style for the row numbers.\nstubhead_label::Crayon: Crayon with the style for the stubhead label.\nrow_label::Crayon: Crayon with the style for the row labels.\nrow_group_label::Crayon: Crayon with the style for the row group label.\nfirst_line_column_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style   for the first column label lines. If a vector of crayons is passed, it must have the   same length as the number columns in the table.\ncolumn_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style for the   rest of the column labels. If a vector of crayons is passed, it must have the same   length as the number of columns in the table.\nfirst_line_merged_column_label::Crayon: Crayon with the style for the merged cells at the first column label line.\nmerged_column_label::Crayon: Crayon with the style for the merged cells at the rest of the column labels.\nsummary_row_cell::Crayon: Crayon with the style for the summary row cell.\nsummary_row_label::Crayon: Crayon with the style for the summary row label.\nfootnote::Crayon: Crayon with the style for the footnotes.\nsource_note::Crayon: Crayon with the style for the source notes.\nomitted_cell_summary::Crayon: Crayon with the style for the omitted cell summary.\ntable_border::Crayon: Crayon with the style for the table border.\n\nEach field is a Crayon describing the style for the corresponding element in the table.\n\nFor example, if we want the stubhead label to be bold and red, we must define:\n\nstyle = TextTableStyle(\n    stubhead_label = crayon\"bold red\"\n)","category":"section"},{"location":"man/html/html_examples/#HTML-Backend-Examples","page":"Examples","title":"HTML Backend Examples","text":"Here, we can see some examples of text tables generated by PrettyTables.jl. The A object, when referenced, is defined as:\n\njulia> A = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n]\n\n\n\njulia> pretty_table(A; backend = :html)\n\npt_to_html(         # hide\n    A;              # hide\n    backend = :html # hide\n)                   # hide\n\n\n\njulia> pretty_table(\n    A;\n    backend = :html,\n    style = HtmlTableStyle(;\n        first_line_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"]\n    )\n)\n\npt_to_html(                                                                         # hide\n    A;                                                                              # hide\n    backend = :html,                                                                # hide\n    style = HtmlTableStyle(;                                                        # hide\n        first_line_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"] # hide\n    )                                                                               # hide\n)                                                                                   # hide\n\n\n\njulia> data = [\n    10.0 6.5\n     3.0 3.0\n     0.1 1.0\n]\n\njulia> row_labels = [\n    \"Atmospheric drag\"\n    \"Gravity gradient\"\n    \"Solar radiation pressure\"\n]\n\njulia> column_labels = [\n    [MultiColumn(2, \"Value\", :c)],\n    [\n        \"Torque [10⁻⁶ Nm]\",\n        \"Angular Momentum [10⁻³ Nms]\"\n    ]\n]\n\njulia> pretty_table(\n    data;\n    backend = :html,\n    column_labels,\n    merge_column_label_cells = :auto,\n    row_labels,\n    stubhead_label = \"Effect\",\n    style = HtmlTableStyle(;\n        first_line_merged_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"],\n        column_label                   = [\"color\" => \"DarkGrey\"],\n        stubhead_label                 = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"],\n        summary_row_label              = [\"color\" => \"red\",       \"font-weight\" => \"bold\"]\n    ),\n    summary_row_labels = [\"Total\"],\n    summary_rows = [(data, i) -> sum(data[:, i])],\n)\n\ndata = [                                                                                    # hide\n    10.0 6.5                                                                                # hide\n     3.0 3.0                                                                                # hide\n     0.1 1.0                                                                                # hide\n]                                                                                           # hide\n                                                                                            # hide\nrow_labels = [                                                                              # hide\n    \"Atmospheric drag\"                                                                      # hide\n    \"Gravity gradient\"                                                                      # hide\n    \"Solar radiation pressure\"                                                              # hide\n]                                                                                           # hide\n                                                                                            # hide\ncolumn_labels = [                                                                           # hide\n    [MultiColumn(2, \"Value\", :c)],                                                          # hide\n    [                                                                                       # hide\n        \"Torque [10⁻⁶ Nm]\",                                                                 # hide\n        \"Angular Momentum [10⁻³ Nms]\"                                                       # hide\n    ]                                                                                       # hide\n]                                                                                           # hide\n                                                                                            # hide\npt_to_html(                                                                                 # hide\n    data;                                                                                   # hide\n    backend = :html,                                                                        # hide\n    column_labels,                                                                          # hide\n    merge_column_label_cells = :auto,                                                       # hide\n    row_labels,                                                                             # hide\n    stubhead_label = \"Effect\",                                                              # hide\n    style = HtmlTableStyle(;                                                                # hide\n        first_line_merged_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"], # hide\n        column_label                   = [\"color\" => \"DarkGrey\"],                           # hide\n        stubhead_label                 = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"], # hide\n        summary_row_label              = [\"color\" => \"red\",       \"font-weight\" => \"bold\"]  # hide\n    ),                                                                                      # hide\n    summary_row_labels = [\"Total\"],                                                         # hide\n    summary_rows = [(data, i) -> sum(data[:, i])],                                          # hide\n)                                                                                           # hide\n\n\n\njulia> t = 0:1:20\n\njulia> data = hcat(t, ones(length(t) ), t, 0.5.*t.^2);\n\njulia> column_labels = [\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ \"[s]\",     \"[m / s²]\",  \"[m / s]\",      \"[m]\"]\n]\n\njulia> hl_p = HtmlHighlighter(\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),\n    [\"color\" => \"blue\"]\n)\n\njulia> hl_v = TextHighlighter(\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),\n    [\"color\" => \"red\"]\n)\n\njulia> pretty_table(\n    data;\n    backend = :html,\n    column_labels = column_labels,\n    highlighters  = [hl_p, hl_v],\n    style = HtmlTableStyle(;\n        first_line_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"],\n        column_label            = [\"color\" => \"DarkGrey\"],\n    )\n)\n\nt = 0:1:20                                                                           # hide\n                                                                                     # hide\ndata = hcat(t, ones(length(t) ), t, 0.5.*t.^2);                                      # hide\n                                                                                     # hide\ncolumn_labels = [                                                                    # hide\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],                                # hide\n    [ \"[s]\",     \"[m / s²]\",  \"[m / s]\",      \"[m]\"]                                 # hide\n]                                                                                    # hide\n                                                                                     # hide\nhl_p = HtmlHighlighter(                                                              # hide\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),                                    # hide\n    [\"color\" => \"blue\"]                                                              # hide\n)                                                                                    # hide\n                                                                                     # hide\nhl_v = HtmlHighlighter(                                                              # hide\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),                                    # hide\n    [\"color\" => \"red\"]                                                               # hide\n)                                                                                    # hide\n                                                                                     # hide\npt_to_html(                                                                          # hide\n    data;                                                                            # hide\n    backend = :html,                                                                 # hide\n    column_labels = column_labels,                                                   # hide\n    highlighters  = [hl_p, hl_v],                                                    # hide\n    style = HtmlTableStyle(;                                                         # hide\n        first_line_column_label = [\"color\" => \"BurlyWood\", \"font-weight\" => \"bold\"], # hide\n        column_label            = [\"color\" => \"DarkGrey\"],                           # hide\n    )                                                                                # hide\n)                                                                                    # hide","category":"section"},{"location":"man/text/text_examples/#Text-Backend-Examples","page":"Examples","title":"Text Backend Examples","text":"Here, we can see some examples of text tables generated by PrettyTables.jl. The A object, when referenced, is defined as:\n\njulia> A = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n]\n\n\n\njulia> pretty_table(A)\n\n<img src=\"../text_example_01.svg\" alt=\"Text Example 01\">\n\n\n\njulia> pretty_table(A; style = TextTableStyle(; table_border = crayon\"yellow\"))\n\n<img src=\"../text_example_02.svg\" alt=\"Text Example 02\">\n\n\n\njulia> data = [\n    10.0 6.5\n     3.0 3.0\n     0.1 1.0\n]\n\njulia> row_labels = [\n    \"Atmospheric drag\"\n    \"Gravity gradient\"\n    \"Solar radiation pressure\"\n]\n\njulia> column_labels = [\n    [MultiColumn(2, \"Value\", :c)],\n    [\n        \"Torque [10⁻⁶ Nm]\",\n        \"Angular Momentum [10⁻³ Nms]\"\n    ]\n]\n\njulia> pretty_table(\n    data;\n    column_labels,\n    merge_column_label_cells = :auto,\n    row_labels,\n    stubhead_label = \"Effect\",\n    style = TextTableStyle(;\n        first_line_merged_column_label = crayon\"bold yellow\",\n        stubhead_label = crayon\"bold yellow\",\n        summary_row_label = crayon\"bold cyan\"\n    ),\n    summary_row_labels = [\"Total\"],\n    summary_rows = [(data, i) -> sum(data[:, i])],\n    table_format = TextTableFormat(;\n        @text__no_vertical_lines,\n        horizontal_lines_at_column_labels = [1],\n        vertical_line_after_row_label_column = true\n    ),\n)\n\n<img src=\"../text_example_03.svg\" alt=\"Text Example 03\">\n\n\n\njulia> t = 0:1:20\n\njulia> data = hcat(t, ones(length(t) ), t, 0.5.*t.^2);\n\njulia> column_labels = [\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ \"[s]\",     \"[m / s²]\",  \"[m / s]\",      \"[m]\"]\n]\n\njulia> hl_p = TextHighlighter(\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),\n    crayon\"bold blue\"\n)\n\njulia> hl_v = TextHighlighter(\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),\n    crayon\"bold red\"\n)\n\njulia> pretty_table(\n    data;\n    column_labels = column_labels,\n    highlighters  = [hl_p, hl_v],\n    style = TextTableStyle(;\n        first_line_column_label = crayon\"bold yellow\",\n    )\n)\n\n<img src=\"../text_example_04.svg\" alt=\"Text Example 04\">","category":"section"},{"location":"man/latex/latex_examples/#LaTeX-Backend-Examples","page":"Examples","title":"LaTeX Backend Examples","text":"Here, we can see some examples of LaTeX tables generated by PrettyTables.jl. Notice that the output has been rendered to PDF using LuaTeX and converted to PNG using ImageMagick.\n\n\n\njulia> data = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n]\n\njulia> pretty_table(data; backend = :latex)\n\n<img src=\"../latex_example_01.png\" alt=\"LaTeX Example 01\" width=\"60%\">\n\n\n\nThis example uses the predefined format for the LaTeX backend latex_table_format__booktabs.\n\njulia> data = [\n    10.0 6.5\n     3.0 3.0\n     0.1 1.0\n]\n\njulia> row_labels = [\n    \"Atmospheric drag\"\n    \"Gravity gradient\"\n    \"Solar radiation pressure\"\n]\n\njulia> column_labels = [\n    [MultiColumn(2, \"Value\", :c)],\n    [\n        latex_cell\"\\textbf{Torque} [10$^{-5}$ Nm]\",\n        latex_cell\"\\textbf{Angular Momentum} [10$^{-3}$ Nms]\"\n    ]\n],\n\njulia> pretty_table(\n    data;\n    backend = :latex,\n    column_labels,\n    merge_column_label_cells = :auto,\n    row_labels,\n    stubhead_label = \"Effect\",\n    style = LatexTableStyle(column_label = String[]),\n    summary_row_labels = [\"Total\"],\n    summary_rows = [(data, i) -> sum(data[:, i])],\n    table_format = latex_table_format__booktabs\n)\n\n(Image: LaTeX Example 02)\n\n\n\njulia> t = 0:1:20\n\njulia> data = hcat(t, ones(length(t) ), t, 0.5.*t.^2);\n\njulia> column_labels = [\n    [            \"Time\",           \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ latex_cell\"{[s]}\",  latex_cell\"[m / s$^2$]\",  \"[m / s]\",      \"[m]\"]\n]\n\njulia> hl_p = LatexHighlighter(\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),\n    [\"textcolor{blue!60}\"]\n)\n\njulia> hl_v = LatexHighlighter(\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),\n    [\"textcolor{red!60}\"]\n)\n\njulia> pretty_table(\n    data;\n    backend       = :latex,\n    column_labels = column_labels,\n    highlighters  = [hl_p, hl_v],\n    style         = LatexTableStyle(column_label = String[]),\n    table_format  = latex_table_format__booktabs\n)\n\n<img src=\"../latex_example_03.png\" alt=\"LaTeX Example 01\" width=\"70%\">","category":"section"},{"location":"man/usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/#Table-Sections","page":"Usage","title":"Table Sections","text":"PrettyTables.jl considers the following table sections when printing a table:\n\n                                      TITLE\n                                     Subtitle\n┌────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┐\n│ Row Number │    Stubhead Label │ Column Label │ Column Label │ ⋯ │ Column Label │\n│            │                   │ Column Label │ Column Label │ ⋯ │ Column Label │\n│            │                   │       ⋮      │       ⋮      │ ⋯ │       ⋮      │\n│            │                   │ Column Label │ Column Label │ ⋯ │ Column Label │\n├────────────┼───────────────────┼──────────────┼──────────────┼───┼──────────────┤\n│          1 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          2 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┤\n│ Row Group Label                                                                 │\n├────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┤\n│          3 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          4 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┤\n│ Row Group Label                                                                 │\n├────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┤\n│          5 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          6 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│      ⋮     │          ⋮        │       ⋮      │       ⋮      │ ⋱ │       ⋮      │\n│        100 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┼───────────────────┼──────────────┼──────────────┼───┼──────────────┤\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n│      ⋮     │          ⋮        │       ⋮      │       ⋮      │ ⋯ │       ⋮      │\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n└────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┘\nFootnotes\nSource notes\n\nAll those sections can be configured using keyword arguments as described below.","category":"section"},{"location":"man/usage/#General-Keywords","page":"Usage","title":"General Keywords","text":"The following keywords are related to table configuration and are available in all backends:\n\nbackend::Symbol: Backend used to print the table. The available options are :text, :markdown, :html, and :latex. (Default: :text)","category":"section"},{"location":"man/usage/#IOContext-Arguments","page":"Usage","title":"IOContext Arguments","text":"compact_printing::Bool: If true, the table will be printed in a compact format, i.e, we will pass the context option :compact => true when rendering the values. (Default: true)\nlimit_printing::Bool: If true, the table will be printed in a limited format, i.e, we will pass the context option :limit => true when rendering the values. (Default: true)","category":"section"},{"location":"man/usage/#Printing-Specification-Arguments","page":"Usage","title":"Printing Specification Arguments","text":"show_omitted_cell_summary::Bool: If true, a summary of the omitted cells will be printed at the end of the table. (Default: true)\nrenderer::Symbol: The renderer used to print the table. The available options are :print and :show. (Default: :print)","category":"section"},{"location":"man/usage/#Table-Sections-Arguments","page":"Usage","title":"Table Sections Arguments","text":"title::String: Title of the table. If it is empty, the title will be omitted. (Default: \"\")\nsubtitle::String: Subtitle of the table. If it is empty, the subtitle will be omitted. (Default: \"\")\nstubhead_label::String: Label of the stubhead column. (Default: \"\")\nrow_number_column_label::String: Label of the row number column. (Default: \"Row\")\nrow_labels::Union{Nothing, AbstractVector}: Row labels. If it is nothing, the column with row labels is omitted. (Default: nothing)\nrow_group_labels::Union{Nothing, Vector{Pair{Int, String}}}: Row group labels. If it is nothing, no row group label is printed. For more information on how to specify the row group labels, see the section Row Group Labels. (Default: nothing)\ncolumn_labels::Union{Nothing, AbstractVector}: Column labels. If it is nothing, the function uses a default value for the column labels. For more information on how to specify the column labels, see the section Column Labels. (Default: nothing)\nshow_column_labels::Bool: If true, the column labels will be printed. (Default: true)\nsummary_rows::Union{Nothing, Vector{Function}}: Summary rows. If it is nothing, no summary rows are printed. For more information on how to specify the summary rows, see the section Summary Rows. (Default: nothing)\nsummary_row_labels::Union{Nothing, Vector{String}}: Labels of the summary rows. If it is nothing, the function uses a default value for the summary row labels. (Default: nothing)\nfootnotes::Union{Nothing, Vector{Pair{FootnoteTuple, String}}}: Footnotes. If it is nothing, no footnotes are printed. For more information on how to specify the footnotes, see the section Footnotes. (Default: nothing)\nsource_notes::String: Source notes. If it is empty, the source notes will be omitted. (Default: \"\")","category":"section"},{"location":"man/usage/#Alignment-Arguments","page":"Usage","title":"Alignment Arguments","text":"The following keyword arguments define the alignment of the table sections. The alignment can be specified using a symbol: :l for left, :c for center, or :r for right.\n\nalignment::Union{Symbol, Vector{Symbol}}: Alignment of the table data. It can be a Symbol, which will be used for all columns, or a vector of Symbols, one for each column. (Default: :r)\ncolumn_label_alignment::Union{Nothing, Symbol, Vector{Symbol}}: Alignment of the column labels. It can be a Symbol, which will be used for all columns, a vector of Symbols, one for each column, or nothing, which will use the value of alignment. (Default: nothing)\ncontinuation_row_alignment::Union{Nothing, Symbol}: Alignment of the columns in the continuation row. If it is nothing, we use the value of alignment. (Default: nothing)\nfootnote_alignment::Symbol: Alignment of the footnotes. (Default: :l)\nrow_label_column_alignment::Symbol: Alignment of the row labels. (Default: :r)\nrow_group_label_alignment::Symbol: Alignment of the row group labels. (Default: :l)\nrow_number_column_alignment::Symbol: Alignment of the row number column. (Default: :r)\nsource_note_alignment::Symbol: Alignment of the source notes. (Default: :l)\nsubtitle_alignment::Symbol: Alignment of the subtitle. (Default: :c)\ntitle_alignment::Symbol: Alignment of the title. (Default: :c)\ncell_alignment::Union{Nothing, Vector{Pair{NTuple{2, Int}, Symbol}, Vector{Function}}: A vector of functions with the signature f(data, i, j) that overrides the alignment of the cell (i, j) to the value returned by f. The function must return a valid alignment symbol or nothing. In the latter, the cell alignment will not be modified. If the function returns an invalid data, it will be discarded. For convenience, it can also be a vector of Pair{NTuple{2, Int}, Symbol}, i.e. (i::Int, j::Int) => a::Symbol, that overrides the alignment of the cell (i, j) to a. (Default = nothing)\n\nwarning: Warning\nSome backends do not support all the alignment options. For example, it is impossible to define cell-specific alignment in the markdown backend.","category":"section"},{"location":"man/usage/#Other-Arguments","page":"Usage","title":"Other Arguments","text":"formatters::Union{Nothing, Vector{Function}}: Formatters used to modify the rendered output of the cells. For more information, see the section Formatters. (Default: nothing)\nmaximum_number_of_columns::Int: Maximum number of columns to be printed. If the table has more columns than this value, the table will be truncated. If it is negative, all columns will be printed. (Default: -1)\nmaximum_number_of_rows::Int: Maximum number of rows to be printed. If the table has more rows than this value, the table will be truncated. If it is negative, all rows will be printed. (Default: -1)\nmerge_column_label_cells::Union{Symbol, Vector{MergeCells}}: Merged cells in the column labels. For more information, see the section Column Labels. (Default: :auto)\nnew_line_at_end::Bool: If true, a new line will be added at the end of the table.\nshow_first_column_label_only::Bool: If true, only the first row of the column labels will be printed. (Default: false)\nvertical_crop_mode::Symbol: Vertical crop mode. This option defines how the table will be vertically cropped if it has more rows than the number specified in maximum_number_of_rows. The available options are :bottom, when the data will be cropped at the bottom of the table, or :middle, when the data will be cropped at the middle of the table. (Default: :bottom)","category":"section"},{"location":"man/usage/#Backend-Specific-Keywords","page":"Usage","title":"Backend-Specific Keywords","text":"Please, see the backend sections for the keywords specific to each one.","category":"section"},{"location":"man/usage/#Specification-of-Table-Sections","page":"Usage","title":"Specification of Table Sections","text":"Here, we show how to specify the table sections using the keyword arguments.","category":"section"},{"location":"man/usage/#Column-Labels","page":"Usage","title":"Column Labels","text":"The specification of column labels must be a vector of elements. Each element in this vector must be another vector with a row of column labels. Notice that each vector must have the same size as the number of table columns.\n\nFor example, in a table with three columns, we can specify two rows of column labels by passing:\n\ncolumn_labels = [\n    [\"Column #1\",    \"Column #2\",    \"Column #3\"],\n    [\"Subcolumn #1\", \"Subcolumn #2\", \"Subcolumn #3\"]\n]\n\ninfo: Info\nIf the user wants only one row in the column labels, they can pass only a vector with the elements. The algorithm will encapsulate it inside another vector to match the API.\n\nAdjacent column labels can be merged using the keyword merge_column_label_cells. It must contain a vector of MergeCells objects. Each object defines a new merged cell. The MergeCells object has the following fields:\n\nrow::Int: Row index of the merged cell.\ncolumn::Int: Column index of the merged cell.\ncolumn_span::Int: Number of columns spanned by the merged cell.\ndata::String: Data of the merged cell.\nalignment::Symbol: Alignment of the merged cell. The available options are :l for left, :c for center, and :r for right. (Default: :c)\n\nHence, in our example, if we want to merge the columns 2 and 3 of the first column label row, we must pass:\n\nmerge_column_label_cells = [\n    MergeCells(1, 2, 2, \"Merged Column\", :c)\n]\n\nWe can pass the helpers MultiColumn and EmptyCells to column_labels to create merged columns more easily. In this case, MultiColumn specify a set of columns that will be merged, and EmptyCells specify a set of empty columns. However, notice that in this case we must set merge_column_label_cells to :auto.\n\nMultiColumn has the following fields:\n\ncolumn_span::Int: Number of columns spanned by the merged cell.\ndata::String: Data of the merged cell.\n\nEmptyCells has the following field:\n\nnumber_of_cells::Int: Number of columns that will be filled with empty cells.\n\nFor example, we can create the following column labels:\n\n┌───────────────────────────────────┬─────────────────┐\n│              Group #1             │     Group #2    │\n├─────────────────┬─────────────────┼────────┬────────┤\n│    Group #1.1   │    Group #1.2   │        │        │\n├────────┬────────┼────────┬────────┼────────┼────────┤\n│ Test 1 │ Test 2 │ Test 3 │ Test 4 │ Test 5 │ Test 6 │\n└────────┴────────┴────────┴────────┴────────┴────────┘\n\nby passing these arguments:\n\ncolumn_labels = [\n    [MultiColumn(4, \"Group #1\"), MultiColumn(2, \"Group #2\")],\n    [MultiColumn(2, \"Group #1.1\"), MultiColumn(2, \"Group #1.2\"), EmptyCells(2)],\n    [\"Test 1\", \"Test 2\", \"Test 3\", \"Test 4\", \"Test 5\", \"Test 6\"]\n]\n\nmerge_column_label_cells = :auto","category":"section"},{"location":"man/usage/#Row-Group-Labels","page":"Usage","title":"Row Group Labels","text":"The row group labels are specified by a Vector{Pair{Int, String}}. Each element defines a new row group label. The first element of the Pair is the row index of the row group and the second is the label. For example, [3 => \"Row Group #1\"] defines that before row 3, we have the row group label named \"Row Group #1\".","category":"section"},{"location":"man/usage/#Summary-Rows","page":"Usage","title":"Summary Rows","text":"The summary rows can be specified by a vector of Functions. Each element defines a summary row and the function must have one the following signature:\n\nf(col)\n\nf(data, j)\n\nwhere col is the current column, data is the table data, and j is the column index. In the first case, it must return the summary cell value for the referenced column. In the second case, it must return the summary cell value for the jth column. The algorithm will check if there is an applicable method for the first signature and use it if it exists. Otherwise, it will use the second signature. This verification is performed using the method applicable and col is obtained by @view data[:, j].\n\nIf we want, for example, to create two summary rows, one with the sum of the column values and other with their mean, we can define:\n\nsummary_rows = [\n    (data, j) -> sum(data[:, j]),\n    (data, j) -> sum(data[:, j]) / length(data[:, j])\n]\n\nWe can also use the first signature to simplify the code:\n\nusing Statistics\nsummary_rows = [sum, mean]\n\nnote: Note\nIf both signatures are available, the algorithm will prioritize the first one. To force the usage of the second, we can create an anonymous functions as follows: (data, i) -> f(data, i). This ensures that only the second method is available.","category":"section"},{"location":"man/usage/#Footnotes","page":"Usage","title":"Footnotes","text":"The footnotes are specified by a vector of Pair{FootnoteTuple, String}. Each element defines a new footnote. The FootnoteTuple is a Tuple with the following elements:\n\nsection::Symbol: Section to which the footnote must be applied. The available options are :column_label, :data, :row_label, :summary_row_label, and :summary_row_cell.\ni::Int: Row index of the footnote considering the desired section.\nj::Int: Column index of the footnote considering the desired section.\n\nThe second element of the Pair is the footnote text.\n\nHence, if we want to apply a foot note to a column label, a data cell, and a summary cell, we can define:\n\nfootnotes = [\n    (:column_label, 1, 2) => \"Footnote in column label\",\n    (:data, 2, 2) => \"Footnote in data\",\n    (:summary_row_cell, 1, 2) => \"Footnote in summary cell\"\n]","category":"section"},{"location":"man/usage/#Formatters","page":"Usage","title":"Formatters","text":"The keyword formatters can be used to pass functions to format the values in the columns. It must be a Vector{Function} in which each function has the following signature:\n\nf(v, i, j)\n\nwhere v is the value in the cell, i is the row number, and j is the column number. It must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.\n\nThis keyword can also be nothing, meaning that no formatter will be used.\n\nFor example, if we want to multiply all values in odd rows of the column 2 by π, the formatter should look like:\n\nformatters = [(v, i, j) -> (j == 2 && isodd(i)) ? v * π : v]\n\nIf multiple formatters are available, they will be applied in the same order as they are located in the vector. Thus, for the following formatters:\n\nformatters = [f1, f2, f3]\n\neach element v in the table (ith row and jth column) will be formatted by:\n\nv = f1(v, i, j)\nv = f2(v, i, j)\nv = f3(v, i, j)\n\nThus, the user must ensure that the type of v between the calls is compatible.\n\nPrettyTables.jl provides some predefined formatters for common tasks as described in the next section.","category":"section"},{"location":"man/usage/#Predefined-Formatters","page":"Usage","title":"Predefined Formatters","text":"fmt__printf(fmt_str::String[, columns::AbstractVector{Int}]) -> Function\n\nApply the format fmt_str (see the Printf standard library) to the elements in the columns specified in the vector columns. If columns is not specified, the format will be applied to the entire table.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\ndata = [f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\npretty_table(data; formatters = [fmt__printf(\"%5.3f\")])\n\npretty_table(data; formatters = [fmt__printf(\"%5.3f\", [1, 3])])\n\n\n\nfmt__round(digits::Int[, columns::AbstractVector{Int}]) -> Function\n\nRound the elements in the columns specified in the vector columns to the number of digits. If columns is not specified, the rounding will be applied to the entire table.\n\ndata = [f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\npretty_table(data; formatters = [fmt__round(1)])\n\npretty_table(data; formatters = [fmt__round(1, [1, 3])])\n\n\n\nfmt__latex_sn(m_digits::Int[, columns::AbstractVector{Int}]) -> Function\n\nFormat the numbers of the elements in the columns to a scientific notation using LaTeX. If columns is not present, the formatting will be applied to the entire table.\n\nThe number is first printed using Printf functions with the g modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument m_digits.\n\nThe formatted number will be wrapped in the object LatexCell. Hence, this formatter only makes sense if the selected backend is :latex.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\njulia> data = [10.0^(-i + j) for i in 1:6, j in 1:6]\n6×6 Matrix{Float64}:\n 1.0     10.0     100.0    1000.0   10000.0  100000.0\n 0.1      1.0      10.0     100.0    1000.0   10000.0\n 0.01     0.1       1.0      10.0     100.0    1000.0\n 0.001    0.01      0.1       1.0      10.0     100.0\n 0.0001   0.001     0.01      0.1       1.0      10.0\n 1.0e-5   0.0001    0.001     0.01      0.1       1.0\n\njulia> pretty_table(data; formatters = [fmt__latex_sn(1)], backend = :latex)\n\n(Image: fmt__latex_sn)","category":"section"},{"location":"man/usage/#PrettyTable-Object","page":"Usage","title":"PrettyTable Object","text":"The structure PrettyTable stores the data and configuration options required to print a table. The table to be displayed is specified by the data field, while any additional configuration options, corresponding to the keyword arguments accepted by the pretty_table function, can be set as fields with matching names.\n\nUsers can overload the show function to customize how the table is printed for different MIME types. PrettyTables.jl provides a default show method for printing tables to stdout.\n\nmatrix = [(i, j) for i in 1:4, j in 1:4]\n\npt = PrettyTable(matrix)\n\npt.table_format = TextTableFormat(; @text__no_vertical_lines)\n\npt\n\npt.formatters = [(v, i, j) -> \"$(v[1]) <=> $(v[2])\"]\n\npt\n\npt.formatters = nothing\n\npt","category":"section"},{"location":"man/html/html_backend/#HTML-Backend","page":"HTML Backend","title":"HTML Backend","text":"The HTML backend can be selected by passing the keyword backend = :html to the function pretty_table. In this case, we have the following additional keywords to configure the output.","category":"section"},{"location":"man/html/html_backend/#Keywords","page":"HTML Backend","title":"Keywords","text":"allow_html_in_cells::Bool: If true, the content of the cells can contain HTML code. This can be useful to render tables with more complex content, but it can also be a security risk if the content is not sanitized. (Default: false)\ncolumn_label_titles::Union{Nothing, AbstractVector}: Titles for the column labels. If nothing, no titles are added. If a vector is passed, it must have the same length as the number of column label rows. Each element in the vector can be nothing (no title for that row) or an element with the title for that row. Notice that this element will be converted to string using the function string. (Default: nothing)\nhighlighters::Vector{HtmlHighlighter}: Highlighters to apply to the table. For more information, see the section HTML Highlighters.\nline_breaks::Bool: If true, line breaks in the content of the cells (\\\\n) are replaced by the HTML tag <br>. (Default: false)\nmaximum_column_width::String: CSS width string for the maximum column width. (Default: \"\")\nminify::Bool: If true, the output HTML code is minified. (Default: false)\nstand_alone::Bool: If true, the output HTML code is a complete HTML document. (Default: false)\nstyle::HtmlTableStyle: Style of the table. For more information, see the section HTML Table Style.\ntable_class::String: Class for the table. (Default: \"\")\ntable_div_class::String: Class for the div containing the table. It is only used if wrap_table_in_div is true. (Default: \"\")\ntable_format::HtmlTableFormat: HTML table format used to render the table. For more information, see the section HTML Table Format.\ntop_left_string::String: String to put in the top left corner div. (Default: \"\")\ntop_right_string::String: String to put in the top right corner div. Notice that this information is replaced if we are printing the omitted cell summary. (Default: \"\")\nwrap_table_in_div::Bool: If true, the table is wrapped in a div. (Default: false)","category":"section"},{"location":"man/html/html_backend/#HTML-Highlighters","page":"HTML Backend","title":"HTML Highlighters","text":"A set of highlighters can be passed as a Vector{HtmlHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the highlighter. This function must return a Vector{Pair{String, String}} with properties compatible with the style field that will be applied to the highlighted cell.\n\nA HTML highlighter can be constructed using three helpers:\n\nHtmlHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nHtmlHighlighter(f::Function, decorations::NTuple{N, Pair{String, String})\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration, whereas the second lets the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the vector highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with values greater than 5 in red, and all the cells with values less than 5 in blue, we can define:\n\nhl_gt5 = HtmlHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"color\" => \"red\"]\n)\n\nhl_lt5 = HtmlHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"color\" => \"blue\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]","category":"section"},{"location":"man/html/html_backend/#HTML-Table-Format","page":"HTML Backend","title":"HTML Table Format","text":"The HTML table format is defined using an object of type HtmlTableFormat that contains the following fields:\n\ncss::String: CSS to be injected at the end of the <style> section.\ntable_width::String: Table width.\n\nNotice that this format is only applied if stand_alone = true.","category":"section"},{"location":"man/html/html_backend/#HTML-Table-Style","page":"HTML Backend","title":"HTML Table Style","text":"The HTML table style is defined using an object of type HtmlTableStyle that contains the following fields:\n\ntop_left_string::Vector{HtmlPair}: Style for the top left string.\ntop_right_string::Vector{HtmlPair}: Style for the top right string.\ntable::Vector{HtmlPair}: Style for the table.\ntitle::Vector{HtmlPair}: Style for the title.\nsubtitle::Vector{HtmlPair}: Style for the subtitle.\nrow_number_label::Vector{HtmlPair}: Style for the row number label.\nrow_number::Vector{HtmlPair}: Style for the row number.\nstubhead_label::Vector{HtmlPair}: Style for the stubhead label.\nrow_label::Vector{HtmlPair}: Style for the row label.\nrow_group_label::Vector{HtmlPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for the first line of the column labels. If a vector of Vector{HtmlPair}} is provided, each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for the rest of the column labels. If a vector of Vector{HtmlPair}} is provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::Vector{HtmlPair}: Style for the merged cells at the first column label line.\nmerged_column_label::Vector{HtmlPair}: Style for the merged cells at the rest of the column labels.\nsummary_row_cell::Vector{HtmlPair}: Style for the summary row cell.\nsummary_row_label::Vector{HtmlPair}: Style for the summary row label.\nfootnote::Vector{HtmlPair}: Style for the footnote.\nsource_notes::Vector{HtmlPair}: Style for the source notes.\nfirst_line_of_column_labels::Vector{HtmlPair}: Style for the first line of the column labels.\n\nEach field is a vector of HtmlPair, i.e. Pair{String, String}, describing properties and values compatible with the HTML style attribute.\n\nFor example, if we want the stubhead label to be bold and red, we must define:\n\nstyle = HtmlTableStyle(\n    stubhead_label = [\"font-weight\" => \"bold\", \"color\" => \"red\"]\n)","category":"section"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"Documentation for PrettyTables.jl.","category":"section"},{"location":"lib/library/#PrettyTables.ColumnTable","page":"Library","title":"PrettyTables.ColumnTable","text":"struct ColumnTable\n\nThis structure helps to access elements that comply with the column access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.Display","page":"Library","title":"PrettyTables.Display","text":"struct Display\n\nStore the information of the display and the current cursor position.\n\nnote: Note\nThis is not the real cursor position with respect to the display, but with respect to the point in which the table is printed.\n\nFields\n\nsize::Tuple{Int, Int}: Display size.\nrow::Int: Current row.\ncolumn::Int: Current column.\nhas_color::Bool: Indicates if the display has color support.\nbuf_line::IOBuffer:  Buffer that stores the current line.\nbuf::IOBuffer: Buffer that stores the entire output.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.EmptyCells","page":"Library","title":"PrettyTables.EmptyCells","text":"struct EmptyCells\n\nSpecification for adding a set of empty cells at the column label rows.\n\nFields\n\nnumber_of_cells::Int: Number of cells to add (must be greater than 0).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlHighlighter","page":"Library","title":"PrettyTables.HtmlHighlighter","text":"struct HtmlHighlighter\n\nDefine the default highlighter of a table when using the HTML back end.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return a Vector{Pair{String, String}} with properties   compatible with the style field that will be applied to the highlighted cell.\n_decoration::Dict{String, String}: The decoration to be applied to the highlighted cell   if the default fd is used.\n\nRemarks\n\nThis structure can be constructed using three helpers:\n\nHtmlHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nHtmlHighlighter(f::Function, decorations::NTuple{N, Pair{String, String})\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration, whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlTableFormat","page":"Library","title":"PrettyTables.HtmlTableFormat","text":"HtmlTableFormat\n\nFormat that will be used to print the HTML table. All parameters are strings compatible with the corresponding HTML property.\n\nFields\n\ncss::String: CSS to be injected at the end of the <style> section.\ntable_width::String: Table width.\n\nNotice that this format is only applied if stand_alone = true.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlTableStyle","page":"Library","title":"PrettyTables.HtmlTableStyle","text":"struct HtmlTableStyle\n\nDefine the style of the tables printed with the HTML back end.\n\nFields\n\ntop_left_string::Vector{HtmlPair}: Style for the top left string.\ntop_right_string::Vector{HtmlPair}: Style for the top right string.\ntable::Vector{HtmlPair}: Style for the table.\ntitle::Vector{HtmlPair}: Style for the title.\nsubtitle::Vector{HtmlPair}: Style for the subtitle.\nrow_number_label::Vector{HtmlPair}: Style for the row number label.\nrow_number::Vector{HtmlPair}: Style for the row number.\nstubhead_label::Vector{HtmlPair}: Style for the stubhead label.\nrow_label::Vector{HtmlPair}: Style for the row label.\nrow_group_label::Vector{HtmlPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for   the first line of the column labels. If a vector of Vector{HtmlPair}} is provided,   each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for the rest of   the column labels. If a vector of Vector{HtmlPair}} is provided, each column label   will use the corresponding style.\nfirst_line_merged_column_label::Vector{HtmlPair}: Style for the merged cells at the   first column label line.\nmerged_column_label::Vector{HtmlPair}: Style for the merged cells at the rest of the   column labels.\nsummary_row_cell::Vector{HtmlPair}: Style for the summary row cell.\nsummary_row_label::Vector{HtmlPair}: Style for the summary row label.\nfootnote::Vector{HtmlPair}: Style for the footnote.\nsource_notes::Vector{HtmlPair}: Style for the source notes.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexCell","page":"Library","title":"PrettyTables.LatexCell","text":"struct LatexCell\n\nDefines a table cell that contains LaTeX code. It can be created using the macro @latex_cell_str.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexHighlighter","page":"Library","title":"PrettyTables.LatexHighlighter","text":"LatexHighlighter\n\nDefines the default highlighter of a table when using the LaTeX backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd: A function with the signature f(h, data, i, j)::Vector{String} in which h is the   highlighter object, data is the matrix, and (i, j) is the element position in the   table. This function should return a vector with the LaTeX environments to be applied to   the cell.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nLatexHighlighter(f::Function, envs::Vector{String})\n\nwhere it will apply recursively all the LaTeX environments in envs to the highlighted text, and\n\nLatexHighlighter(f::Function, fd::Function)\n\nwhere the user select the desired decoration by specifying the function fd.\n\nThus, for example:\n\nLatexHighlighter((data, i, j) -> true, [\"textbf\", \"small\"])\n\nwill wrap all the cells in the table in the following environment:\n\n\\textbf{\\small{<Cell text>}}\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexTableFormat","page":"Library","title":"PrettyTables.LatexTableFormat","text":"struct LatexTableFormat\n\nDefine the format of the tables printed with the LaTeX back end.\n\nFields\n\nborders::LatexTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the   beginning of the table.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn on bottom of the merged column labels using \\cline.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn   after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each data row index listed in this vector. If the symbol :all is passed, a   horizontal line will be drawn after every data column. If the symbol :none is passed,   no horizontal lines will be drawn after the data rows.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be   drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be   drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn   after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there is no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn   after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the   beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn   after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn   after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will be   drawn after each data column index listed in this vector. If the symbol :all is   passed, a vertical line will be drawn after every data column. If the symbol :none is   passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after   the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be   drawn after the continuation column.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexTableStyle","page":"Library","title":"PrettyTables.LatexTableStyle","text":"struct LatextTableStyle\n\nDefine the style of the tables printed with the latex back end.\n\nFields\n\ntitle::LatexEnvironments: Latex environments with the style for the title.\nsubtitle::LatexEnvironments: Latex environments with the style for the subtitle.\nrow_number_label::LatexEnvironments: Latex environments with the style for the row   number label.\nrow_number::LatexEnvironments: Latex environments with the style for the row numbers.\nstubhead_label::LatexEnvironments:  Latex environments with the style for the stubhead   label.\nrow_label::LatexEnvironments: Latex environments with the style for the row labels.\nrow_group_label::LatexEnvironments: Latex environments with the style for the row group   label.\nfirst_line_column_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex   environments with the style for the first line of the column labels. If a vector of   LatexEnvironments is provided, each column label in the first line will use the   corresponding style.\ncolumn_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex environments   with the style for the rest of the column labels. If a vector of LatexEnvironments is   provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::LatexEnvironments: Latex environments with the style for   the merged cells at the first column label line.\nmerged_column_label::LatexEnvironments: Latex environments with the style for the merged   cells at the rest of the column labels.\nsummary_row_cell::LatexEnvironments: Latex environments with the style for the summary   row cell.\nsummary_row_label::LatexEnvironments: Latex environments with the style for the summary   row label.\nfootnote::LatexEnvironments: Latex environments with the style for the footnotes.\nsource_note::LatexEnvironments: Latex environments with the style for the source notes.\nomitted_cell_summary::LatexEnvironments: Latex environments with the style for the   omitted cell summary.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownHighlighter","page":"Library","title":"PrettyTables.MarkdownHighlighter","text":"struct MarkdownHighlighter\n\nDefines the default highlighter of a table when using the markdown backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the MarkdownStyle to be applied to the   cell that must be highlighted.\n_decoration::MarkdownStyle: The decoration to be applied to the highlighted cell if   the default fd is used.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nMarkdownHighlighter(f::Function, decoration::MarkdownStyle)\n\nMarkdownHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownStyle","page":"Library","title":"PrettyTables.MarkdownStyle","text":"struct MarkdownStyle\n\nStructure that defines styling parameters to a table cell in the markdown back end.\n\nFields\n\nbold::Bool: Bold text.\nitalic::Bool: Italic text.\nstrikethrough::Bool: Strikethrough.\ncode::Bool: Code.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownTableFormat","page":"Library","title":"PrettyTables.MarkdownTableFormat","text":"struct MarkdownTableFormat\n\nDefine the format of the tables printed with the markdown back end.\n\nFields\n\ntitle_heading_level::Int: Title heading level.\nsubtitle_heading_level::Int: Subtitle heading level.\nhorizontal_line_char::Char: Character used to draw the horizontal line.\nline_before_summary_rows::Bool: Whether to draw a line before the summary rows.\ncompact_table::Bool: If true, the table is printed in a compact format without extra   spaces between columns.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownTableStyle","page":"Library","title":"PrettyTables.MarkdownTableStyle","text":"struct MarkdownTableStyle\n\nDefine the style of the tables printed with the markdown back end.\n\nFields\n\nrow_number_label::MarkdownStyle: Style for the row number label.\nrow_number::MarkdownStyle: Style for the row number.\nstubhead_label::MarkdownStyle: Style for the stubhead label.\nrow_label::MarkdownStyle: Style for the row label.\nrow_group_label::MarkdownStyle: Style for the row group label.\nfirst_line_column_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the   first line of the column label. If a vector of MarkdownStyle is provided, each column   label in the first line will use the corresponding style.\ncolumn_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the column label.   If a vector of MarkdownStyle is provided, each column label will use the corresponding   style.\nsummary_row_label::MarkdownStyle: Style for the summary row label.\nsummary_row_cell::MarkdownStyle: Style for the summary row cell.\nfootnote::MarkdownStyle: Style for the footnote.\nsource_note::MarkdownStyle: Style for the source note.\nomitted_cell_summary::MarkdownStyle: Style for the omitted cell summary.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MultiColumn","page":"Library","title":"PrettyTables.MultiColumn","text":"struct MultiColumn\n\nSpecification for merging columns at the column label rows.\n\nFields\n\ncolumn_span::Int: Number of columns to merge (must be greater than 1).\ndata::Any: Merged cell data.\nalignment::Symbol: Merge cell alignment.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrettyTable","page":"Library","title":"PrettyTables.PrettyTable","text":"mutable struct PrettyTable\n\nThis structure stores the data and configuration options required to print a table. The table to be displayed is specified by the data field, while any additional configuration options, corresponding to the keyword arguments accepted by the pretty_table function, can be set as fields with matching names.\n\nUsers can overload the show function to customize how the table is printed for different MIME types. PrettyTables.jl provides a default show method for printing tables to stdout.\n\nFields\n\ndata::Any: The table to be displayed.\nconfigurations::Dict{Symbol, Any}: A dictionary containing configuration options for   the table. The keys are symbols corresponding to the keyword arguments accepted by the   pretty_table function, and the values are the corresponding settings. It is not   recommended to add configurations here directly. Use the native Julia syntax to set   fields in the PrettyTable object instead.\n\nExtended Help\n\nExamples\n\njulia> pt = PrettyTable(ones(3, 3))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n└────────┴────────┴────────┘\n\njulia> pt.table_format = TextTableFormat(; @text__no_vertical_lines)\nTextTableFormat(TextTableBorders('┐', '┌', '└', '┘', '┬', '├', '┤', '┼', '┴', '│', '─'), true, :none, true, :none, true, true, true, true, true, false, false, false, :none, false, false, true, 0)\n\njulia> pt\n────────────────────────\n Col. 1  Col. 2  Col. 3\n────────────────────────\n    1.0     1.0     1.0\n    1.0     1.0     1.0\n    1.0     1.0     1.0\n────────────────────────\n\njulia> pt.data = 2 .* ones(3, 3)\n3×3 Matrix{Float64}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> pt\n────────────────────────\n Col. 1  Col. 2  Col. 3\n────────────────────────\n    2.0     2.0     2.0\n    2.0     2.0     2.0\n    2.0     2.0     2.0\n────────────────────────\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrintingTableState","page":"Library","title":"PrettyTables.PrintingTableState","text":"struct PrintingTableState\n\nThis structure stores the current state of the printing process.\n\nFields\n\nstate::Int: The current state of the printing process.\ni::Int: The current row index.\nj::Int: The current column index.\nrow_section::Symbol: The current or the next row section.\n\nwarning: Warning\nThe field row_section is used to determine the next state of the printing process. It must not be used to verify the current or the next row section as the meaning can change depending on the current state. Instead, always used the function _next to obtain the next row section.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.RowTable","page":"Library","title":"PrettyTables.RowTable","text":"struct RowTable\n\nThis structure helps to access elements that comply with the row access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextHighlighter","page":"Library","title":"PrettyTables.TextHighlighter","text":"struct TextHighlighter\n\nDefines the default highlighter of a table when using the text backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return the Crayon to be applied to the cell that must   be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd   is used.\n\nRemarks\n\nThis structure can be constructed using three helpers:\n\nTextHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nTextHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nTextHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextTableBorders","page":"Library","title":"PrettyTables.TextTableBorders","text":"struct TextTableBorders\n\nDefine the format of the borders in the tables printed with the text back end.\n\nFields\n\nup_right_corner::Char: Character in the up right corner.\nup_left_corner::Char: Character in the up left corner.\nbottom_left_corner::Char: Character in the bottom left corner.\nbottom_right_corner::Char: Character in the bottom right corner.\nup_intersection::Char: Character in the intersection of lines in the up part.\nleft_intersection::Char: Character in the intersection of lines in the left part.\nright_intersection::Char: Character in the intersection of lines in the right part.\nmiddle_intersection::Char: Character in the intersection of lines in the middle of the   table.\nbottom_intersection::Char: Character in the intersection of the lines in the bottom   part.\ncolumn::Char: Character in a vertical line inside the table.\nrow::Char: Character in a horizontal line inside the table.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextTableFormat","page":"Library","title":"PrettyTables.TextTableFormat","text":"struct TextTableFormat\n\nDefine the format of the tables printed with the text back end.\n\nFields\n\nborders::TextTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the   beginning of the table.\nhorizontal_lines_at_column_labels::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each column label row index listed in this vector. If the symbol :all is   passed, a horizontal line will be drawn after every column label. If the symbol :none   is passed, no horizontal lines will be drawn.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn at the merged column labels. Notice that the horizontal line drawn using the   option horizontal_lines_at_column_labels has precedence over this one.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn   after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each data row index listed in this vector. If the symbol :all is passed, a   horizontal line will be drawn after every data column. If the symbol :none is passed,   no horizontal lines will be drawn.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be   drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be   drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn   after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there is no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn   after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the   beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn   after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn   after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will be   drawn after each data column index listed in this vector. If the symbol :all is   passed, a vertical line will be drawn after every data column. If the symbol :none is   passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after   the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be   drawn after the continuation column.\nellipsis_line_skip::Integer: Number of lines to skip when printing an ellipsis.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextTableStyle","page":"Library","title":"PrettyTables.TextTableStyle","text":"struct TextTableStyle\n\nDefine the style of the tables printed with the text back end.\n\nFields\n\ntitle::Crayon: Crayon with the style for the title.\nsubtitle::Crayon: Crayon with the style for the subtitle.\nrow_number_label::Crayon: Crayon with the style for the row number label.\nrow_number::Crayon: Crayon with the style for the row numbers.\nstubhead_label::Crayon:  Crayon with the style for the stubhead label.\nrow_label::Crayon: Crayon with the style for the row labels.\nrow_group_label::Crayon: Crayon with the style for the row group label.\nfirst_line_column_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style   for the first column label lines. If a vector of crayons is passed, it must have the   same length as the number columns in the table.\ncolumn_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style for the   rest of the column labels. If a vector of crayons is passed, it must have the same   length as the number of columns in the table.\nfirst_line_merged_column_label::Crayon: Crayon with the style for the merged cells at   the first column label line.\nmerged_column_label::Crayon: Crayon with the style for the merged cells at the rest of   the column labels.\nsummary_row_cell::Crayon: Crayon with the style for the summary row cell.\nsummary_row_label::Crayon: Crayon with the style for the summary row label.\nfootnote::Crayon: Crayon with the style for the footnotes.\nsource_note::Crayon: Crayon with the style for the source notes.\nomitted_cell_summary::Crayon: Crayon with the style for the omitted cell summary.\ntable_border::Crayon: Crayon with the style for the table border.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TypstCaption","page":"Library","title":"PrettyTables.TypstCaption","text":"struct TypstCaption\n\nDefine a Typst caption configuration to be used by the Typst backend.\n\nFields\n\ncaption::String: Caption text.\nkind::Union{Auto, String}: Caption kind forwarded to Typst (for example, auto or a   custom kind).\nsupplement::Union{Nothing, String}: Optional caption supplement.\ngap::Union{Auto, AbstractTypstLength}: Gap between figure content and caption.\nposition::Union{Nothing, String}: Optional caption position.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TypstHighlighter","page":"Library","title":"PrettyTables.TypstHighlighter","text":"struct TypstHighlighter\n\nDefine the default highlighter of a table when using the Typst back end.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return a Vector{Pair{String, String}} with properties   compatible with the style field that will be applied to the highlighted cell.\n_decoration::Dict{String, String}: The decoration to be applied to the highlighted cell   if the default fd is used.\n\nRemarks\n\nThis structure can be constructed using three helpers:\n\nTypstHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nTypstHighlighter(f::Function, decorations::NTuple{N, Pair{String, String})\n\nTypstHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration, whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TypstTableStyle","page":"Library","title":"PrettyTables.TypstTableStyle","text":"struct TypstTableStyle\n\nDefine the style of the tables printed with the Typst back end.\n\nFields\n\ntable::Vector{TypstPair}: Style for the table.\ntitle::Vector{TypstPair}: Style for the title.\nsubtitle::Vector{TypstPair}: Style for the subtitle.\nrow_number_label::Vector{TypstPair}: Style for the row number label.\nrow_number::Vector{TypstPair}: Style for the row number.\nstubhead_label::Vector{TypstPair}: Style for the stubhead label.\nrow_label::Vector{TypstPair}: Style for the row label.\nrow_group_label::Vector{TypstPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for   the first line of the column labels. If a vector of Vector{TypstPair}} is provided,   each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for the rest of   the column labels. If a vector of Vector{TypstPair}} is provided, each column label   will use the corresponding style.\nfirst_line_merged_column_label::Vector{TypstPair}: Style for the merged cells at the   first column label line.\nmerged_column_label::Vector{TypstPair}: Style for the merged cells at the rest of the   column labels.\nomitted_cell_summary::Vector{TypstPair}: Style for the omitted cell summary.\nsummary_row_cell::Vector{TypstPair}: Style for the summary row cell.\nsummary_row_label::Vector{TypstPair}: Style for the summary row label.\nfootnote::Vector{TypstPair}: Style for the footnote.\nsource_notes::Vector{TypstPair}: Style for the source notes.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables._align_column_with_regex!-Tuple{AbstractVector{String}, Vector{Regex}, Symbol}","page":"Library","title":"PrettyTables._align_column_with_regex!","text":"_align_column_with_regex!(column::AbstractVector{String}, alignment_anchor_regex::Vector{Regex}, alignment_anchor_fallback::Symbol) -> Int\n_align_column_with_regex!(column::AbstractVector{Vector{String}}, alignment_anchor_regex::Vector{Regex}, alignment_anchor_fallback::Symbol) -> Int\n\nAlign the lines in the column at the first match obtained by the regex vector alignment_anchor_regex, falling back to alignment_anchor_fallback if a match is not found for a specific line.\n\nThis function returns the largest cell width.\n\nnote: Note\nIn the second signature, each element in column must be a vector of Strings, where each string is a line.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._align_multline_column_with_regex!-Tuple{AbstractVector{String}, Vector{Regex}, Symbol}","page":"Library","title":"PrettyTables._align_multline_column_with_regex!","text":"_align_multline_column_with_regex!(column::AbstractVector{String}, alignment_anchor_regex::Vector{Regex}, alignment_anchor_fallback::Symbol,) -> Int\n\nSimilar to _align_column_with_regex!, but each row will be split into multiple lines at  before applying the alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._aprint","page":"Library","title":"PrettyTables._aprint","text":"_aprint(buf::IO, str::String, indentation_level::Int = 0, indentation_spaces::Int = 2; kwargs...) -> Nothing\n\nPrint str in the buffer buf aligned to the indentation_level. Each indentation level contains a number of spaces given by indentation_spaces.\n\nKeywords\n\nminify::Bool: If true, the output will be minified, meaning that it will be printed   without indentation spaces or line breaks.   (Default: false)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._aprintln","page":"Library","title":"PrettyTables._aprintln","text":"_aprintln(buf::IO, str::String, indentation_level::Int = 0, indentation_spaces::Int = 2; kwargs...) -> Nothing\n\nPrint str in the buffer buf aligned to the indentation_level and adding a line break at the end. Each indentation level contains a number of spaces given by indentation_spaces.\n\nKeywords\n\nminify::Bool: If true, the output will be minified, meaning that it will be printed   without indentation spaces or line breaks.   (Default: false)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._auto_wrap-Tuple{AbstractString, Int64}","page":"Library","title":"PrettyTables._auto_wrap","text":"_auto_wrap(str::AbstractString, field_width::Int) -> String\n\nAutowrap the string str given a field_width.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._column_label_limits-Tuple{PrettyTables.TableData, Int64, Int64}","page":"Library","title":"PrettyTables._column_label_limits","text":"_column_label_limits(table_data::TableData, i::Int, j::Int) -> Tuple{Int, Int}\n\nReturn the limits of the column label cell at (i, j) in table_data. If the cell is not merged, the limits are just (j, j). If the cell is merged, the limits are the start and end of the merged cell, which is defined by the merge_column_label_cells field of table_data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._compact_type_str-Tuple{Any}","page":"Library","title":"PrettyTables._compact_type_str","text":"_compact_type_str(T) -> String\n\nReturn a string with a compact representation of type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._current_cell-Tuple{Symbol, PrettyTables.PrintingTableState, PrettyTables.TableData}","page":"Library","title":"PrettyTables._current_cell","text":"_current_cell(action::Symbol, state::PrintingTableState, table_data::TableData) -> Any\n\nReturn the current data specified by the action and the current printing table state of table_data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._current_cell_alignment-Tuple{Symbol, PrettyTables.PrintingTableState, PrettyTables.TableData}","page":"Library","title":"PrettyTables._current_cell_alignment","text":"_current_cell_alignment(action::Symbol, state::PrintingTableState, table_data::TableData) -> Symbol\n\nReturn the alignment where the current cell specified by the action and the current printing table state of table_data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._current_cell_footnotes-Tuple{PrettyTables.TableData, Symbol, Int64, Int64}","page":"Library","title":"PrettyTables._current_cell_footnotes","text":"_current_cell_footnotes(table_data::TableData, cell_type::Symbol, i::Int, j::Int) -> Union{Nothing, Vector{Int}}\n\nReturn an array of integers with the footnotes defined in table_data for the cell_type at position (i, j).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._current_table_row_section_info-Tuple{Symbol, Symbol, Number}","page":"Library","title":"PrettyTables._current_table_row_section_info","text":"_current_table_row_section_info(rs::Symbol, action::Symbol, i::Number) -> String\n\nGenerate a descriptive string for the current table row section specified by the rs and action parameters, along with the row index i.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._data_column_alignment-Tuple{PrettyTables.TableData, Int64}","page":"Library","title":"PrettyTables._data_column_alignment","text":"_data_column_alignment(table_data::TableData, i::Int) -> Symbol\n\nReturn the alignment of the ith column.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._guess_column_labels-Tuple{Union{PrettyTables.ColumnTable, PrettyTables.RowTable}}","page":"Library","title":"PrettyTables._guess_column_labels","text":"_guess_column_labels(data) -> Vector{Vector{String}}\n\nGuess the column label associated with data in case the user did not pass a default value.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._has_footnotes-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._has_footnotes","text":"_has_footnotes(table_data::TableData) -> Bool\n\nReturn whether table_data has footnotes.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._has_merged_cells-Tuple{PrettyTables.TableData, Int64}","page":"Library","title":"PrettyTables._has_merged_cells","text":"_has_merged_cells(table_data::TableData, i::Int) -> Bool\n\nReturn whether table_data has merged cells in line i.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._has_row_group_labels-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._has_row_group_labels","text":"_has_row_group_labels(table_data::TableData)\n\nReturn whether table_data has row group lables.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._has_row_labels-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._has_row_labels","text":"_has_row_labels(table_data::TableData) -> Bool\n\nReturn whether table_data has row labels.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._has_summary_rows-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._has_summary_rows","text":"_has_summary_rows(table_data::TableData) -> Bool\n\nReturn whether table_data has summary rows.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__add_alignment_to_style!-Tuple{Vector{Pair{String, String}}, Symbol}","page":"Library","title":"PrettyTables._html__add_alignment_to_style!","text":"_html__add_alignment_to_style!(style::Vector{HtmlPair}, alignment::Symbol) -> Nothing\n\nAdd the HTML alignment property to style according to the alignment symbol.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__cell_to_str-Tuple{Any, IOContext, Val{:print}}","page":"Library","title":"PrettyTables._html__cell_to_str","text":"_html__cell_to_str(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nConvert the cell to a string using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__close_tag-Tuple{String}","page":"Library","title":"PrettyTables._html__close_tag","text":"_html__close_tag(tag::String) -> String\n\nCreate the string that closes the HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__create_style-Tuple{Vector{Pair{String, String}}}","page":"Library","title":"PrettyTables._html__create_style","text":"_html__create_style(style::Vector{HtmlPair}) -> String\n\nCreate the HTML style string using the information in the dictionary style.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__create_tag-Tuple{String, String}","page":"Library","title":"PrettyTables._html__create_tag","text":"_html__create_tag(tag::String, content::String; kwargs...) -> String\n\nCreate an HTML tag with the content.\n\nKeywords\n\nproperties::Union{Nothing, Vector{HtmlPair}}: Tag properties.   (Default: nothing)\nstyle::Union{Nothing, Vector{HtmlPair}}: Tag style.   (Default: nothing)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__escape_str","page":"Library","title":"PrettyTables._html__escape_str","text":"_html__escape_str(@nospecialize(io::IO), s::AbstractString, replace_newline::Bool = false, escape_html_chars::Bool = true) -> Nothing\n_html__escape_str(s::AbstractString, replace_newline::Bool = false, escape_html_chars::Bool = true) -> String\n\nPrint the string s in io escaping the characters for the HTML back end. If io is omitted, the escaped string is returned.\n\nIf replace_newline is true,  is replaced with <br>. Otherwise, it is escaped, leading to \\n.\n\nIf escape_html_chars is true, &, <, >, \", and '  will be replaced by HTML sequences.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._html__open_tag-Tuple{String}","page":"Library","title":"PrettyTables._html__open_tag","text":"_html__open_tag(tag::String; kwargs...) -> String\n\nCreate the string that opens the HTML tag.\n\nKeywords\n\nproperties::Union{Nothing, Vector{HtmlPair}}: Tag properties.   (Default: nothing)\nstyle::Union{Nothing, Vector{HtmlPair}}: Tag style.   (Default: nothing)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__print_top_bar_section-Tuple{IOContext, String, String, Union{Nothing, Vector{Pair{String, String}}}, Int64, Int64}","page":"Library","title":"PrettyTables._html__print_top_bar_section","text":"_html__print_top_bar_section(buf::IOContext, position::String, text::String, decoration::Union{Nothing, Vector{HtmlPair}}, il::Int, ns::Int; kwargs...)\n\nPrint the HTML top bar section.\n\nArguments\n\nbuf::IOContext: Buffer to which the top bar will be printed.\nposition::String: Buffer position. It can be \"left\" or \"right\".\ntext::String: Text to be printed in the selected position.\ndecoration::Union{Nothing, Vector{HtmlPair}}: Text decoration.\nil::Int: Indentation level.\nns::Int: Number of space per indentation level.\n\nKeywords\n\nminify::Bool: If true, the output will be minified.   (Default: false)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._html__render_cell-Tuple{Any, IOContext, Union{Val{:print}, Val{:show}}}","page":"Library","title":"PrettyTables._html__render_cell","text":"_html__render_cell(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}; kwargs...) -> String\n\nRender the cell in HTML back end using a specific context and renderer.\n\nKeywords\n\nallow_html_in_cells::Bool: If true, we will not escape HTML sequences in the rendered   string.   (Default: false)\nline_breaks::Bool: If true, we will replace \\n with <br>.   (Default: false)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._is_column_label_cell_merged-Tuple{PrettyTables.TableData, Int64, Int64}","page":"Library","title":"PrettyTables._is_column_label_cell_merged","text":"_is_column_label_cell_merged(table_data::TableData, i::Int, j::Int) -> Bool\n\nReturn whether the cell at (i, j) is a merged column label cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._is_horizontally_cropped-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._is_horizontally_cropped","text":"_is_horizontally_cropped(table_data::TableData) -> Bool\n\nReturn whether table_data is horizontally cropped, meaning that a continuation column must be printed.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._is_vertically_cropped-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._is_vertically_cropped","text":"_is_vertically_cropped(table_data::TableData) -> Bool\n\nReturn whether table_data is vertically cropped, meaning that a continuation row must be printed.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._latex__add_environments-Tuple{String, Vector{String}}","page":"Library","title":"PrettyTables._latex__add_environments","text":"_latex__add_environments(str::String, envs::Union{Nothing, Vector{String}}) -> String\n\nApply the latex environments in envs to the string str. If envs is nothing, it returns str unchanged.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._latex__alignment_to_str-Tuple{Symbol}","page":"Library","title":"PrettyTables._latex__alignment_to_str","text":"_latex__alignment_to_str(a::Symbol) -> String\n\nConvert the alignment a to the corresponding string for LaTeX.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._latex__cell_to_str-Tuple{Any, IOContext, Val{:print}}","page":"Library","title":"PrettyTables._latex__cell_to_str","text":"_latex__cell_to_str(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nConvert the cell to a string using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._latex__escape_str","page":"Library","title":"PrettyTables._latex__escape_str","text":"_latex__escape_str(@nospecialize(io::IO), s::AbstractString, replace_newline::Bool = false, escape_latex_chars::Bool = true) -> Nothing\n_latex__escape_str(s::AbstractString, replace_newline::Bool = false, escape_latex_chars::Bool = true) -> String\n\nPrint the string s in io escaping the characters for the latex back end. If io is omitted, the escaped string is returned.\n\nIf replace_newline is true,  is replaced with <br>. Otherwise, it is escaped, leading to \\n.\n\nIf escape_latex_chars is true, &, <, >, \", and '  will be replaced by latex sequences.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._latex__render_cell-Tuple{Any, IOContext, Union{Val{:print}, Val{:show}}}","page":"Library","title":"PrettyTables._latex__render_cell","text":"_latex__render_cell(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}; kwargs...) -> String\n\nRender the cell in latex back end using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._latex__table_header_description-Tuple{PrettyTables.TableData, LatexTableFormat, AbstractVector{Int64}}","page":"Library","title":"PrettyTables._latex__table_header_description","text":"_latex__table_header_description(td::TableData, tf::LatexTableFormat, vertical_lines_at_data_columns::AbstractVector{Int}) -> String\n\nCreate the LaTeX table header description with the column alignments and vertical lines considering the table data td, table format tf, and the processed information about vertical lines at data columns vertical_lines_at_data_columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__apply_style-Tuple{MarkdownStyle, String}","page":"Library","title":"PrettyTables._markdown__apply_style","text":"_markdown__apply_style(d::MarkdownStyle, str::String) -> String\n\nApply the markdown style s to str.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__cell_to_str-Tuple{Any, IOContext, Val{:print}}","page":"Library","title":"PrettyTables._markdown__cell_to_str","text":"_markdown__cell_to_str(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nConvert the cell to a string using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__column_alignment_str-Tuple{Int64, Symbol}","page":"Library","title":"PrettyTables._markdown__column_alignment_str","text":"_markdown__column_alignment_str(column_width::Int, alignment::Symbol) -> String\n\nCompose the markdown alignment string given a column with width column_width. The possible values for alignment are:\n\n:l: Left alignment.\n:c: Center alignment.\n:r: Right alignment.\n:n: No alignment information will be added to the string.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__escape_str-Tuple{IO, AbstractString, Bool, Bool}","page":"Library","title":"PrettyTables._markdown__escape_str","text":"_markdown__escape_str(@nospecialize(io::IO), s::AbstractString, replace_newline::Bool = false, escape_markdown_chars::Bool = true) -> Nothing\n_markdown__escape_str(s::AbstractString, replace_newline::Bool = false, escape_markdown_chars::Bool = true) -> String\n\nPrint the string s in io escaping the characters for the markdown back end. If io is omitted, the escaped string is returned.\n\nIf replace_newline is true,  is replaced with <br>. Otherwise, it is escaped, leading to \\n.\n\nIf escape_markdown_chars is true, *, _, ~, \\, and|`  will be escaped.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__print_aligned-Tuple{IOContext, String, Int64, Symbol}","page":"Library","title":"PrettyTables._markdown__print_aligned","text":"_markdown__print_aligned(buf::IOContext, str::String, cell_width::Int, alignment::Symbol) -> Nothing\n\nPrint str to the buffer buf with alignment considering the cell_width.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__print_header_separator-Tuple{IOContext, PrettyTables.TableData, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._markdown__print_header_separator","text":"_markdown__print_header_separator(buf::IOContext, table_data::TableData, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}) -> Nothing\n\nPrint the markdown header separator with the column alignment information.\n\nArguments\n\nbuf::IOContext: Buffer where the separator will be printed.\ntable_data::TableData: Table data.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Widths of the printed data columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__print_row_group_line-Tuple{IOContext, String, PrettyTables.TableData, Char, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._markdown__print_row_group_line","text":"_markdown__row_group_line(buf::IOContext, row_group_label::String, table_data::TableData, char::Char, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}) -> Nothing\n\nPrint the row group line to buf.\n\nArguments\n\nbuf::IOContext: Buffer where the separator will be printed.\nrow_group_label::String: Row group label.\ntable_data::TableData: Table data.\nchar::Char: Character used for the separation line.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Widths of the printed data columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__print_separation_line-Tuple{IOContext, PrettyTables.TableData, Char, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._markdown__print_separation_line","text":"_markdown__row_separation_line(buf::IOContext, table_data::TableData, char::Char, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}) -> Nothing\n\nPrint a row separation line to buf.\n\nArguments\n\nbuf::IOContext: Buffer where the separator will be printed.\ntable_data::TableData: Table data.\nchar::Char: Character used for the separation line.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Widths of the printed data columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__render_cell-Tuple{Any, IOContext, Union{Val{:print}, Val{:show}}}","page":"Library","title":"PrettyTables._markdown__render_cell","text":"_markdown__render_cell(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}; kwargs...) -> String\n\nRender the cell in markdown back end using a specific context and renderer.\n\nKeywords\n\nallow_markdown_in_cells::Bool: If true, we will not escape markdown sequences in the rendered   string.   (Default: false)\nline_breaks::Bool: If true, we will replace \\n with <br>.   (Default: false)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._markdown__style_textwidth-Tuple{MarkdownStyle}","page":"Library","title":"PrettyTables._markdown__style_textwidth","text":"_markdown__style_textwidth(s::MarkdownStyle) -> Int\n\nReturn the additional textwidth required to apply the markdown style s.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._maximum_textwidth_per_line-Tuple{AbstractString}","page":"Library","title":"PrettyTables._maximum_textwidth_per_line","text":"_maximum_textwidth_per_line(str::AbstractString) -> Int\n\nCompute the maximum textwidth per line of the string str.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._next-Tuple{PrettyTables.PrintingTableState, PrettyTables.TableData}","page":"Library","title":"PrettyTables._next","text":"_next(state::PrintingTableState, table_data::TableData) -> Union{Symbol, Nothing}, PrintingTableState\n\nReturn the action the back end must perform and the new print table state given the current state and the table_data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._number_of_printed_columns-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._number_of_printed_columns","text":"_number_of_printed_columns(table_data::TableData) -> Int\n\nReturn the number of printed columns in table_data, which includes the continuation row.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._number_of_printed_data_columns-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._number_of_printed_data_columns","text":"_number_of_printed_data_columns(table_data::TableData) -> Int\n\nReturn the number of printed data columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._number_of_printed_data_rows-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._number_of_printed_data_rows","text":"_number_of_printed_data_rows(table_data::TableData) -> Int\n\nReturn the number of printed data rows.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._omitted_cell_summary-Tuple{Int64, Int64}","page":"Library","title":"PrettyTables._omitted_cell_summary","text":"_omitted_cell_summary(num_omitted_rows::Int, num_omitted_columns::Int) -> String\n\nReturn the omitted cell summary string when there are num_omitted_rows omitted data rows and num_omitted_columns omitted data columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._omitted_cell_summary-Tuple{PrettyTables.TableData, PrettyTables.PrintingSpec}","page":"Library","title":"PrettyTables._omitted_cell_summary","text":"_omitted_cell_summary(table_data::TableData, pspec::PrintingSpec) -> String\n\nReturn the omitted cell summary related to the table_data and printing specification pspec.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._preprocess_data-Tuple{AbstractVecOrMat}","page":"Library","title":"PrettyTables._preprocess_data","text":"_preprocess_data(data::Any) -> Any\n\nPreprocess the data for printing. This function throws an error if data is not supported by PrettyTables.jl.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._print_row_group_label-Tuple{PrettyTables.TableData, Int64}","page":"Library","title":"PrettyTables._print_row_group_label","text":"_print_row_group_label(table_data::TableData, i::Int) -> Bool\n\nReturn whether we must print a row group label of table_data in line i.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._printing_backend-Tuple{Val{:latex}, PrettyTables.PrintingSpec}","page":"Library","title":"PrettyTables._printing_backend","text":"_printing_backend(::Val{backend}, pspec::PrintingSpec; is_stdout::Bool, kwargs...)\n\nCall the appropriate printing backend using the printing specification pspec. The keyword argument is_stdout is true if the user wants to output the table to the stdout.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._process_merge_column_label_specification-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:(AbstractVector)","page":"Library","title":"PrettyTables._process_merge_column_label_specification","text":"_process_merge_column_label_specification(column_labels::Vector{T}, num_columns::Int) where T <: AbstractVector -> Vector{Vector{Any}}, Vector{MergeCells}\n\nProcess the column label specification by replacing MultiColumn objects in column_labels and adding the correct specification to merge_column_label_cells. This function returns the new objects that must replace the olds column_labels and the merge_column_label_cells.\n\nThe number of columns in the table must be passed in num_column so the function can verify the correctness of the specification.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._resolve_printing_backend-Tuple{Any}","page":"Library","title":"PrettyTables._resolve_printing_backend","text":"_resolve_printing_backend(configurations) -> Symbol\n\nReturn the printing backend to be used based on the configurations provided. Notice that it function must only be used when the user did not specify the backend directly using the backend keyword.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._row_label_column_alignment-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._row_label_column_alignment","text":"_row_label_column_alignment(table_data::TableData) -> Symbol\n\nReturn the row label column alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._row_number_column_alignment-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._row_number_column_alignment","text":"_row_number_column_alignment(table_data::TableData) -> Symbol\n\nReturn the row number column alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__cell_to_str-Tuple{Any, IOContext, Val{:print}}","page":"Library","title":"PrettyTables._text__cell_to_str","text":"_text__cell_to_str(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nConvert the cell to a string using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__check_eol-Tuple{PrettyTables.Display}","page":"Library","title":"PrettyTables._text__check_eol","text":"_text__check_eol(display::Display) -> Bool\n\nCheck if the current column of the display is past the end of line.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__design_vertical_cropping-Tuple{PrettyTables.TableData, TextTableFormat, AbstractVector{Int64}, AbstractVector{Int64}, Bool, Int64, Bool}","page":"Library","title":"PrettyTables._text__design_vertical_cropping","text":"_text__design_vertical_cropping(table_data::TableData, tf::TextTableFormat, horizontal_lines_at_column_labels::AbstractVector{Int}, horizontal_lines_at_data_rows::AbstractVector{Int}, show_omitted_row_summary::Bool, display_number_of_rows::Int, new_line_at_end::Bool = true) -> Int, Bool\n\nDesign the vertical cropping of the table by computing how many data lines we can print and if we must suppress the horizontal line before or after the continuation line.\n\nArguments\n\ntable_data::TableData: Table data.\ntf::TextTableFormat: Table format.\nhorizontal_lines_at_column_labels::AbstractVector{Int}: Horizontal lines at column   labels.\nhorizontal_lines_at_data_rows::AbstractVector{Int}: Horizontal lines at data rows.\nshow_omitted_row_summary::Bool: If true, we must show the omitted row summary.\ndisplay_number_of_rows::Int: Number of rows in the display.\nnew_line_at_end::Bool: If true, we must add a new line at the end of the table.\n\nReturns\n\nInt: Number of data rows we can print.\nBool: If true, we must suppress the horizontal line before the continuation line.\nBool: If true, we must suppress the horizontal line after the continuation line.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__design_vertical_cropping_with_line_breaks-Tuple{PrettyTables.TableData, Matrix{String}, TextTableFormat, AbstractVector{Int64}, AbstractVector{Int64}, Bool, Int64, Bool, Int64}","page":"Library","title":"PrettyTables._text__design_vertical_cropping_with_line_breaks","text":"_text__design_vertical_cropping_with_line_breaks(table_data::TableData, table_str::Matrix{String}, tf::TextTableFormat, horizontal_lines_at_column_labels::AbstractVector{Int}, horizontal_lines_at_data_rows::AbstractVector{Int}, show_omitted_row_summary::Bool, display_number_of_rows::Int, new_line_at_end::Bool, num_printed_data_columns::Int) -> Int, Int, Bool\n\nDesign the vertical cropping of the table when the user wants line breaks by computing how many data lines we can print and if we must suppress the horizontal line before the continuation line. Notice that middle vertical cropping is not supported when we have line breaks.\n\nArguments\n\ntable_data::TableData: Table data.\ntf::TextTableFormat: Table format.\nhorizontal_lines_at_column_labels::AbstractVector{Int}: Horizontal lines at column   labels.\nhorizontal_lines_at_data_rows::AbstractVector{Int}: Horizontal lines at data rows.\nshow_omitted_row_summary::Bool: If true, we must show the omitted row summary.\ndisplay_number_of_rows::Int: Number of rows in the display.\nnew_line_at_end::Bool: If true, we must add a new line at the end of the table.\nnum_printed_data_columns::Int: Number of printed data columns.\n\nReturns\n\nInt: Number of data rows we can fully print.\nBool: If true, the printing process with crop the last row.\nBool: If true, we must suppress the horizontal line before the continuation line.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__fit_cell_in_maximum_cell_width-Tuple{String, Int64, Bool}","page":"Library","title":"PrettyTables._text__fit_cell_in_maximum_cell_width","text":"_text__fit_cell_in_maximum_cell_width(cell_str::String, maximum_cell_width::Int, line_breaks::Bool) -> String\n\nFit the cell with text cell_str in a field with a maximum width maximum_cell_width. If line_breaks is true, the cell will be split into multiple lines before fitting it.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__fix_data_column_widths!-Tuple{Vector{Int64}, Union{Nothing, Matrix{String}}, Matrix{String}, Union{Nothing, Matrix{String}}, AbstractVector{Int64}, Bool, Bool}","page":"Library","title":"PrettyTables._text__fix_data_column_widths!","text":"_text__fix_data_column_widths!(printed_data_column_widths::Vector{Int}, column_labels::Union{Nothing, Matrix{String}}, table_str::Matrix{String}, summary_rows::Union{Nothing, Matrix{String}}, fixed_data_column_widths::AbstractVector{Int}) -> Nothing\n\nFix the data column widths given the user specification. This function also crops the cells at the data columns to fit the fixed width.\n\nArguments\n\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\ncolumn_labels::Union{Nothing, Matrix{String}}: Column labels.\ntable_str::Matrix{String}: Rendered data cells.\nsummary_rows::Union{Nothing, Matrix{String}}: Summary rows.\nfixed_data_column_widths::AbstractVector{Int}: Fixed data column widths.\nauto_wrap::Bool: If true, the strings will be auto wrapped at each column with a fixed   width.\nline_breaks::Bool: If true, the cells will be split into multiple lines if needed.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__flush_line","page":"Library","title":"PrettyTables._text__flush_line","text":"_text__flush_line(display::Display, add_continuation_char::Bool = true, continuation_char::Char = '⋯'; crop_line::Bool = true) -> Nothing\n\nFlush the current line buffer to the display, cropping and adding continuation characters if needed.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__horizontal_line_intersection-Tuple{PrettyTables.Display, String, String, Bool}","page":"Library","title":"PrettyTables._text__horizontal_line_intersection","text":"_text__horizontal_line_intersection(display::Display, intersection::String, row::String, final_intersection::Bool) -> Nothing\n\nPrint to display the horizontal line intersection if we have enough space. Otherwise, print row. The argument final_intersection indicates that we are printing the final intersection of the table. In that case, we print intersection if we have at least two remaning spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__is_printing_horizontally_limited-Tuple{PrettyTables.TableData, Bool, Int64, Int64, Int64, Bool}","page":"Library","title":"PrettyTables._text__is_printing_horizontally_limited","text":"_text__is_printing_horizontally_limited(table_data::TableData, fit_table_in_display_horizontally::Bool, display_width::Int, num_printed_data_columns::Int, table_width_wo_cont_col::Int, vertical_line_after_continuation_column::Bool) -> Bool\n\nReturn true if the table printing is horizontally limited by the display, meaning that it will be cropped.\n\nArguments\n\ntable_data::TableData: Table data.\nfit_table_in_display_horizontally::Bool: If true, the table must fit in the display   horizontally.\ndisplay_width::Int: Display width.\nnum_printed_data_columns::Int: Number of printed data columns.\ntable_width_wo_cont_col::Int: Width of the table without the continuation column.\nvertical_line_after_continuation_column::Bool: If true, there is a vertical line   after the continuation column.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__number_of_printed_data_columns-Tuple{Int64, PrettyTables.TableData, TextTableFormat, AbstractVector{Int64}, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._text__number_of_printed_data_columns","text":"_text__number_of_printed_data_columns(display_width::Int, table_data::TableData, tf::TextTableFormat, vertical_lines_at_data_columns::AbstractVector{Int}, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}) -> Int\n\nCompute the number of printed data columns.\n\nArguments\n\ndisplay_width::Int: Display width.\ntable_data::TableData: Table data.\ntf::TextTableFormat: Table format.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__number_of_required_lines-Tuple{PrettyTables.TableData, TextTableFormat, AbstractVector{Int64}, AbstractVector{Int64}, Bool}","page":"Library","title":"PrettyTables._text__number_of_required_lines","text":"_text__number_of_required_lines(table_data::TableData, tf::TextTableFormat, horizontal_lines_at_column_lables::AbstractVector{Int}, horizontal_lines_at_data_rows::AbstractVector{Int}, new_line_at_end::Bool) -> NTuple{4, Int}\n\nCompute the total number of lines required to print the table.\n\nArguments\n\ntable_data::TableData: Table data.\ntf::TextTableFormat: Table format.\nhorizontal_lines_at_column_labels::AbstractVector{Int}: Horizontal lines at column   labels.\nhorizontal_lines_at_data_rows::AbstractVector{Int}: Horizontal lines at data rows.\nnew_line_at_end::Bool: If true, we must add a new line at the end of the table.\n\nReturns\n\nInt: Total number of lines required to print the table.\nInt: Number of lines required before printing the data.\nInt: Number of lines required after printing the data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__print","page":"Library","title":"PrettyTables._text__print","text":"_text__print(display::Display, str::AbstractString, str_width::Int = -1) -> Nothing\n\nPrint a string str to the display, updating the column position. If str_width is positive, it is used as the width of the printed string, reducing the computational burden. Otherwise, the printable width of str is computed using printable_textwidth.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__print-Tuple{PrettyTables.Display, Char}","page":"Library","title":"PrettyTables._text__print","text":"_text__print(display::Display, char::Char) -> Nothing\n\nPrint a single character char to the display.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__print_aligned","page":"Library","title":"PrettyTables._text__print_aligned","text":"_text__print_aligned(display::Display, str::AbstractString, cell_width::Int, alignment::Symbol, crayon::Crayon = _TEXT__DEFAULT, fill::Bool = true) -> Nothing\n\nPrint a string str to the display, aligned according to alignment in a cell of width cell_width. The string is printed with the style given by crayon. The alignment can be :l (left), :right (right), or :center (center). If fill is true, the string is filled with spaces to fit the cell width.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__print_column_label_horizontal_line","page":"Library","title":"PrettyTables._text__print_column_label_horizontal_line","text":"_text__print_column_label_horizontal_line(display::Display, tf::TextTableFormat, crayon::Crayon, table_data::TableData, row_number::Int, vertical_lines_at_data_columns::AbstractVector{Int}, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}, top::Bool = false, bottom::Bool = false)\n\nPrint a column label horizontal line to display.\n\nArguments\n\ndisplay::Display: Display where the horizontal line will be printed.\ntf::TextTableFormat: Table format.\ncrayon::Crayon: Crayon used to print the horizontal line.\ntable_data::TableData: Table data.\nrow_number::Int: Column label row number before the horizontal line.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\ntop::Bool: If true, a top horizontal line will be drawn.   (Default: false)\nbottom::Bool: If true, a bottom horizontal line will be drawn.   (Default: false)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__print_column_label_horizontal_line_only_at_merged_labels-Tuple{PrettyTables.Display, TextTableFormat, Crayon, PrettyTables.TableData, Int64, AbstractVector{Int64}, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._text__print_column_label_horizontal_line_only_at_merged_labels","text":"_text__print_column_label_horizontal_line_only_at_merged_labels(display::Display, tf::TextTableFormat, crayon::Crayon, table_data::TableData, row_number::Int, vertical_lines_at_data_columns::AbstractVector{Int}, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int})\n\nPrint a column label line to display where a horizontal line is drawn only after merged column labels.\n\nArguments\n\ndisplay::Display: Display where the horizontal line will be printed.\ntf::TextTableFormat: Table format.\ncrayon::Crayon: Crayon used to print the horizontal line.\ntable_data::TableData: Table data.\nrow_number::Int: Column label row number before the horizontal line.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__print_horizontal_line","page":"Library","title":"PrettyTables._text__print_horizontal_line","text":"_text__print_horizontal_line(display::Display, tf::TextTableFormat, crayon::Crayon, table_data::TableData, vertical_lines_at_data_columns::AbstractVector{Int}, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}, top::Bool = false, bottom::Bool = false, row_group_label::Bool = false) -> Nothing\n\nPrint a horizontal line to display.\n\nArguments\n\ndisplay::Display: Display where the horizontal line will be printed.\ntf::TextTableFormat: Table format.\ncrayon::Crayon: Crayon used to print the horizontal line.\ntable_data::TableData: Table data.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\ntop::Bool: If true, a top horizontal line will be drawn.   (Default: false)\nbottom::Bool: If true, a bottom horizontal line will be drawn.   (Default: false)\nrow_group_label::Bool: If true, a row group label horizontal line will be drawn. In   this case, the horizontal line type is also modified by the keyword top, whereas the   keyword bottom is neglected. To draw the bottom row label horizontal line, set topto   false.   (Default: false)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__printed_column_widths-Tuple{PrettyTables.TableData, Union{Nothing, Vector{String}}, Union{Nothing, Matrix{String}}, Union{Nothing, Matrix{String}}, Matrix{String}, AbstractVector{Int64}, Bool, Bool, AbstractVector{Int64}}","page":"Library","title":"PrettyTables._text__printed_column_widths","text":"_text__printed_column_widths(table_data::TableData, row_labels::Union{Nothing, Vector{String}}, column_labels::Union{Nothing, Matrix{String}}, summary_rows::Union{Nothing, Matrix{String}}, table_str::Matrix{String}, vertical_lines_at_data_columns::AbstractVector{Int}, column_label_width_based_on_first_line_only::Bool, line_breaks::Bool, minimum_data_column_width::Union{Nothing, Vector{Int}})\n\nCompute the printed column widths.\n\nArguments\n\ntable_data::TableData: Table data.\nrow_labels::Union{Nothing, Vector{String}}: Rendered row labels.\ncolumn_labels::Union{Nothing, Matrix{String}}: Rendered column labels.\nsummary_rows::Union{Nothing, Vector{String}}: Rendered summary rows.\ntable_str::Matrix{String}: Rendered data cells.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\ncolumn_label_width_based_on_first_line_only::Bool: If true, the column label width   will be computed based on the first line only.\nline_breaks::Bool: If true, the cells will be split into multiple lines if needed.   Hence, the textwidth of each line is used to compute the column width.\nminimum_data_column_widths::Union{Nothing, Vector{Int}}: Minimum data column widths.\n\nReturns\n\nInt: Row number column width.\nInt: Row label column width.\nVector{Int}: Printed data column widths.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__render_cell","page":"Library","title":"PrettyTables._text__render_cell","text":"_text__render_cell(cell::Any, @nospecialize(context::IOContext), renderer::Union{Val{:print}, Val{:show}}, line_breaks::Bool = false, column_width::Int = -1) -> String\n\nRender the cell in text back end using a specific context and renderer.\n\nIf line_breaks is true, the user wants to see line breaks in the output. The parameter column_width contains the maximum column width of the current cell. Currently, it is only used when rendering Markdown.MD cells.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._text__render_footnote_superscript-Tuple{Int64}","page":"Library","title":"PrettyTables._text__render_footnote_superscript","text":"_text__render_footnote_superscript(number::Int) -> String\n\nRender the superscript of a footnote.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__render_table-Tuple{PrettyTables.TableData, IOContext, Union{Val{:print}, Val{:show}}, Bool, AbstractVector{Int64}}","page":"Library","title":"PrettyTables._text__render_table","text":"_text__render_table(table_data::TableData, @nospecialize(context::IOContext), renderer::Union{Val{:print}, Val{:show}}, line_breaks::Bool, maximum_data_column_widths::AbstractVector{Int})\n\nRender the table using the specification in table_data. When the cells are converted to String, we use the context, and the renderer.\n\nIf line_breaks is true, we split each cell into multiple lines at every occurence of \\n.\n\nmaximum_data_column_widths must contain the user specification for the maximum data column widths.\n\nReturns\n\nUnion{Nothing, Vector{String}}: Rendered row labels.\nMatrix{String}: Rendered data cells.\nUnion{Nothing, Vector{String}}: Rendered summary rows.\nVector{String}: Rendered footnotes.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__styled_print-Tuple{PrettyTables.Display, AbstractString, Crayon}","page":"Library","title":"PrettyTables._text__styled_print","text":"_text__styled_print(display::Display, str::AbstractString, crayon::Crayon) -> Nothing\n\nPrint a string str to the display with the style given by the crayon.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__styled_print-Tuple{PrettyTables.Display, Char, Crayon}","page":"Library","title":"PrettyTables._text__styled_print","text":"_text__styled_print(display::Display, char::Char, crayon::Crayon) -> Nothing\n\nPrint a single character char to the display with style given by the crayon.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._text__table_width_wo_cont_column-Tuple{PrettyTables.TableData, TextTableFormat, AbstractVector{Int64}, Int64, Int64, Vector{Int64}}","page":"Library","title":"PrettyTables._text__table_width_wo_cont_column","text":"_text__table_width_wo_cont_column(table_data::TableData, tf::TextTableFormat, vertical_lines_at_data_columns::AbstractVector{Int}, row_number_column_width::Int, row_label_column_width::Int, printed_data_column_widths::Vector{Int}) -> Int\n\nCompute the width of the table without the continuation column.\n\nArguments\n\ntable_data::TableData: Table data.\ntf::TextTableFormat: Table format.\nvertical_lines_at_data_columns::AbstractVector{Int}: List of columns where a vertical   line must be drawn after the cell.\nrow_number_column_width::Int: Row number column width.\nrow_label_column_width::Int: Row label column width.\nprinted_data_column_widths::Vector{Int}: Printed data column widths.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__alignment-Tuple{Symbol}","page":"Library","title":"PrettyTables._typst__alignment","text":"_typst__alignment(a::Symbol) -> String\n\nGet the Typst alignment string corresponding to the given alignment symbol a. If the alignment symbol is not recognized, it defaults to \"right\".\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__alignment_configuration-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._typst__alignment_configuration","text":"_typst__alignment_configuration(td::TableData) -> String\n\nCreate the Typst alignment configuration string for the given td::TableData.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__cell_and_text_properties-Tuple{Vector{Pair{String, String}}}","page":"Library","title":"PrettyTables._typst__cell_and_text_properties","text":"_typst__cell_and_text_properties(vproperties::Vector{TypstPair}) -> Tuple{Vector{TypstPair}, Vector{TypstPair}}\n\nSplit vproperties into the properties that must be applied to the Typst table.cell and those that must be applied to the text content.\n\nThe first returned vector contains only attributes listed in _TYPST__CELL_ATTRIBUTES. The second returned vector contains only valid text properties prefixed with text-, with this prefix removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__cell_to_str-Tuple{Any, IOContext, Val{:print}}","page":"Library","title":"PrettyTables._typst__cell_to_str","text":"_typst__cell_to_str(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nConvert the cell to a string using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__create_component","page":"Library","title":"PrettyTables._typst__create_component","text":"_typst__create_component(component::String, content::String; kwargs...) -> String\n\nCreate an HTML component with the content.\n\nKeywords\n\nproperties::Union{Nothing, Vector{TypstPair}}: Tag properties.   (Default: nothing)\nstyle::Union{Nothing, Vector{TypstPair}}: Tag style.   (Default: nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._typst__escape_str-Tuple{IO, AbstractString}","page":"Library","title":"PrettyTables._typst__escape_str","text":"_typst__escape_str(io::IO, s::AbstractString) -> Nothing\n_typst__escape_str(s::AbstractString) -> String\n\nPrint the string s in io escaping the characters for the Typst backend. If io is omitted, the escaped string is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__get_data_column_widths-Tuple{PrettyTables.TableData, Nothing}","page":"Library","title":"PrettyTables._typst__get_data_column_widths","text":"_typst__get_data_column_widths(table_data::TableData[, data_column_widths]) -> String\n\nGenerate a Typst column width specification string for a table specified by table_data. data_column_widths must be an iterable of width specifications for data columns. Each element should be a width value compatible with Typst format (e.g., \"auto\", \"1fr\", \"2cm\"). If data_column_widths is nothing (default), it defaults to \"auto\" for all columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__merge_properties!-Tuple{Vector{Pair{String, String}}, Vector{Pair{String, String}}}","page":"Library","title":"PrettyTables._typst__merge_properties!","text":"_typst__merge_properties!(bproperties::Vector{TypstPair}, nproperties::Vector{TypstPair}) -> Vector{TypstPair}\n\nMerge two Typst properties, bproperties and nproperties, giving priority to nproperties in case of conflicts.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__open_component","page":"Library","title":"PrettyTables._typst__open_component","text":"_typst__open_component(component::String, properties::Union{Nothing, Vector{TypstPair}} = nothing) -> String\n\nCreate the string that opens the Typst component with the given properties.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._typst__print_cell-Tuple{IO, String, Bool, Int64, Int64, Bool}","page":"Library","title":"PrettyTables._typst__print_cell","text":"_typst__print_cell(io::IO, cell::String, first_column::Bool, il::Int, ns::Int, minify::Bool)\n\nPrint a table cell to the output stream in Typst format.\n\nArguments\n\nio::IO: The output stream where the cell will be printed.\ncell::String: The content of the cell to be printed.\nfirst_column::Bool: Whether this cell is in the first column.\nil::Int: The indentation level for formatting.\nns::Int: The number of spaces for indentation.\nminify::Bool: If true, prints the cell in minified format.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__process_caption-Tuple{TypstCaption, Int64}","page":"Library","title":"PrettyTables._typst__process_caption","text":"_typst__process_caption(c::TypstCaption, il::Int) -> String\n\nConvert a TypstCaption into a string with the corresponding Typst configuration. The il parameter indicates the indentation level for the generated string.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__property_list-Tuple{Vector{Pair{String, String}}}","page":"Library","title":"PrettyTables._typst__property_list","text":"_typst__property_list(properties::Vector{TypstPair}) -> String\n\nCreate a Typst property list string from the given vector of properties.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__render_cell-Tuple{Any, IOContext, Union{Val{:print}, Val{:show}}}","page":"Library","title":"PrettyTables._typst__render_cell","text":"_typst__render_cell(cell::Any, context::IOContext, renderer::Union{Val{:print}, Val{:show}}) -> String\n\nRender the cell in Typst back end using a specific context and renderer.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__should_wrap-NTuple{4, Int64}","page":"Library","title":"PrettyTables._typst__should_wrap","text":"_typst__should_wrap(str_length::Int, il::Int, ns::Int, wrap_column::Int) -> Bool\n\nDetermine whether a string with length str_length should be wrapped in Typst backend based on length constraints. The current indentation level of the string is determined by il, the number of spaces per indentation level is ns, and the maximum column width for wrapping is wrap_column.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__table_cell-Tuple{String, Vector{Pair{String, String}}}","page":"Library","title":"PrettyTables._typst__table_cell","text":"_typst__table_cell(content::String[, properties::Vector{TypstPair}]; kwargs...) -> String\n\nCreate a Typst table cell with content and optional properties. If properties is not provided or empty, a basic cell is created with the content. If properties are provided, a table.cell component is created with the content and properties.\n\nKeywords\n\nil::Int: Indentation level for formatting.   (Default: 2)\nns::Int: Number of spaces for indentation.   (Default: 2)\nwrap_column::Int: Column width threshold for wrapping content.   (Default: 92)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._typst__text-Tuple{String, Nothing}","page":"Library","title":"PrettyTables._typst__text","text":"_typst__text(content::String, properties::Union{Vector{TypstPair}, Nothing}) -> String\n\nConvert the content to Typst format with optional styling properties. If properties is empty or nothing (default), the function returns the content unchanged.  Otherwise, it creates a Typst #text component with the specified properties.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._validate_merge_cell_specification-Tuple{PrettyTables.TableData}","page":"Library","title":"PrettyTables._validate_merge_cell_specification","text":"_validate_merge_cell_specification(table_data::TableData) -> Nothing\n\nValidate the merge cell specification in table_data. If something is wrong, this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.fmt__latex_sn-Tuple{Int64}","page":"Library","title":"PrettyTables.fmt__latex_sn","text":"fmt__latex_sn(m_digits::Int[, columns::AbstractVector{Int}]) -> Function\n\nFormat the numbers of the elements in the columns to a scientific notation using LaTeX. If columns is not present, the formatting will be applied to the entire table.\n\nThe number is first printed using Printf functions with the g modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument m_digits.\n\nThe formatted number will be wrapped in the object LatexCell. Hence, this formatter only makes sense if the selected backend is :latex.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\nExtended Help\n\nExamples\n\njulia> data = [10.0^(-i + j) for i in 1:6, j in 1:6]\n6×6 Matrix{Float64}:\n 1.0     10.0     100.0    1000.0   10000.0  100000.0\n 0.1      1.0      10.0     100.0    1000.0   10000.0\n 0.01     0.1       1.0      10.0     100.0    1000.0\n 0.001    0.01      0.1       1.0      10.0     100.0\n 0.0001   0.001     0.01      0.1       1.0      10.0\n 1.0e-5   0.0001    0.001     0.01      0.1       1.0\n\njulia> pretty_table(data; formatters = [fmt__latex_sn(1)], backend = :latex)\n\\begin{tabular}{|r|r|r|r|r|r|}\n  \\hline\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} & \\textbf{Col. 4} & \\textbf{Col. 5} & \\textbf{Col. 6} \\\\\n  \\hline\n  1 & $1 \\cdot 10^{1}$ & $1 \\cdot 10^{2}$ & $1 \\cdot 10^{3}$ & $1 \\cdot 10^{4}$ & $1 \\cdot 10^{5}$ \\\\\n  0.1 & 1 & $1 \\cdot 10^{1}$ & $1 \\cdot 10^{2}$ & $1 \\cdot 10^{3}$ & $1 \\cdot 10^{4}$ \\\\\n  0.01 & 0.1 & 1 & $1 \\cdot 10^{1}$ & $1 \\cdot 10^{2}$ & $1 \\cdot 10^{3}$ \\\\\n  0.001 & 0.01 & 0.1 & 1 & $1 \\cdot 10^{1}$ & $1 \\cdot 10^{2}$ \\\\\n  0.0001 & 0.001 & 0.01 & 0.1 & 1 & $1 \\cdot 10^{1}$ \\\\\n  $1 \\cdot 10^{-5}$ & 0.0001 & 0.001 & 0.01 & 0.1 & 1 \\\\\n  \\hline\n\\end{tabular}\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.fmt__printf-Tuple{String}","page":"Library","title":"PrettyTables.fmt__printf","text":"fmt__printf(fmt_str::String[, columns::AbstractVector{Int}]) -> Function\n\nApply the format fmt_str (see the Printf standard library) to the elements in the columns specified in the vector columns. If columns is not specified, the format will be applied to the entire table.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\nExtended Help\n\nExamples\n\njulia> data = [f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n4×3 Matrix{Float64}:\n 0.0       1.0        0.0\n 0.5       0.866025   0.57735\n 0.866025  0.5        1.73205\n 1.0       0.0       Inf\n\njulia> pretty_table(data; formatters = [fmt__printf(\"%5.3f\")])\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│  0.000 │  1.000 │  0.000 │\n│  0.500 │  0.866 │  0.577 │\n│  0.866 │  0.500 │  1.732 │\n│  1.000 │  0.000 │    Inf │\n└────────┴────────┴────────┘\n\njulia> pretty_table(data; formatters = [fmt__printf(\"%5.3f\", [1, 3])])\n┌────────┬──────────┬────────┐\n│ Col. 1 │   Col. 2 │ Col. 3 │\n├────────┼──────────┼────────┤\n│  0.000 │      1.0 │  0.000 │\n│  0.500 │ 0.866025 │  0.577 │\n│  0.866 │      0.5 │  1.732 │\n│  1.000 │      0.0 │    Inf │\n└────────┴──────────┴────────┘\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.fmt__round-Tuple{Int64}","page":"Library","title":"PrettyTables.fmt__round","text":"fmt__round(digits::Int[, columns::AbstractVector{Int}]) -> Function\n\nRound the elements in the columns specified in the vector columns to the number of digits. If columns is not specified, the rounding will be applied to the entire table.\n\nExtended Help\n\nExamples\n\njulia> data = [f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n4×3 Matrix{Float64}:\n 0.0       1.0        0.0\n 0.5       0.866025   0.57735\n 0.866025  0.5        1.73205\n 1.0       0.0       Inf\n\njulia> pretty_table(data; formatters = [fmt__round(1)])\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    0.0 │    1.0 │    0.0 │\n│    0.5 │    0.9 │    0.6 │\n│    0.9 │    0.5 │    1.7 │\n│    1.0 │    0.0 │    Inf │\n└────────┴────────┴────────┘\n\njulia> pretty_table(data; formatters = [fmt__round(1, [1, 3])])\n┌────────┬──────────┬────────┐\n│ Col. 1 │   Col. 2 │ Col. 3 │\n├────────┼──────────┼────────┤\n│    0.0 │      1.0 │    0.0 │\n│    0.5 │ 0.866025 │    0.6 │\n│    0.9 │      0.5 │    1.7 │\n│    1.0 │      0.0 │    Inf │\n└────────┴──────────┴────────┘\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.pretty_table","page":"Library","title":"PrettyTables.pretty_table","text":"pretty_table(table; kwargs...) -> Nothing\n\nPrint the table to the stdout.\n\npretty_table(io::IO, table; kwargs...) -> Nothing\npretty_table(String, table; kwargs...) -> String\npretty_table(HTML,   table; kwargs...) -> HTML\n\nPrint the table to the output specified by the first argument.\n\nIf the first argument is of type IO, the function prints the table to it. If it is String, a String with the printed table will be returned by the function. If HTML is passed as the first argument, the function will return an HTML object with the table.\n\nWhen printing, the function verifies if table complies with Tables.jl API. If it is compliant, this interface will be used to print the table. If it is not compliant, only the following types are supported:\n\nAbstractVector: any vector can be printed.\nAbstractMatrix: any matrix can be printed.\n\npretty_table currently supports printing tables for four backends: text, markdown, html, and latex. The desired backend can be set using the backend keyword argument.\n\nFor more information, see the Extended Help section.\n\nExtended Help\n\nTable Sections\n\nPrettyTables.jl considers the following table sections when printing a table:\n\n                                      TITLE\n                                     Subtitle\n┌────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┐\n│ Row Number │    Stubhead Label │ Column Label │ Column Label │ ⋯ │ Column Label │\n│            │                   │ Column Label │ Column Label │ ⋯ │ Column Label │\n│            │                   │       ⋮      │       ⋮      │ ⋯ │       ⋮      │\n│            │                   │ Column Label │ Column Label │ ⋯ │ Column Label │\n├────────────┼───────────────────┼──────────────┼──────────────┼───┼──────────────┤\n│          1 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          2 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┤\n│ Row Group Label                                                                 │\n├────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┤\n│          3 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          4 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┤\n│ Row Group Label                                                                 │\n├────────────┬───────────────────┬──────────────┬──────────────┬───┬──────────────┤\n│          5 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│          6 │         Row Label │         Data │         Data │ ⋯ │         Data │\n│      ⋮     │          ⋮        │       ⋮      │       ⋮      │ ⋱ │       ⋮      │\n│        100 │         Row Label │         Data │         Data │ ⋯ │         Data │\n├────────────┼───────────────────┼──────────────┼──────────────┼───┼──────────────┤\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n│      ⋮     │          ⋮        │       ⋮      │       ⋮      │ ⋯ │       ⋮      │\n│            │ Summary Row Label │ Summary Cell │ Summary Cell │ ⋯ │ Summary Cell │\n└────────────┴───────────────────┴──────────────┴──────────────┴───┴──────────────┘\nFootnotes\nSource notes\n\nAll those sections can be configured using keyword arguments as described below.\n\nQuick Start\n\nThe following commands prints the table in matrix using the text backend with all the available sections:\n\njulia> matrix = [(i, j) for i in 1:3, j in 1:3];\n\njulia> result = pretty_table(\n    matrix;\n    column_labels            = [[\"Col. $i\" for i in 1:3], [\"$i\" for i in 1:3]],\n    footnotes                = [(:column_label, 1, 2) => \"Footnote in column label\", (:data, 2, 2) => \"Footnote in data\"],\n    merge_column_label_cells = [MergeCells(1, 2, 2, \"Merged Column\", :c)],\n    row_group_labels         = [2                     => \"Row Group\"],\n    row_labels               = [\"Row $i\" for i in 1:5],\n    show_row_number_column   = true,\n    source_notes             = \"Source Notes\",\n    stubhead_label           = \"Rows\",\n    subtitle                 = \"Table Subtitle\",\n    summary_rows             = [(data, i) -> 10i, (data, i) -> 20i],\n    title                    = \"Table Title\",\n)\n                  Table Title\n                Table Subtitle\n┌─────┬───────────┬────────┬──────────────────┐\n│ Row │      Rows │ Col. 1 │  Merged Column¹  │\n│     │           │      1 │       2 │      3 │\n├─────┼───────────┼────────┼─────────┼────────┤\n│   1 │     Row 1 │ (1, 1) │  (1, 2) │ (1, 3) │\n├─────┴───────────┴────────┴─────────┴────────┤\n│ Row Group                                   │\n├─────┬───────────┬────────┬─────────┬────────┤\n│   2 │     Row 2 │ (2, 1) │ (2, 2)² │ (2, 3) │\n│   3 │     Row 3 │ (3, 1) │  (3, 2) │ (3, 3) │\n├─────┼───────────┼────────┼─────────┼────────┤\n│     │ Summary 1 │     10 │      20 │     30 │\n│     │ Summary 2 │     20 │      40 │     60 │\n└─────┴───────────┴────────┴─────────┴────────┘\n¹: Footnote in column label\n²: Footnote in data\nSource Notes\n\nGeneral Keywords\n\nThe following keywords are related to table configuration and are available in all backends:\n\nbackend::Symbol: Backend used to print the table. The available options are :text,   :markdown, :html, and :latex.   (Default: :text)\n\nIOContext Arguments\n\ncompact_printing::Bool: If true, the table will be printed in a compact format, i.e,   we will pass the context option :compact => true when rendering the values.   (Default: true)\nlimit_printing::Bool: If true, the table will be printed in a limited format, i.e,   we will pass the context option :limit => true when rendering the values.   (Default: true)\n\nPrinting Specification Arguments\n\nshow_omitted_cell_summary::Bool: If true, a summary of the omitted cells will be   printed at the end of the table.   (Default: true)\nrenderer::Symbol: The renderer used to print the table. The available options are   :print and :show.   (Default: :print)\n\nTable Sections Arguments\n\ntitle::String: Title of the table. If it is empty, the title will be omitted.   (Default: \"\")\nsubtitle::String: Subtitle of the table. If it is empty, the subtitle will be omitted.   (Default: \"\")\nstubhead_label::String: Label of the stubhead column.   (Default: \"\")\nrow_number_column_label::String: Label of the row number column.   (Default: \"Row\")\nrow_labels::Union{Nothing, AbstractVector}: Row labels. If it is nothing, the column   with row labels is omitted.   (Default: nothing)\nrow_group_labels::Union{Nothing, Vector{Pair{Int, String}}}: Row group labels. If it is   nothing, no row group label is printed. For more information on how to specify the row   group labels, see the section Row Group Labels.   (Default: nothing)\ncolumn_labels::Union{Nothing, AbstractVector}: Column labels. If it is nothing, the   function uses a default value for the column labels. For more information on how to   specify the column labels, see the section Column Labels.   (Default: nothing)\nshow_column_labels::Bool: If true, the column labels will be printed.   (Default: true)\nsummary_rows::Union{Nothing, Vector{Function}}: Summary rows. If it is nothing, no   summary rows are printed. For more information on how to specify the summary rows, see   the section Summary Rows.   (Default: nothing)\nsummary_row_labels::Union{Nothing, Vector{String}}: Labels of the summary rows. If it is   nothing, the function uses a default value for the summary row labels.   (Default: nothing)\nfootnotes::Union{Nothing, Vector{Pair{FootnoteTuple, String}}}: Footnotes. If it is   nothing, no footnotes are printed. For more information on how to specify the   footnotes, see the section Footnotes.   (Default: nothing)\nsource_notes::String: Source notes. If it is empty, the source notes will be omitted.   (Default: \"\")\n\nAlignment Arguments\n\nThe following keyword arguments define the alignment of the table sections. The alignment can be specified using a symbol: :l for left, :c for center, or :r for right.\n\nalignment::Union{Symbol, Vector{Symbol}}: Alignment of the table data. It can be a   Symbol, which will be used for all columns, or a vector of Symbols, one for each   column.   (Default: :r)\ncolumn_label_alignment::Union{Nothing, Symbol, Vector{Symbol}}: Alignment of the column   labels. It can be a Symbol, which will be used for all columns, a vector of Symbols,   one for each column, or nothing, which will use the value of alignment.   (Default: nothing)\ncontinuation_row_alignment::Union{Nothing, Symbol}: Alignment of the columns in the   continuation row. If it is nothing, we use the value of alignment.   (Default: nothing)\nfootnote_alignment::Symbol: Alignment of the footnotes.   (Default: :l)\nrow_label_column_alignment::Symbol: Alignment of the row labels.   (Default: :r)\nrow_group_label_alignment::Symbol: Alignment of the row group labels.   (Default: :l)\nrow_number_column_alignment::Symbol: Alignment of the row number column.   (Default: :r)\nsource_note_alignment::Symbol: Alignment of the source notes.   (Default: :l)\nsubtitle_alignment::Symbol: Alignment of the subtitle.   (Default: :c)\ntitle_alignment::Symbol: Alignment of the title.   (Default: :c)\ncell_alignment::Union{Nothing, Vector{Pair{NTuple{2, Int}, Symbol}, Vector{Function}}: A   vector of functions with the signature f(data, i, j) that overrides the alignment of   the cell (i, j) to the value returned by f. The function must return a valid   alignment symbol or nothing. In the latter, the cell alignment will not be modified.   If the function returns an invalid data, it will be discarded. For convenience, it can   also be a vector of Pair{NTuple{2, Int}, Symbol}, i.e.   (i::Int, j::Int) => a::Symbol, that overrides the alignment of the cell (i, j) to   a.   (Default = nothing)\n\nwarning: Warning\nSome backends do not support all the alignment options. For example, it is impossible to define cell-specific alignment in the markdown backend.\n\nOther Arguments\n\nformatters::Union{Nothing, Vector{Function}}: Formatters used to modify the rendered   output of the cells. For more information, see the section Formatters.   (Default: nothing)\nmaximum_number_of_columns::Int: Maximum number of columns to be printed. If the table   has more columns than this value, the table will be truncated. If it is negative, all   columns will be printed.   (Default: -1)\nmaximum_number_of_rows::Int: Maximum number of rows to be printed. If the table has more   rows than this value, the table will be truncated. If it is negative, all rows will be   printed.   (Default: -1)\nmerge_column_label_cells::Union{Symbol, Vector{MergeCells}}: Merged cells in the column   labels. For more information, see the section Column Labels.   (Default: :auto)\nnew_line_at_end::Bool: If true, a new line will be printed at the end of the table.   (Default: true)\nshow_first_column_label_only::Bool: If true, only the first row of the column labels   will be printed.   (Default: false)\nvertical_crop_mode::Symbol: Vertical crop mode. This option defines how the table will   be vertically cropped if it has more rows than the number specified in   maximum_number_of_rows. The available options are :bottom, when the data will be   cropped at the bottom of the table, or :middle, when the data will be cropped at the   middle of the table.   (Default: :bottom)\n\nBackend-Specific Keywords\n\nThe keywords and information specific to each backend can be seen in the docstrings of the following methods:\n\nText backend: pretty_table_text_backend.\nMarkdown backend: pretty_table_markdown_backend.\nHTML backend: pretty_table_html_backend.\n\nwarning: Warning\nThose methods must not be called directly. They are only defined to split the documentation, providing a better organization.\n\nSpecification of Table Sections\n\nHere, we show how to specify the table sections using the keyword arguments.\n\nColumn Labels\n\nThe specification of column labels must be a vector of elements. Each element in this vector must be another vector with a row of column labels. Notice that each vector must have the same size as the number of table columns.\n\nFor example, in a table with three columns, we can specify two rows of column labels by passing:\n\ncolumn_labels = [\n    [\"Column #1\",    \"Column #2\",    \"Column #3\"],\n    [\"Subcolumn #1\", \"Subcolumn #2\", \"Subcolumn #3\"]\n]\n\ninfo: Info\nIf the user wants only one row in the column labels, they can pass only a vector with the elements. The algorithm will encapsulate it inside another vector to match the API.\n\nAdjacent column labels can be merged using the keyword merge_column_label_cells. It must contain a vector of MergeCells objects. Each object defines a new merged cell. The MergeCells object has the following fields:\n\nrow::Int: Row index of the merged cell.\ncolumn::Int: Column index of the merged cell.\ncolumn_span::Int: Number of columns spanned by the merged cell.\ndata::String: Data of the merged cell.\nalignment::Symbol: Alignment of the merged cell. The available options are :l for   left, :c for center, and :r for right.   (Default: :c)\n\nHence, in our example, if we want to merge the columns 2 and 3 of the first column label row, we must pass:\n\nmerge_column_label_cells = [\n    MergeCells(1, 2, 2, \"Merged Column\", :c)\n]\n\nWe can pass the helpers MultiColumn and EmptyCells to column_labels to create merged columns more easily. In this case, MultiColumn specify a set of columns that will be merged, and EmptyCells specify a set of empty columns. However, notice that in this case we must set merge_column_label_cells to :auto, which is the default.\n\nMultiColumn has the following fields:\n\ncolumn_span::Int: Number of columns spanned by the merged cell.\ndata::String: Data of the merged cell.\n\nEmptyCells has the following field:\n\nnumber_of_cells::Int: Number of columns that will be filled with empty cells.\n\nFor example, we can create the following column labels:\n\n┌───────────────────────────────────┬─────────────────┐\n│              Group #1             │     Group #2    │\n├─────────────────┬─────────────────┼────────┬────────┤\n│    Group #1.1   │    Group #1.2   │        │        │\n├────────┬────────┼────────┬────────┼────────┼────────┤\n│ Test 1 │ Test 2 │ Test 3 │ Test 4 │ Test 5 │ Test 6 │\n└────────┴────────┴────────┴────────┴────────┴────────┘\n\nby passing these arguments:\n\ncolumn_labels = [\n    [MultiColumn(4, \"Group #1\"), MultiColumn(2, \"Group #2\")],\n    [MultiColumn(2, \"Group #1.1\"), MultiColumn(2, \"Group #1.2\"), EmptyCells(2)],\n    [\"Test 1\", \"Test 2\", \"Test 3\", \"Test 4\", \"Test 5\", \"Test 6\"]\n]\n\nmerge_column_label_cells = :auto\n\nRow Group Labels\n\nThe row group labels are specified by a Vector{Pair{Int, String}}. Each element defines a new row group label. The first element of the Pair is the row index of the row group and the second is the label. For example, [3 => \"Row Group #1\"] defines that before row 3, we have the row group label named \"Row Group #1\".\n\nSummary Rows\n\nThe summary rows can be specified by a vector of Functions. Each element defines a summary row and the function must have one the following signature:\n\nf(col)\n\nf(data, j)\n\nwhere col is the current column, data is the table data, and j is the column index. In the first case, it must return the summary cell value for the referenced column. In the second case, it must return the summary cell value for the jth column. The algorithm will check if there is an applicable method for the first signature and use it if it exists. Otherwise, it will use the second signature. This verification is performed using the method applicable and col is obtained by @view data[:, j].\n\nIf we want, for example, to create two summary rows, one with the sum of the column values and other with their mean, we can define:\n\nsummary_rows = [\n    (data, j) -> sum(data[:, j]),\n    (data, j) -> sum(data[:, j]) / length(data[:, j])\n]\n\nWe can also use the first signature to simplify the code:\n\nusing Statistics\nsummary_rows = [sum, mean]\n\nnote: Note\nIf both signatures are available, the algorithm will prioritize the first one. To force the usage of the second, we can create an anonymous functions as follows: (data, i) -> f(data, i). This ensures that only the second method is available.\n\nFootnotes\n\nThe footnotes are specified by a vector of Pair{FootnoteTuple, String}. Each element defines a new footnote. The FootnoteTuple is a Tuple with the following elements:\n\nsection::Symbol: Section to which the footnote must be applied. The available options   are :column_label, :data, :row_label, :summary_row_label, and   :summary_row_cell.\ni::Int: Row index of the footnote considering the desired section.\nj::Int: Column index of the footnote considering the desired section.\n\nThe second element of the Pair is the footnote text.\n\nHence, if we want to apply a foot note to a column label, a data cell, and a summary cell, we can define:\n\nfootnotes = [\n    (:column_label, 1, 2) => \"Footnote in column label\",\n    (:data, 2, 2) => \"Footnote in data\",\n    (:summary_row_cell, 1, 2) => \"Footnote in summary cell\"\n]\n\nFormatters\n\nThe keyword formatters can be used to pass functions to format the values in the columns. It must be a Vector{Function} in which each function has the following signature:\n\nf(v, i, j)\n\nwhere v is the value in the cell, i is the row number, and j is the column number. It must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.\n\nThis keyword can also be nothing, meaning that no formatter will be used.\n\nFor example, if we want to multiply all values in odd rows of the column 2 by π, the formatter should look like:\n\nformatters = [(v, i, j) -> (j == 2 && isodd(i)) ? v * π : v]\n\nIf multiple formatters are available, they will be applied in the same order as they are located in the vector. Thus, for the following formatters:\n\nformatters = [f1, f2, f3]\n\neach element v in the table (ith row and jth column) will be formatted by:\n\nv = f1(v, i, j)\nv = f2(v, i, j)\nv = f3(v, i, j)\n\nThus, the user must ensure that the type of v between the calls is compatible.\n\nPrettyTables.jl provides some predefined formatters for common tasks. For more information, see fmt__printf, fmt__round, and fmt__latex_sn.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.pretty_table_html_backend","page":"Library","title":"PrettyTables.pretty_table_html_backend","text":"PrettyTables.jl HTML Backend\n\nThe HTML backend can be selected by passing the keyword backend = :html to the function pretty_table. In this case, we have the following additional keywords to configure the output.\n\nKeywords\n\nallow_html_in_cells::Bool: If true, the content of the cells can contain HTML code.   This can be useful to render tables with more complex content, but it can also be a   security risk if the content is not sanitized.   (Default: false)\ncolumn_label_titles::Union{Nothing, AbstractVector}: Titles for the column labels. If   nothing, no titles are added. If a vector is passed, it must have the same length as   the number of column label rows. Each element in the vector can be nothing (no title   for that row) or an element with the title for that row. Notice that this element will   be converted to string using the function string.   (Default: nothing)\nhighlighters::Vector{HtmlHighlighter}: Highlighters to apply to the table. For more   information, see the section HTML Highlighters in the Extended Help.\nline_breaks::Bool: If true, line breaks in the content of the cells (\\n) are   replaced by the HTML tag <br>.   (Default: false)\nmaximum_column_width::String: CSS width string for the maximum column width.   (Default: \"\")\nminify::Bool: If true, the output HTML code is minified.   (Default: false)\nstand_alone::Bool: If true, the output HTML code is a complete HTML document.   (Default: false)\nstyle::HtmlTableStyle: Style of the table. For more information, see the section   HTML Table Style in the Extended Help.\ntable_class::String: Class for the table.   (Default: \"\")\ntable_div_class::String: Class for the div containing the table. It is only used if   wrap_table_in_div is true.   (Default: \"\")\ntable_format::HtmlTableFormat: HTML table format used to render the table. For more   information, see the section HTML Table Format in the Extended Help.\ntop_left_string::String: String to put in the top left corner div.   (Default: \"\")\ntop_right_string::String: String to put in the top right corner div. Notice that this   information is replaced if we are printing the omitted cell summary.   (Default: \"\")\nwrap_table_in_div::Bool: If true, the table is wrapped in a div.   (Default: false)\n\nExtended Help\n\nHTML Highlighters\n\nA set of highlighters can be passed as a Vector{HtmlHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return a Vector{Pair{String, String}} with properties   compatible with the style field that will be applied to the highlighted cell.\n\nA HTML highlighter can be constructed using three helpers:\n\nHtmlHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nHtmlHighlighter(f::Function, decorations::NTuple{N, Pair{String, String}})\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration,  the second allows specifying decorations as a Tuple, and the third lets the user select  the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the vector highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with value greater than 5 in red, and all cells with values less than 5 in blue, we can define:\n\nhl_gt5 = HtmlHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"color\" => \"red\"]\n)\n\nhl_lt5 = HtmlHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"color\" => \"blue\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]\n\nHTML Table Format\n\nThe HTML table format is defined using an object of type HtmlTableFormat that contains the following fields:\n\ncss::String: CSS to be injected at the end of the <style> section.\ntable_width::String: Table width.\n\nNotice that this format is only applied if stand_alone = true.\n\nHTML Table Style\n\nThe HTML table style is defined using an object of type HtmlTableStyle that contains the following fields:\n\ntop_left_string::Vector{HtmlPair}: Style for the top left string.\ntop_right_string::Vector{HtmlPair}: Style for the top right string.\ntable::Vector{HtmlPair}: Style for the table.\ntitle::Vector{HtmlPair}: Style for the title.\nsubtitle::Vector{HtmlPair}: Style for the subtitle.\nrow_number_label::Vector{HtmlPair}: Style for the row number label.\nrow_number::Vector{HtmlPair}: Style for the row number.\nstubhead_label::Vector{HtmlPair}: Style for the stubhead label.\nrow_label::Vector{HtmlPair}: Style for the row label.\nrow_group_label::Vector{HtmlPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for   the first line of the column labels. If a vector of Vector{HtmlPair}} is provided,   each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{HtmlPair}, Vector{Vector{HtmlPair}}}: Style for the rest of   the column labels. If a vector of Vector{HtmlPair}} is provided, each column label   will use the corresponding style.\nfirst_line_merged_column_label::Vector{HtmlPair}: Style for the merged cells at the   first column label line.\nmerged_column_label::Vector{HtmlPair}: Style for the merged cells at the rest of the   column labels.\nsummary_row_cell::Vector{HtmlPair}: Style for the summary row cell.\nsummary_row_label::Vector{HtmlPair}: Style for the summary row label.\nfootnote::Vector{HtmlPair}: Style for the footnote.\nsource_notes::Vector{HtmlPair}: Style for the source notes.\n\nEach field is a vector of HtmlPair, i.e. Pair{String, String}, describing properties and values compatible with the HTML style attribute.\n\nFor example, if we want the stubhead label to be bold and red, we must define:\n\nstyle = HtmlTableStyle(\n    stubhead_label = [\"font-weight\" => \"bold\", \"color\" => \"red\"]\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.pretty_table_latex_backend","page":"Library","title":"PrettyTables.pretty_table_latex_backend","text":"PrettyTables.jl LaTeX Backend\n\nThe LaTeX backend can be selected by passing the keyword backend = :latex to the function pretty_table. In this case, we have the following additional keywords to configure the output.\n\nKeywords\n\nhighlighters::Vector{LatexHighlighter}: Highlighters to apply to the table. For more   information, see the section LaTeX Highlighters in the Extended Help.\nstyle::LatexTableStyle: Style of the table. For more information, see the section   LaTeX Table Style in the Extended Help.\ntable_format::LatexTableFormat: LaTeX table format used to render the table. For more   information, see the section LaTeX Table Format in the Extended Help.\n\nExtended Help\n\nLaTeX Highlighters\n\nA set of highlighters can be passed as a Vector{LatexHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure LatexHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return a Vector{String} with the LaTeX environments to   be applied to the cell.\n\nA LaTeX highlighter can be constructed using two helpers:\n\nLatexHighlighter(f::Function, envs::Vector{String})\n\nwhere it will apply recursively all the LaTeX environments in envs to the highlighted text, and\n\nLatexHighlighter(f::Function, fd::Function)\n\nwhere the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the vector highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to make the cells with value greater than 5 bold, and all the cells with value less than 5 small, we can define:\n\nhl_gt5 = LatexHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"textbf\"]\n)\n\nhl_lt5 = LatexHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"small\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]\n\nLaTeX Table Format\n\nThe LaTeX table format is defined using an object of type LatexTableFormat that contains the following fields:\n\nborders::LatexTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the   beginning of the table.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn on bottom of the merged column labels using \\cline.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn   after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each data row index listed in this vector. If the symbol :all is passed, a   horizontal line will be drawn after every data column. If the symbol :none is passed,   no horizontal lines will be drawn after the data rows.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be   drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be   drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn   after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there is no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn   after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the   beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn   after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn   after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will   be drawn after each data column index listed in this vector. If the symbol :all is   passed, a vertical line will be drawn after every data column. If the symbol :none is   passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after   the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be   drawn after the continuation column.\n\nWe provide a few helpers to configure the table format. For more information, see the documentation of the following macros:\n\n@latex__all_horizontal_lines.\n@latex__all_vertical_lines.\n@latex__no_horizontal_lines.\n@latex__no_vertical_lines.\n\nLaTeX Table Style\n\nThe LaTeX table style is defined using an object of type LatexTableStyle that contains the following fields:\n\ntitle::LatexEnvironments: Latex environments with the style for the title.\nsubtitle::LatexEnvironments: Latex environments with the style for the subtitle.\nrow_number_label::LatexEnvironments: Latex environments with the style for the row   number label.\nrow_number::LatexEnvironments: Latex environments with the style for the row numbers.\nstubhead_label::LatexEnvironments:  Latex environments with the style for the stubhead   label.\nrow_label::LatexEnvironments: Latex environments with the style for the row labels.\nrow_group_label::LatexEnvironments: Latex environments with the style for the row group   label.\nfirst_line_column_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex   environments with the style for the first line of the column labels. If a vector of   LatexEnvironments is provided, each column label in the first line will use the   corresponding style.\ncolumn_label::Union{LatexEnvironments, Vector{LatexEnvironments}}: Latex environments   with the style for the rest of the column labels. If a vector of LatexEnvironments is   provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::LatexEnvironments: Latex environments with the style for   the merged cells at the first column label line.\nmerged_column_label::LatexEnvironments: Latex environments with the style for the merged   cells at the rest of the column labels.\nsummary_row_cell::LatexEnvironments: Latex environments with the style for the summary   row cell.\nsummary_row_label::LatexEnvironments: Latex environments with the style for the summary   row label.\nfootnote::LatexEnvironments: Latex environments with the style for the footnotes.\nsource_note::LatexEnvironments: Latex environments with the style for the source notes.\nomitted_cell_summary::LatexEnvironments: Latex environments with the style for the   omitted cell summary.\n\nEach field is a LatexEnvironments object, which is a vector of strings with the LaTeX environments to be applied to the corresponding element.\n\nFor example, if we want to make the stubhead label bold and red, we must define:\n\nstyle = LatexTableStyle(\n    stubhead_label = [\"textbf\", \"color{red}\"]\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.pretty_table_markdown_backend","page":"Library","title":"PrettyTables.pretty_table_markdown_backend","text":"PrettyTables.jl Markdown Backend\n\nThe markdown backend can be selected by passing the keyword backend = :markdown to the function pretty_table. In this case, we have the following additional keywords to configure the output.\n\nKeywords\n\nallow_markdown_in_cells::Bool: If true, the content of the cells can contain markdown   code.   (Default: false)\nhighlighters::Vector{MarkdownHighlighter}: Highlighters to apply to the table. For more   information, see the section Markdown Highlighters in the Extended Help.\nline_breaks::Bool: If true, line breaks in the content of the cells (\\n) are   replaced by <br>.   (Default: false)\nstyle::MarkdownTableStyle: Style of the table. For more information, see the section   Markdown Table Style in the Extended Help.\ntable_format::MarkdownTableFormat: Markdown table format used to render the table. For   more information, see the section Markdown Table Format in the Extended Help.\n\nExtended Help\n\nMarkdown Highlighters\n\nA set of highlighters can be passed as a Vector{MarkdownHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure MarkdownHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the MarkdownStyle to be applied to the\n\ncell that must be highlighted.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type MarkdownStyle that contains the decoration to be applied to the cell.\n\nA markdown highlighter can be constructed using two helpers:\n\nMarkdownHighlighter(f::Function, decoration::MarkdownStyle)\n\nMarkdownHighlighter(f::Function, fd::Function)\n\nwhereas the second lets the user select the desired decoration by specifying the function fd. fd.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nMarkdown Table Format\n\nThe markdown table format is defined using an object of type MarkdownTableFormat that contains the following fields:\n\ntitle_heading_level::Int: Title heading level.\nsubtitle_heading_level::Int: Subtitle heading level.\nhorizontal_line_char::Char: Character used to draw the horizontal line.\nline_before_summary_rows::Bool: Whether to draw a line before the summary rows.\ncompact_table::Bool: If true, the table is printed in a compact format without extra   spaces between columns.\n\nMarkdown Table Style\n\nThe markdown table style is defined using an object of type MarkdownTableStyle that contains the following fields:\n\nrow_number_label::MarkdownStyle: Style for the row number label.\nrow_number::MarkdownStyle: Style for the row number.\nfirst_column_label::MarkdownStyle: Style for the first line of the column labels.\nrow_label::MarkdownStyle: Style for the row label.\nrow_group_label::MarkdownStyle: Style for the row group label.\nfirst_line_column_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the   first line of the column label. If a vector of MarkdownStyle is provided, each column   label in the first line will use the corresponding style.\ncolumn_label::Union{MarkdownStyle, Vector{MarkdownStyle}}: Style for the column label.   If a vector of MarkdownStyle is provided, each column label will use the corresponding   style.\nsummary_row_label::MarkdownStyle: Style for the summary row label.\nsummary_row_cell::MarkdownStyle: Style for the summary row cell.\nfootnote::MarkdownStyle: Style for the footnote.\nsource_note::MarkdownStyle: Style for the source note.\nomitted_cell_summary::MarkdownStyle: Style for the omitted cell summary.\n\nEach field is an instance of the structure MarkdownStyle describing the style to be applied to the corresponding element.\n\nFor example, if we want that the stubhead label is bold and italic, we must define:\n\nstyle = MarkdownTableStyle(\n    stubhead_label = MarkdownStyle(bold = true, italic = true)\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.pretty_table_text_backend","page":"Library","title":"PrettyTables.pretty_table_text_backend","text":"PrettyTables.jl Text Backend\n\nThe text backend can be selected by passing the keyword backend = :text to the function pretty_table. In this case, we have the following additional keywords to configure the output.\n\nKeywords\n\nalignment_anchor_fallback::Symbol: This keyword controls the line alignment when using   the regex alignment anchors if a match is not found. If it is :l, the left of the line   will be aligned with the anchor. If it is :c, the line center will be aligned with the   anchor. Otherwise, the end of the line will be aligned with the anchor.   (Default = :l)\nalignment_anchor_regex::Union{Vector{Regex}, Vector{Pair{Int, Vector{Regex}}}}: This   keyword can be used to provide regexes to align the data values in the table columns. If   it is Vector{Regex}, the regexes will be used to align all the columns. If it is   Vector{Pair{Int, Vector{Regex}}}, the Int element specifies the column to which the   regexes in Vector{Regex} will be applied. The regex match is searched in the same   order as the regexes appear on the vector. The regex matching is applied after the cell   conversion to string, which includes the formatters. If no match is found for a specific   line, the alignment of this line depends on the option alignment_anchor_fallback.   Example: [2 => [r\"\\.\"]] aligns the decimal point of the cells in the second column.   (Default = Regex[])\napply_alignment_regex_to_summary_rows::Bool: If true, the alignment regexes in   alignment_anchor_regex will also be applied to the summary rows.   (Default = false)\nauto_wrap::Bool: If true, the text will be wrapped on spaces to fit the column. Note   that this function requires line_breaks = true and the column must have a fixed size   (see fixed_data_column_widths).   (Default = false)\ncolumn_label_width_based_on_first_line_only::Bool: If true, the column label width is   based on the first line of the column. Hence, if the other column labels have text   width larger than the computed column width, they will be cropped to fit.   (Default = false)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the display size   (num. of rows, num. of columns) that is available to print the table. It is used to crop   the data depending on the value of the keyword crop. Notice that if a dimension is not   positive, it will be treated as unlimited.   (Default = displaysize(io))\nequal_data_column_widths::Bool: If true, the data columns will have the same width.   (Default = false)\nfit_table_in_display_horizontally::Bool: If true, the table will be cropped to fit   the display horizontally.   (Default = true)\nfit_table_in_display_vertically::Bool: If true, the table will be cropped to fit the   display vertically.   (Default = true)\nfixed_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this vector   specifies the width of each column. If it is a Int, this number will be used as the   width of all columns. If the width is equal to or lower than 0, it will be automatically   computed to fit the large cell in the column.   (Default = 0)\nhighlighters::Vector{TextHighlighter}: Highlighters to apply to the table. For more   information, see the section Text Highlighters in the Extended Help.\nline_breaks::Bool: If true, a new line character will break the line inside the cells.   (Default = false)\nmaximum_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this   vector specifies the maximum width of each column. If it is an Int, this number will   be used as the maximum width of all columns. If the maximum width is equal or lower than   0, it will be ignored. Notice that the parameter fixed_data_column_widths has   precedence over this one.   (Default = 0)\nminimum_data_column_widths::Union{Int, Vector{Int}}: If it is a Vector{Int}, this   vector specifies the minimum width of each column. If it is an Int, this number will   be used as the minimum width of all columns. If the minimum width is equal or lower than   0, it will be ignored. Notice that the parameter fixed_data_column_widths has   precedence over this one.   (Default = 0)\noverwrite_display::Bool: If true, the same number of lines in the printed table will   be deleted from the output io. This can be used to update the table in the display   continuously.   (Default = false)\nreserved_display_lines::Int: Number of lines to be left at the beginning of the printing   when vertically cropping the output.   (Default = 0)\nshrinkable_column_minimum_width::Int: If it is a positive integer (> 0), this is the   minimum width of the shrinkable column (see shrinkable_data_column).   (Default = 0)\nshrinkable_data_column::Int: If it is a positive integer, this column will be   shrinkable. This means that if the table does not fit in the display, this column will   be shrunk to fit the table in the display. If it is 0 or negative, no column will be   shrinkable.   (Default = 0)\nstyle::TextTableStyle: Style of the table. For more information, see the section   Text Table Style in the Extended Help.\ntable_format::TextTableFormat: Text table format used to render the table. For more   information, see the section Text Table Format in the Extended Help.\n\nExtended Help\n\nText highlighters\n\nA set of highlighters can be passed as a Vector{TextHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure TextHighlighter. It contains three fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the Crayon to be applied to the cell that must   be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd   is used.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the cell (i, j) will be highlighted.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.\n\nA highlighter can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with value greater than 5 in red, and all the cells with value less than 5 in blue, we can define:\n\nhl_gt5 = TextHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    crayon\"red\"\n)\n\nhl_lt5 = TextHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    crayon\"blue\"\n)\n\nhighlighters = [hl_gt5, hl_lt5]\n\nText Table Format\n\nThe text table format is defined using an object of type TextTableFormat that contains the following fields:\n\nborders::TextTableBorders: Format of the borders.\nhorizontal_line_at_beginning::Bool: If true, a horizontal line will be drawn at the   beginning of the table.\nhorizontal_lines_at_column_labels::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each column label row index listed in this vector. If the symbol :all is   passed, a horizontal line will be drawn after every column label. If the symbol :none   is passed, no horizontal lines will be drawn.\nhorizontal_line_at_merged_column_labels::Bool: If true, a horizontal line will be   drawn at the merged column labels. Notice that the horizontal line drawn using the   option horizontal_lines_at_column_labels has precedence over this one.\nhorizontal_line_after_column_labels::Bool: If true, a horizontal line will be drawn   after the column labels.\nhorizontal_lines_at_data_rows::Union{Symbol, Vector{Int}}: A horizontal line will be   drawn after each data row index listed in this vector. If the symbol :all is passed, a   horizontal line will be drawn after every data column. If the symbol :none is passed,   no horizontal lines will be drawn.\nhorizontal_line_before_row_group_label::Bool: If true, a horizontal line will be   drawn before the row group label.\nhorizontal_line_after_row_group_label::Bool: If true, a horizontal line will be   drawn after the row group label.\nhorizontal_line_after_data_rows::Bool: If true, a horizontal line will be drawn   after the data rows.\nhorizontal_line_before_summary_rows::Bool: If true, a horizontal line will be drawn   before the summary rows. Notice that this line is the same as the one drawn if   horizontal_line_after_data_rows is true. However, in this case, the line is omitted   if there is no summary rows.\nhorizontal_line_after_summary_rows::Bool: If true, a horizontal line will be drawn   after the summary rows.\nvertical_line_at_beginning::Bool: If true, a vertical line will be drawn at the   beginning of the table.\nvertical_line_after_row_number_column::Bool: If true, a vertical line will be drawn   after the row number column.\nvertical_line_after_row_label_column::Bool: If true, a vertical line will be drawn   after the row label column.\nvertical_lines_at_data_columns::Union{Symbol, Vector{Int}}: A vertical line will be   drawn after each data column index listed in this vector. If the symbol :all is   passed, a vertical line will be drawn after every data column. If the symbol :none is   passed, no vertical lines will be drawn after the data columns.\nvertical_line_after_data_columns::Bool: If true, a vertical line will be drawn after   the data columns.\nvertical_line_after_continuation_column::Bool: If true, a vertical line will be   drawn after the continuation column.\nellipsis_line_skip::Integer: Number of lines to skip when printing an ellipsis.\n\nWe provide a few helpers to configure the table format. For more information, see the documentation of the following macros:\n\n@text__all_horizontal_lines.\n@text__all_vertical_lines.\n@text__no_horizontal_lines.\n@text__no_vertical_lines.\n\nText Table Style\n\nThe text table style is defined using an object of type TextTableStyle that contains the following fields:\n\ntitle::Crayon: Crayon with the style for the title.\nsubtitle::Crayon: Crayon with the style for the subtitle.\nrow_number_label::Crayon: Crayon with the style for the row number label.\nrow_number::Crayon: Crayon with the style for the row numbers.\nstubhead_label::Crayon:  Crayon with the style for the stubhead label.\nrow_label::Crayon: Crayon with the style for the row labels.\nrow_group_label::Crayon: Crayon with the style for the row group label.\nfirst_line_column_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style   for the first column label lines. If a vector of crayons is passed, it must have the   same length as the number columns in the table.\ncolumn_label::Union{Crayon, Vector{Crayon}}: Crayon or crayons with the style for the   rest of the column labels. If a vector of crayons is passed, it must have the same   length as the number of columns in the table.\nfirst_line_merged_column_label::Crayon: Crayon with the style for the merged cells at   the first column label line.\nmerged_column_label::Crayon: Crayon with the style for the merged cells at the rest of   the column labels.\nsummary_row_cell::Crayon: Crayon with the style for the summary row cell.\nsummary_row_label::Crayon: Crayon with the style for the summary row label.\nfootnote::Crayon: Crayon with the style for the footnotes.\nsource_note::Crayon: Crayon with the style for the source notes.\nomitted_cell_summary::Crayon: Crayon with the style for the omitted cell summary.\ntable_border::Crayon: Crayon with the style for the table border.\n\nEach field is a Crayon describing the style for the corresponding element in the table.\n\nFor example, if we want that the stubhead label is bold and red, we must define:\n\nstyle = TextTableStyle(\n    stubhead_label = crayon\"bold red\"\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.pretty_table_typst_backend","page":"Library","title":"PrettyTables.pretty_table_typst_backend","text":"PrettyTables.jl Typst Backend\n\nThe Typst backend can be selected by passing the keyword backend = :typst to the function pretty_table. In this case, we have the following additional keywords to configure the output:\n\nKeywords\n\nannotate::Bool: Boolean indicating whether Typst code should be annotated.\ncaption::Union{Nothing, String, TypstCaption}: Table caption to be used by the   Typst #figure function. The user can provide additional configuration to the caption   by using the TypstCaption structure.\ndata_column_widths::Union{Nothing, String, Vector{String}, Vector{Pair{Int, String}}}:   Column widths for the data columns. The information must be a valid length information   in Typst, such as \"10fr\" or \"30pt\". If a single string is provided, it will be repeated   for all columns. If a vector of strings is provided, its length must be equal to or   larger than the number of printed columns. Alternatively, a vector of pairs can be   provided, where the first element of the pair is the column index and the second element   is the width for that column. In this case, columns that are not specified will have   width auto.   (Default = nothing)\nhighlighters::Vector{TypstHighlighter}: Highlighters to apply to the table. For more   information, see the section Typst Highlighters in the Extended Help.   (Default = TypstHighlighter[])\nminify::Bool: If true, the generated Typst code will be minified by ignoring   wrap_column and printing the table columns in the same line.   (Default = false)\nstyle::TypstTableStyle: Style of the table. For more information, see the section   Typst Table Style in the Extended Help.   (Default = TypstTableStyle())\nwrap_column::Integer: Indicates the column where the output will be wrapped.   (Default = 92)\n\nnote: Note\nThe content in the cells is always escaped. If you want to use a raw Typst component as cell, load the package Typstry.jl and pass the cell content as a TypstString. In this case, the content will not be escaped and will be treated as a raw Typst component.\n\nExtended Help\n\nTypst Highlighters\n\nA set of highlighters can be passed as a Vector{TypstHighlighter} to the highlighters keyword. Each highlighter is an instance of the structure TypstHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j), which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j), where h is the   highlighter. This function must return a Vector{Pair{String, String}} with properties   compatible with the style field that will be applied to the highlighted cell.\n\nA Typst highlighter can be constructed using three helpers:\n\nTypstHighlighter(f::Function, decoration::Vector{Pair{String, String}})\n\nTypstHighlighter(f::Function, decorations::NTuple{N, Pair{String, String}})\n\nTypstHighlighter(f::Function, fd::Function)\n\nThe first applies a fixed decoration to the highlighted cell specified in decoration, the second allows specifying decorations as a Tuple, and the third lets the user select the desired decoration by specifying the function fd.\n\nnote: Note\nIf multiple highlighters are valid for element (i, j), the applied style is the first match according to the order in the vector highlighters.\n\nnote: Note\nIf highlighters are used together with Formatters, formatting changes will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\nFor example, if we want to highlight the cells with value greater than 5 in red, and all cells with values less than 5 in blue, we can define:\n\nhl_gt5 = TypstHighlighter(\n    (data, i, j) -> data[i, j] > 5,\n    [\"text-fill\" => \"red\"]\n)\n\nhl_lt5 = TypstHighlighter(\n    (data, i, j) -> data[i, j] < 5,\n    [\"text-fill\" => \"blue\"]\n)\n\nhighlighters = [hl_gt5, hl_lt5]\n\nEach cell with properties is rendered with one call to #text inside a table.cell function, as shown below:\n\ntable.cell()[#text()[Cell Content]]\n\nnote: Note\nSince table.cell and #text() share some attribute names, attributes used by the #text function must be defined with the text- prefix. For example, to create a table style (or highlighter) that sets a blue background and white font color:[\"fill\" => \"blue\", \"text-fill\" => \"white\"]\n\nTypst Table Style\n\nThe Typst table style is defined using an object of type TypstTableStyle that contains the following fields:\n\ntable::Vector{TypstPair}: Style for the table.\ntitle::Vector{TypstPair}: Style for the title.\nsubtitle::Vector{TypstPair}: Style for the subtitle.\nrow_number_label::Vector{TypstPair}: Style for the row number label.\nrow_number::Vector{TypstPair}: Style for the row number.\nstubhead_label::Vector{TypstPair}: Style for the stubhead label.\nrow_label::Vector{TypstPair}: Style for the row label.\nrow_group_label::Vector{TypstPair}: Style for the row group label.\nfirst_line_column_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for the first line of the column labels. If a vector of Vector{TypstPair} is provided, each column label in the first line will use the corresponding style.\ncolumn_label::Union{Vector{TypstPair}, Vector{Vector{TypstPair}}}: Style for the rest of the column labels. If a vector of Vector{TypstPair} is provided, each column label will use the corresponding style.\nfirst_line_merged_column_label::Vector{TypstPair}: Style for the merged cells at the first column label line.\nmerged_column_label::Vector{TypstPair}: Style for the merged cells at the rest of the column labels.\nsummary_row_cell::Vector{TypstPair}: Style for the summary row cell.\nsummary_row_label::Vector{TypstPair}: Style for the summary row label.\nfootnote::Vector{TypstPair}: Style for the footnote.\nsource_notes::Vector{TypstPair}: Style for the source notes.\n\nEach field is a vector of TypstPair, i.e. Pair{String, String}, describing properties and values compatible with the Typst style attribute.\n\nFor example, if we want the stubhead label to be bold and red, we must define:\n\nstyle = TypstTableStyle(\n    stubhead_label = [\"text-weight\" => \"bold\", \"text-fill\" => \"red\"]\n)\n\nThe user can pass any property compatible with the Typst style attribute. If the prefix text- is used, the property will be applied to the text of the cell. Otherwise, it will be applied to the cell itself.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables.@latex__all_horizontal_lines-Tuple{}","page":"Library","title":"PrettyTables.@latex__all_horizontal_lines","text":"@latex__all_horizontal_lines() -> Keywords for `LatexTableFormat`\n\nReturn the keyword arguments to be passed to LatexTableFormat to show all horizontal lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format with all horizontal lines:\n\ntf = LatexTableFormat(; @latex__all_horizontal_lines())\n\nAny option can be overridden by merging the keyword arguments. For example, the following code shows all the horizontal lines but the first one:\n\ntf = LatexTableFormat(; @latex__all_horizontal_lines, horizontal_line_at_beginning = false)\n\nExtended Help\n\nExample\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = LatexTableFormat(; @latex__all_horizontal_lines))\n\\begin{tabular}{|r|r|r|}\n  \\hline\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n\\end{tabular}\n\njulia> pretty_table(\n           A;\n           table_format = LatexTableFormat(;\n               @latex__all_horizontal_lines,\n               horizontal_line_after_column_labels = false\n           )\n       )\n\\begin{tabular}{|r|r|r|}\n  \\hline\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\n  \\hline\n\\end{tabular}\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex__all_vertical_lines-Tuple{}","page":"Library","title":"PrettyTables.@latex__all_vertical_lines","text":"@latex__all_vertical_lines() -> Keywords for `LatexTableFormat`\n\nReturn the keyword arguments to be passed to LatexTableFormat to show all vertical lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format with all vertical lines:\n\ntf = LatexTableFormat(; @latex__all_vertical_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code shows all the vertical lines but the first one:\n\ntf = LatexTableFormat(; @latex__all_vertical_lines, vertical_line_at_beginning = false)\n\nExtended Help\n\nExamples\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = LatexTableFormat(; @latex__all_vertical_lines))\n\\begin{tabular}{|r|r|r|}\n  \\hline\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  \\hline\n\\end{tabular}\n\njulia> pretty_table(\n           A;\n           show_row_number_column = true,\n           table_format = LatexTableFormat(;\n               @latex__all_vertical_lines,\n               vertical_line_after_row_number_column = false\n           )\n       )\n\\begin{tabular}{|rr|r|r|}\n  \\hline\n  \\textbf{Row} & \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  \\hline\n  1 & 1.0 & 1.0 & 1.0 \\\\\n  2 & 1.0 & 1.0 & 1.0 \\\\\n  3 & 1.0 & 1.0 & 1.0 \\\\\n  \\hline\n\\end{tabular}\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex__no_horizontal_lines-Tuple{}","page":"Library","title":"PrettyTables.@latex__no_horizontal_lines","text":"latex__no_horizontal_lines() -> Keywords for `LatexTableFormat`\n\nReturn the keyword arguments to be passed to LatexTableFormat to suppress all horizontal lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format without horizontal lines:\n\ntf = LatexTableFormat(; @latex__no_horizontal_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code draws only the horizontal line at the beginning of the table:\n\ntf = LatexTableFormat(; @latex__no_horizontal_lines, horizontal_line_at_beginning = true)\n\nExtended Help\n\nExample\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = LatexTableFormat(; @latex__no_horizontal_lines))\n\\begin{tabular}{|r|r|r|}\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n\\end{tabular}\n\njulia> pretty_table(\n           A;\n           table_format = LatexTableFormat(;\n               @latex__no_horizontal_lines,\n               horizontal_line_after_column_labels = true\n           )\n       )\n\\begin{tabular}{|r|r|r|}\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n\\end{tabular}\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex__no_vertical_lines-Tuple{}","page":"Library","title":"PrettyTables.@latex__no_vertical_lines","text":"latex__no_vertical_lines() -> Keywords for `LatexTableFormat`\n\nReturn the keyword arguments to be passed to LatexTableFormat to suppress all vertical lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format without vertical lines:\n\ntf = LatexTableFormat(; @latex__no_vertical_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code draws only the vertical line at the beginning of the table:\n\ntf = LatexTableFormat(; @latex__no_vertical_lines, vertical_line_at_beginning = true)\n\nExtended Help\n\nExamples\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = LatexTableFormat(; @latex__no_vertical_lines))\n\\begin{tabular}{rrr}\n  \\hline\n  \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  \\hline\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  1.0 & 1.0 & 1.0 \\\\\n  \\hline\n\\end{tabular}\n\njulia> pretty_table(\n           A;\n           show_row_number_column = true,\n           table_format = LatexTableFormat(;\n               @latex__no_vertical_lines,\n               vertical_line_after_row_number_column = true\n           )\n       )\n\\begin{tabular}{r|rrr}\n  \\hline\n  \\textbf{Row} & \\textbf{Col. 1} & \\textbf{Col. 2} & \\textbf{Col. 3} \\\\\n  \\hline\n  1 & 1.0 & 1.0 & 1.0 \\\\\n  2 & 1.0 & 1.0 & 1.0 \\\\\n  3 & 1.0 & 1.0 & 1.0 \\\\\n  \\hline\n\\end{tabular}\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex_cell_str-Tuple{Any}","page":"Library","title":"PrettyTables.@latex_cell_str","text":"@latex_cell_str(str)\n\nCreate a table cell with LaTeX code.\n\nExamples\n\njulia> latex_cell\"\textbf{Bold text}\"\nLatexCell{String}(\"\\textbf{Bold text}\")\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@text__all_horizontal_lines-Tuple{}","page":"Library","title":"PrettyTables.@text__all_horizontal_lines","text":"@text__all_horizontal_lines() -> Keywords for `TextTableFormat`\n\nReturn the keyword arguments to be passed to TextTableFormat to show all horizontal lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format with all horizontal lines:\n\ntf = TextTableFormat(; @text__all_horizontal_lines())\n\nAny option can be overridden by merging the keyword arguments. For example, the following code shows all the horizontal lines but the first one:\n\ntf = TextTableFormat(; @text__all_horizontal_lines, horizontal_line_at_beginning = false)\n\nExtended Help\n\nExample\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = TextTableFormat(; @text__all_horizontal_lines))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n└────────┴────────┴────────┘\n\njulia> pretty_table(\n    A;\n    table_format = TextTableFormat(\n        ;\n        @text__all_horizontal_lines,\n        horizontal_line_after_column_labels = false\n    )\n)\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n│    1.0 │    1.0 │    1.0 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n└────────┴────────┴────────┘\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@text__all_vertical_lines-Tuple{}","page":"Library","title":"PrettyTables.@text__all_vertical_lines","text":"@text__all_vertical_lines() -> Keywords for `TextTableFormat`\n\nReturn the keyword arguments to be passed to TextTableFormat to show all vertical lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format with all vertical lines:\n\ntf = TextTableFormat(; @text__all_vertical_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code shows all the vertical lines but the first one:\n\ntf = TextTableFormat(; @text__all_vertical_lines, vertical_line_at_beginning = false)\n\nExtended Help\n\nExamples\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = TextTableFormat(; @text__all_vertical_lines))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n└────────┴────────┴────────┘\n\njulia> pretty_table(\n    A;\n    show_row_number_column = true,\n    table_format = TextTableFormat(\n        ;\n        @text__all_vertical_lines,\n        vertical_line_after_row_number_column = false\n    )\n)\n┌─────────────┬────────┬────────┐\n│ Row  Col. 1 │ Col. 2 │ Col. 3 │\n├─────────────┼────────┼────────┤\n│   1     1.0 │    1.0 │    1.0 │\n│   2     1.0 │    1.0 │    1.0 │\n│   3     1.0 │    1.0 │    1.0 │\n└─────────────┴────────┴────────┘\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@text__no_horizontal_lines-Tuple{}","page":"Library","title":"PrettyTables.@text__no_horizontal_lines","text":"text__no_horizontal_lines() -> Keywords for `TextTableFormat`\n\nReturn the keyword arguments to be passed to TextTableFormat to suppress all horizontal lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format without horizontal lines:\n\ntf = TextTableFormat(; @text__no_horizontal_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code draws only the horizontal line at the beginning of the table:\n\ntf = TextTableFormat(; @text__no_horizontal_lines, horizontal_line_at_beginning = true)\n\nExtended Help\n\nExample\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = TextTableFormat(; @text__no_horizontal_lines))\n│ Col. 1 │ Col. 2 │ Col. 3 │\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n\njulia> pretty_table(\n    A;\n    table_format = TextTableFormat(\n        ;\n        @text__no_horizontal_lines,\n        horizontal_line_after_column_labels = true\n    )\n)\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n│    1.0 │    1.0 │    1.0 │\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@text__no_vertical_lines-Tuple{}","page":"Library","title":"PrettyTables.@text__no_vertical_lines","text":"text__no_vertical_lines() -> Keywords for `TextTableFormat`\n\nReturn the keyword arguments to be passed to TextTableFormat to suppress all vertical lines.\n\nWe can use the output of this function when creating the text table format object. For example, the following code creates a text table format without vertical lines:\n\ntf = TextTableFormat(; @text__no_vertical_lines)\n\nAny option can be overridden by merging the keyword arguments. For example, the following code draws only the vertical line at the beginning of the table:\n\ntf = TextTableFormat(; @text__no_vertical_lines, vertical_line_at_beginning = true)\n\nExtended Help\n\nExamples\n\njulia> A = ones(3, 3);\n\njulia> pretty_table(A; table_format = TextTableFormat(; @text__no_vertical_lines))\n────────────────────────\n Col. 1  Col. 2  Col. 3\n────────────────────────\n    1.0     1.0     1.0\n    1.0     1.0     1.0\n    1.0     1.0     1.0\n────────────────────────\n\njulia> pretty_table(\n    A;\n    show_row_number_column = true,\n    table_format = TextTableFormat(\n        ;\n        @text__no_vertical_lines,\n        vertical_line_after_row_number_column = true\n    )\n)\n─────┬────────────────────────\n Row │ Col. 1  Col. 2  Col. 3\n─────┼────────────────────────\n   1 │    1.0     1.0     1.0\n   2 │    1.0     1.0     1.0\n   3 │    1.0     1.0     1.0\n─────┴────────────────────────\n\n\n\n\n\n","category":"macro"},{"location":"#PrettyTables.jl","page":"Home","title":"PrettyTables.jl","text":"This package has the purpose to print data in matrices using different backends. It was orizinally inspired in the functionality provided by ASCII Tables.\n\nPrettyTables.jl allows to print the data together with some table sections. They can be modified by the user to obtain the desired output. The sections currently available are:\n\n(Image: Table Design)\n\nThis design is heavily inspired by the R's package gt but the API is highly different due to the differences between the R and Julia languages.\n\nusing PrettyTables\n\nt = 0:1:20\n\ndata = hcat(t, ones(length(t) ), t, 0.5.*t.^2);\n\ncolumn_labels = [\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ \"[s]\",     \"[m / s²]\",  \"[m / s]\",      \"[m]\"]\n]\n\nhl_p = TextHighlighter(\n    (data, i, j) -> (j == 4) && (data[i, j] > 9),\n    crayon\"blue bold\"\n);\n\nhl_v = TextHighlighter(\n    (data, i, j) -> (j == 3) && (data[i, j] > 9),\n    crayon\"red bold\"\n);\n\nhl_10 = TextHighlighter(\n    (data, i, j) -> (i == 10),\n    crayon\"fg:white bold bg:dark_gray\"\n);\n\nstyle = TextTableStyle(first_line_column_label = crayon\"yellow bold\");\n\ntable_format = TextTableFormat(borders = text_table_borders__unicode_rounded);\n\njulia> pretty_table(\n    data;\n    column_labels = column_labels,\n    style         = style,\n    highlighters  = [hl_10, hl_p, hl_v],\n    table_format  = table_format_format  = TextTableFormat(borders = text_table_borders__unicode_rounded)\n)\n\n(Image: Welcome figure)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(\"PrettyTables\")","category":"section"},{"location":"man/quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"The following command prints the table in matrix using the text backend with all the available sections:\n\njulia> matrix = [(i, j) for i in 1:3, j in 1:3];\n\njulia> pretty_table(\n    matrix;\n    column_labels            = [[\"Col. $i\" for i in 1:3], [\"$i\" for i in 1:3]],\n    footnotes                = [(:column_label, 1, 2) => \"Footnote in column label\", (:data, 2, 2) => \"Footnote in data\"],\n    merge_column_label_cells = [MergeCells(1, 2, 2, \"Merged Column\", :c)],\n    row_group_labels         = [2 => \"Row Group\"],\n    row_labels               = [\"Row $i\" for i in 1:5],\n    show_row_number_column   = true,\n    source_notes             = \"Source Notes\",\n    stubhead_label           = \"Rows\",\n    subtitle                 = \"Table Subtitle\",\n    summary_rows             = [(data, i) -> 10i, (data, i) -> 20i],\n    title                    = \"Table Title\",\n)\n\n(Image: Quick start)","category":"section"}]
}
