var documenterSearchIndex = {"docs":
[{"location":"man/text_examples/#Text-back-end-examples","page":"Text back-end","title":"Text back-end examples","text":"","category":"section"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"In the following, it is presented how the following matrix can be printed using the text back-end.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> data = Any[ 1    false      1.0     0x01 ;\n                   2     true      2.0     0x02 ;\n                   3    false      3.0     0x03 ;\n                   4     true      4.0     0x04 ;\n                   5    false      5.0     0x05 ;\n                   6     true      6.0     0x06 ;]","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data, border_crayon = crayon\"yellow\")","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data, tf = tf_simple, border_crayon = crayon\"bold yellow\", header_crayon = crayon\"bold green\")","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data, tf = tf_markdown, show_row_number = true)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"The following example shows how formatters can be used to change how elements are printed.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> formatter = (v, i, j) -> begin\n           if j != 2\n               return isodd(i) ? i : 0\n           else\n               return v\n           end\n       end\n\njulia> pretty_table(data, tf = tf_ascii_rounded, formatters = formatter)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"The following example indicates how highlighters can be used to highlight the lowest and highest element in the data considering the columns 1, 3, and 5:","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> h1 = Highlighter((data, i, j) -> j in (1, 3, 4) && data[i, j] == maximum(data[2:end, [1, 3, 4]]),\n                        bold       = true,\n                        foreground = :blue )\n\njulia> h2 = Highlighter( (data,i,j)->j in (1, 3, 4) && data[i, j] == minimum(data[2:end,[1, 3, 4]]),\n                         bold       = true,\n                         foreground = :red )\n\njulia> pretty_table(data, highlighters = (h1, h2))","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"Since this package has support to the API defined by Tables.jl, then many formats, e.g DataFrames.jl, can be pretty printed:","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:2:20, B = rand(10), C = rand(10))\n\njulia> pretty_table(df, formatters = ft_printf(\"%.3f\", [2, 3]), highlighters = (hl_lt(0.2), hl_gt(0.8)))","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"You can use body_hlines keyword to divide the table into interesting parts:","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data, body_hlines = [2, 4])","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"If you want to break lines inside the cells, then you can set the keyword linebreaks to true. Hence, the characters \\n will cause a line break inside the cell.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> text = [\"This line contains\\nthe velocity [m/s]\" 10.0;\n               \"This line contains\\nthe acceleration [m/s^2]\" 1.0;\n               \"This line contains\\nthe time from the\\nbeginning of the simulation\" 10;]\n\njulia> pretty_table(text, linebreaks = true, body_hlines = [1, 2, 3])","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"The keyword show_header can be used to suppres the header, which leads to a very simplistic, compact format.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> pretty_table(data, tf = tf_borderless, show_header = false)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"By default, if the data is larger than the display, then it will be cropped to fit it. This can be changed by using the keywords crop and display_size.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> data = rand(100, 10); pretty_table(data, highlighters = (hl_gt(0.5),))","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"You can use the keyword columns_width to select the width of each column, so that the data is cropped to fit the available space.","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> mat = rand(100, 4)\n\njulia> pretty_table(mat,\n                    highlighters = hl_gt(0.5),\n                    columns_width = [7, -1, 7, 8],\n                    compact_printing = false)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"If you want to save the printed table to a file, you can do:","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> open(\"output.txt\", \"w\") do f\n            pretty_table(f,data)\n       end","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"This package can also be used to create data reports in text format:","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> data = [\n    \"Torques\" \"\" \"\" \"\";\n    \"Atmospheric drag\" \".\"^10 10 \"10⁻⁵ Nm\";\n    \"Gravity gradient\" \".\"^10 3 \"10⁻⁵ Nm\";\n    \"Solar radiation pressure\" \".\"^10 0.1 \"10⁻⁵ Nm\";\n    \"Total\" \".\"^10 13.1 \"10⁻⁵ Nm\";\n    \"\" \"\" \"\" \"\"\n    \"Angular momentum\" \"\" \"\" \"\";\n    \"Atmospheric drag\" \".\"^10 6.5 \"Nms\";\n    \"Gravity gradient\" \".\"^10 3.0 \"Nms\";\n    \"Solar radiation pressure\" \".\"^10 1.0 \"Nms\";\n    \"Total\" \".\"^10 10.5 \"Nms\"\n]\n\njulia> pretty_table(\n    data;\n    body_hlines        = [1,7],\n    body_hlines_format = Tuple('─' for _ = 1:4),\n    cell_alignment     = Dict((1, 1) => :l, (7, 1) => :l),\n    formatters         = ft_printf(\"%10.1f\", 2),\n    highlighters       = (\n        hl_cell([(1, 1); (7, 1)], crayon\"bold\"),\n        hl_col(2, crayon\"dark_gray\"),\n        hl_row([5, 11], crayon\"bold yellow\")\n    ),\n    show_header        = false,\n    tf                 = tf_borderless\n)","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"The highlighters API can be used to dynamically highlight cells. In the next example, it is shown how the package ColorSchemes.jl can be integrated to build a table with a color map (the following example will be displayed better in a terminal that supports 24-bit color):","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"julia> using ColorSchemes\n\njulia> data = [sind(x) * cosd(y) for x in 0:10:180, y in 0:10:180]\n\njulia> hl = Highlighter((data, i, j) -> true,\n                        (h, data, i, j) -> begin\n                             color = get(colorschemes[:coolwarm], data[i, j], (-1, 1))\n                             return Crayon(foreground = (round(Int, color.r * 255),\n                                                         round(Int, color.g * 255),\n                                                         round(Int, color.b * 255)))\n                         end)\n\njulia> pretty_table(data;\n                    header = [\"x = $(x)°\" for x = 0:10:180],\n                    row_labels = [\"y = $(y)°\" for y = 0:10:180],\n                    highlighters = hl,\n                    formatters = ft_printf(\"%.2f\"))","category":"page"},{"location":"man/text_examples/","page":"Text back-end","title":"Text back-end","text":"(Image: )","category":"page"},{"location":"man/html_examples/#HTML-back-end-examples","page":"HTML back-end","title":"HTML back-end examples","text":"","category":"section"},{"location":"man/html_examples/","page":"HTML back-end","title":"HTML back-end","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/html_examples/","page":"HTML back-end","title":"HTML back-end","text":"Coming soon...","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for PrettyTables.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [PrettyTables]","category":"page"},{"location":"lib/library/#PrettyTables.T_BACKENDS","page":"Library","title":"PrettyTables.T_BACKENDS","text":"T_BACKENDS\n\nTypes that define the supported backends.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.AnsiTextCell","page":"Library","title":"PrettyTables.AnsiTextCell","text":"AnsiTextCell\n\nA text cell that supports rendering ANSI escape sequences without interfering with the table layout.\n\nFields\n\nPublic\n\nstring::String: The string with the cell text that can contain ANSI escape   sequences.\n\nPrivate\n\n_rendered_lines::Union{Nothing, Vector{String}}: The lines with the rendered   strings.\n_stripped_lines::Union{Nothing, Vector{String}}: The lines with the   printable text.\n_crops::Union{Nothing, Vector{Int}}: Vector with the number of characters   that must be cropped at each line.\n_left_pads::Union{Nothing, Vector{Int}}: Left padding to be applied to each   line.\n_right_pads::Union{Nothing, Vector{Int}}: Right padding to be applied to   each line.\n_suffixes::Union{Nothing, Vector{String}}: Suffixed to be applied to each   line.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.AnsiTextCell-Tuple{AbstractString}","page":"Library","title":"PrettyTables.AnsiTextCell","text":"AnsiTextCell(string::AbstractString)\n\nCreate an AnsiTextCell using string.\n\nAnsiTextCell(renderfn[; context])\n\nCreate an AnsiTextCell using a render function.\n\nrenderfn is a function with the following signature:\n\nrenderfn(io)::String\n\nthat renders a string that can contain ANSI sequences into io.\n\ncontext is a tuple of context arguments passed to an IOContext that renderfn receives. See IOContext for details on what arguments are available.\n\nUseful for supporting packages that have rich terminal outputs.\n\nExamples\n\nBelow are examples for wrappers around AnsiTextCell to print rich data into tables that make use of packages with rich terminal output.\n\nCrayons.jl\n\nApply custom decoration to text inside a cell.\n\nusing Crayons, PrettyTables\n\nb = crayon\"blue bold\"\ny = crayon\"yellow bold\"\ng = crayon\"green bold\"\n\npretty_table([AnsiTextCell(\"$(g)This $(y)is $(b)awesome!\") for _ in 1:5, _ in 1:5])\n\nImageInTerminal.jl\n\nShow images inside a table.\n\nusing ImageInTerminal, PrettyTables\n\nfunction ImageCell(img, size)\n    return AnsiTextCell(\n        io -> ImageInTerminal.imshow(io, img),\n        context = (:displaysize => size,),)\nend\n\nusing TestImages\nimg = testimage(\"lighthouse\")\npretty_table([ImageCell(img, (20, 20)) ImageCell(img, (40, 40))])\n\nUnicodePlots.jl\n\nShow a variety of plots in a table.\n\nusing UnicodePlots, PrettyTables\n\nfunction UnicodePlotCell(p)\n    return AnsiTextCell(\n        io -> show(io, p),\n        context = (:color => true,)\n    )\nend\n\npretty_table([\n    UnicodePlotCell(barplot(Dict(\"x\" => 10, \"y\" => 20)))\n    UnicodePlotCell(boxplot([1, 3, 3, 4, 6, 10]))\n])\n\nCommonMark.jl\n\nUse rich Markdown inside tables.\n\nusing CommonMark, PrettyTables\n\nfunction MarkdownCell(md)\n    return AnsiTextCell(\n        renderfn = io -> display(TextDisplay(io), md),\n        context = (:color => true,)\n    )\nend\n\npretty_table([MarkdownCell(cm\"**Hi**\") MarkdownCell(cm\"> quote\")])\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ColumnTable","page":"Library","title":"PrettyTables.ColumnTable","text":"struct ColumnTable\n\nThis structure helps to access elements that comply with the column access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.CustomTextCell","page":"Library","title":"PrettyTables.CustomTextCell","text":"CustomTextCell\n\nAbstract type of custom cells in the text backend.\n\nEach type must implement the following API:\n\nget_printable_cell_text: A function that must return a vector of strings   with the printable text, i.e. without any non-printable character.\nget_rendered_line: A function that must return the rendered line that will   be printed to the display.\napply_line_padding!: Apply a certain number of spaces to the left and right   of a specific line.\ncrop_line!: A function that must crop a certain number of printable   characters from the end of the line.\nappend_suffix_to_line!: Append a string suffix to a line of the custom cell.\napply_line_padding!: Apply left and right padding to a line of the custom   cell.\ncrop_line!: Crop a certain number of characters from a line of the custom   cell.\nget_printable_cell_line: Get a printable line of the custom cell.\nget_rendered_line: Get a rendered line of the custom cell.\nparse_cell_text: Parse the cell text and return a Vector{String} with the   printable lines.\nreset!: Reset all the temporary fields. This function is not required.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.Display","page":"Library","title":"PrettyTables.Display","text":"Display\n\nStore the information of the display and the current cursor position.\n\nnote: Note\nThis is not the real cursor position with respect to the display, but with respect to the point in which the table is printed.\n\nFields\n\nsize::Tuple{Int, Int}: Display size.\nrow::Int: Current row.\ncolumn::Int: Current column.\nhas_color::Bool: Indicates if the display has color support.\ncont_char::Char: The character that indicates the line is cropped.\ncont_space_char::Char: Space character to be printed before cont_char.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.Highlighter","page":"Library","title":"PrettyTables.Highlighter","text":"Highlighter\n\nDefines the default highlighter of a table when using the text backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should   return true if the element (i,j) in data must be highlighter, or   false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is   the highlighter. This function must return the Crayon to be applied to the   cell that must be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the   default fd is used.\n\nRemarks\n\nThis structure can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlCell","page":"Library","title":"PrettyTables.HtmlCell","text":"struct HtmlCell\n\nDefines a table cell that contains HTML code. It can be created using the macro @html_cell_str.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlDecoration","page":"Library","title":"PrettyTables.HtmlDecoration","text":"HtmlDecoration\n\nStructure that defines parameters to decorate a table cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlHighlighter","page":"Library","title":"PrettyTables.HtmlHighlighter","text":"HtmlHighlighter\n\nDefines the default highlighter of a table when using the html backend.\n\nFields\n\nf::Function: Function with the signature f(data,i,j) in which should   return true if the element (i,j) in data must be highlighter, or   false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is   the highlighter. This function must return the HtmlDecoration to be   applied to the cell that must be highlighted.\ndecoration::HtmlDecoration: The HtmlDecoration to be applied to the   highlighted cell if the default fd is used.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nHtmlHighlighter(f::Function, decoration::HtmlDecoration)\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlTableFormat","page":"Library","title":"PrettyTables.HtmlTableFormat","text":"HtmlTableFormat\n\nFormat that will be used to print the HTML table. All parameters are strings compatible with the corresponding HTML property.\n\nFields\n\ncss::String: CSS to be injected at the end of the <style> section.\ntable_width::String: Table width.\n\nRemarks\n\nBesides the usual HTML tags related to the tables (table, td,th,tr, etc.), there are three important classes that can be used to format tables using the variablecss`.\n\nheader: This is the class of the header (first line).\nsubheader: This is the class of the sub-headers (all the rest of the lines   in the header section).\nheaderLastRow: The last row of the header section has additionally this   class.\nrowNumber: All the cells related to the row number have this class. Thus,   the row number header can be styled using th.rowNumber and the   row numbers cells can be styled using td.rowNumber.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexCell","page":"Library","title":"PrettyTables.LatexCell","text":"struct LatexCell\n\nDefines a table cell that contains LaTeX code. It can be created using the macro @latex_cell_str.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexHighlighter","page":"Library","title":"PrettyTables.LatexHighlighter","text":"LatexHighlighter\n\nDefines the default highlighter of a table when using the LaTeX backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should   return true if the element (i, j) in data must be highlighted, or   false otherwise.\nfd: A function with the signature f(data, i, j, str)::String in which   data is the matrix, (i, j) is the element position in the table, and   str is the data converted to string. This function must return a string   that will be placed in the cell.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nLatexHighlighter(f::Function, envs::Union{String, Vector{String}})\n\nLatexHighlighter(f::Function, fd::Function)\n\nThe first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.\n\nThus, for example:\n\nLatexHighlighter((data, i, j)->true, [\"textbf\", \"small\"])\n\nwill wrap all the cells in the table in the following environment:\n\n\\textbf{\\small{<Cell text>}}\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexTableFormat","page":"Library","title":"PrettyTables.LatexTableFormat","text":"LatexTableFormat\n\nThis structure defines the format of the LaTeX table.\n\nFields\n\ntop_line::String: Top line of the table.\nheader_line::String: Line that separate the header from the table body.\nmid_line::String: Line printed in the middle of the table.\nbottom_line::String: Bottom line of the table.\nleft_vline::String: Left vertical line of the table.\nmid_vline::String: Vertical line in the middle of the table.\nright_vline::String: Right vertical line of the table.\nheader_envs::Vector{String}: LaTeX environments that will be used in each   header cell.\nsubheader_envs::Vector{String}: LaTeX environments that will be used in each   sub-header cell.\nhlines::Vector{Symbol}: Horizontal lines that must be drawn by default.\nvlines::Union{Symbol, Vector{Symbol}}: Vertical lines that must be drawn by   default.\ntable_type::Symbol: Select the type of table that should be used for this   format.\nwrap_table::Bool: Select if the table must be wrapped inside the environment   defined by wrap_table_environment.\nwrap_table_environment::String: Environment in which the table will be   wrapped if wrap_table is true.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrettyTablesConf","page":"Library","title":"PrettyTables.PrettyTablesConf","text":"struct PrettyTablesConf\n\nType of the object that holds a pre-defined set of configurations for PrettyTables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrintInfo","page":"Library","title":"PrettyTables.PrintInfo","text":"struct PrintInfo\n\nThis structure stores the information required so that the backends can print the tables.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.ProcessedTable","page":"Library","title":"PrettyTables.ProcessedTable","text":"struct ProcessedTable\n\nThis struct contains the processed table, which handles additional columns, etc. All the backend functions have access to this object.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.ProcessedTable-Tuple{Any, Any}","page":"Library","title":"PrettyTables.ProcessedTable","text":"ProcessedTable(data::Any, header::Any; kwargs...)\n\nCreate a processed table with data and header.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.RowPrintingState","page":"Library","title":"PrettyTables.RowPrintingState","text":"RowPrintingState\n\nStructure that hold the state of the row printing state machine.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.RowTable","page":"Library","title":"PrettyTables.RowTable","text":"struct RowTable\n\nThis structure helps to access elements that comply with the row access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextCrayons","page":"Library","title":"PrettyTables.TextCrayons","text":"struct TextCrayons\n\nStructure that holds all the crayons in the text backend.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextFormat","page":"Library","title":"PrettyTables.TextFormat","text":"TextFormat\n\nFields\n\nup_right_corner::Char: Character in the up right corner.\nup_left_corner::Char: Character in the up left corner.\nbottom_left_corner::Char: Character in the bottom left corner.\nbottom_right_corner::Char: Character in the bottom right corner.\nup_intersection::Char: Character in the intersection of lines in the up   part.\nleft_intersection::Char: Character in the intersection of lines in the left   part.\nright_intersection::Char: Character in the intersection of lines in the   right part.\nmiddle_intersection::Char: Character in the intersection of lines in the   middle of the table.\nbottom_intersection::Char: Character in the intersection of the lines in the   bottom part.\ncolumn::Char: Character in a vertical line inside the table.\nleft_border::Char: Character used as the left border.\nright_border::Char: Character used as the right border.\nrow::Char: Character in a horizontal line inside the table.\nhlines::Vector{Symbol}: Horizontal lines that must be drawn by default.\nvlines::Union{Symbol, Vector{Symbol}}: Vertical lines that must be drawn by   default.\n\nPre-defined formats\n\nThe following pre-defined formats are available: unicode (default), mysql, compact, markdown, simple, ascii_rounded, and ascii_dots.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.UndefinedCell","page":"Library","title":"PrettyTables.UndefinedCell","text":"struct UndefinedCell\n\nInternal structure to indicate that a cell has an undefined reference.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.UrlTextCell","page":"Library","title":"PrettyTables.UrlTextCell","text":"UrlTextCell\n\nA text cell that contains a URL and is rendered using the ANSI escape sequence \\e8].\n\nwarning: Warning\nSome terminals do not support this feature, leading to a layout problem in the printed table.\n\nFields\n\nPublic\n\ntext::String: The label of the URL.\nurl::String: The URL.\n\nPrivate\n\n_crop::Int: Number of characters in the text that must be cropped when   rendering the URL.\n_left_pad::Int: Number of spaces to be added to the left of the text when   rendering the URL.\n_right_pad::Int: Number of spaces to be added to the right of the text when   rendering the URL.\n_suffix::String: Suffix to be appended to the text when rendering the URL.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables._add_column!","page":"Library","title":"PrettyTables._add_column!","text":"_add_column!(ptable::ProcessedTable, new_column::AbstractVector, new_header::Vector{String} = String[\"\"]; kwargs...)\n\nAdd a new column new_column with header new_header to ptable.\n\nKeywords\n\nalignment::Symbol: Alignment for the new column. (Default = :r)\nheader_alignment::Symbol: Alignment for the new column header.   (Default = :s)\nid::Symbol: Identification symbol for the new column.   (Default = :additional_column)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._aprint","page":"Library","title":"PrettyTables._aprint","text":"_aprint(buf::IO, [v,] indentation = 0, nspace = 2, minify = false)\n\nPrint the variable v to the buffer buf at the indentation level indentation. Each level has nspaces spaces. If minify is true, then the text is printed without breaklines or padding.\n\nIf v is not present, then only the indentation spaces will be printed.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._aprintln","page":"Library","title":"PrettyTables._aprintln","text":"_aprintln(buf::IO, [v,] indentation = 0, nspaces = 2, minify = false)\n\nSame as _aprint, but a new line will be added at the end. Notice that this newline is not added if minify is true Notice that this newline is not added if minify is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._check_hline-Tuple{PrettyTables.ProcessedTable, Vector{Int64}, AbstractVector, Int64}","page":"Library","title":"PrettyTables._check_hline","text":"_check_hline(ptable::ProcessedTable, hlines, body_hlines::AbstractVector, i::Int)\n\nCheck if there is a horizontal line after the ith row of ptable considering the options hlines and body_hlines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._check_vline-Tuple{PrettyTables.ProcessedTable, AbstractVector, Int64}","page":"Library","title":"PrettyTables._check_vline","text":"_check_vline(ptable::ProcessedTable, vlines::AbstractVector, j::Int)\n\nCheck if there is a vertical line after the jth column of ptable considering the option vlines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables._conf_to_nt","text":"_conf_to_nt(conf::PrettyTablesConf)\n\nConvert the configuration object conf to a named tuple so that it can be passed to pretty_table.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._count_hlines-Tuple{PrettyTables.ProcessedTable, Vector{Int64}, Vector{Int64}}","page":"Library","title":"PrettyTables._count_hlines","text":"_count_hlines(ptable::ProcessedTable, hlines::Vector{Int}, body_hlines::Vector{Int})\n\nCount the number of horizontal lines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._count_vlines-Tuple{PrettyTables.ProcessedTable, Vector{Int64}}","page":"Library","title":"PrettyTables._count_vlines","text":"_count_vlines(ptable::ProcessedTable, vlines::Vector{Int})\n\nCount the number of vertical lines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._data_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._data_size","text":"_data_size(ptable::ProcessedTable)\n\nReturn a tuple with the original data size.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_cell_alignment-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._get_cell_alignment","text":"_get_cell_alignemnt(ptable::ProcessedTable, i::Int, j::Int)\n\nGet the alignment of the ptable cell in ith row and jth column.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_column_alignment-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_column_alignment","text":"_get_column_alignment(ptable::ProcessedTable, j::Int)\n\nReturn the alignment of the jth column in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_column_id-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_column_id","text":"_get_column_id(ptable::ProcessedTable, j::Int)\n\nReturn the identification symbol of the column j of ptable. If the column is from the original data, then :__ORIGINAL_DATA__ is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_data_column_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_data_column_index","text":"_get_data_column_index(ptable::ProcessedTable, j::Int)\n\nGet the index of the jth data column in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_data_row_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_data_row_index","text":"_get_data_row_index(ptable::ProcessedTable, i::Int)\n\nGet the index of the ith data row in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_element-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._get_element","text":"_get_element(ptable::ProcessedTable, i::Int, j::Int)\n\nGet the element (i, j) if ptable. This function always considers the additional columns and the header.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_header_element-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_header_element","text":"_get_header_element(ptable::ProcessedTable, j::Int)\n\nGet the jth header element in ptable. This function always considers the additional columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_num_of_hidden_columns-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._get_num_of_hidden_columns","text":"_get_num_of_hidden_columns(ptable::ProcessedTable)\n\nReturn the number of hidden columns (see option max_num_of_columns).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_num_of_hidden_rows-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._get_num_of_hidden_rows","text":"_get_num_of_hidden_rows(ptable::ProcessedTable)\n\nReturn the number of hidden rows (see option max_num_of_rows).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_row_id-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_row_id","text":"_get_row_id(ptable::ProcessedTable, j::Int)\n\nReturn the identification symbol of the row i of ptable. If the row is part of the header, then it returns :__HEADER__: or :__SUBHEADER__, otherwise it returns :__ORIGINAL_DATA__ because we do not have the functionality to add new rows yet.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_table_column_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_table_column_index","text":"_get_table_column_index(ptable::ProcessedTable, jr::Int)\n\nGet the table column index related to a data table index jr in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._header_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._header_size","text":"_header_size(ptable::ProcessedTable)\n\nReturn a tuple with the header size.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._is_cell_alignment_overridden-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._is_cell_alignment_overridden","text":"_is_cell_alignment_overridden(ptable::ProcessedTable, i::Int, j::Int)\n\nReturn true is the alignment of the cell (i, j) is overridden using the keyword option cell_alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._num_additional_columns-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._num_additional_columns","text":"_num_additional_columns(ptable::ProcessedTable)\n\nReturn the number of additional columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._parse_cell_html-Tuple{Any}","page":"Library","title":"PrettyTables._parse_cell_html","text":"_parse_cell_html(cell::T; kwargs...)\n\nParse the table cell of type T.\n\nThis function must return a string that will be printed to the IO.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._parse_cell_latex-Tuple{Any}","page":"Library","title":"PrettyTables._parse_cell_latex","text":"_parse_cell_latex(cell::T; kwargs...)\n\nParse the table cell of type T.\n\nThis function must return a string that will be printed to the IO.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._process_hlines-Tuple{PrettyTables.ProcessedTable, Symbol}","page":"Library","title":"PrettyTables._process_hlines","text":"_process_hlines(ptable::ProcessedTable, hlines)\n\nProcess the horizontal lines hlines considerering the processed table ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._process_vlines-Tuple{PrettyTables.ProcessedTable, Symbol}","page":"Library","title":"PrettyTables._process_vlines","text":"_process_vlines(ptable::ProcessedTable, vlines)\n\nProcess the vertical lines vlines considerering the processed table ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._size","text":"_size(ptable::ProcessedTable)\n\nReturn a tuple with the current size of the table, considering the header, and the additional columns, but also the maximum number of rows and columns that user wants.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._total_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._total_size","text":"_total_size(ptable::ProcessedTable)\n\nReturn the total table size neglecting the options max_num_of_columns and max_num_of_rows.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.append_suffix_to_line!-Tuple{CustomTextCell, Int64, String}","page":"Library","title":"PrettyTables.append_suffix_to_line!","text":"append_suffix_to_line!(c::CustomTextCell, l::Int, suffix::String)\n\nAppend the suffix to the line l of the custom cell text c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.apply_line_padding!-Tuple{CustomTextCell, Int64, Int64, Int64}","page":"Library","title":"PrettyTables.apply_line_padding!","text":"apply_line_padding!(c::CustomTextCell, l::Int, left_pad::Int, right_pad::Int)\n\nApply to the line l of the custom text cell c the padding with left_pad spaces in the left and right_pad spaces in the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables.clear_pt_conf!","text":"clear_pt_conf!(conf::PrettyTablesConf)\n\nClear all configurations in conf.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.compact_type_str-Tuple{Any}","page":"Library","title":"PrettyTables.compact_type_str","text":"compact_type_str(T)\n\nReturn a string with a compact representation of type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.crop_line!-Tuple{CustomTextCell, Int64, Int64}","page":"Library","title":"PrettyTables.crop_line!","text":"crop_line!(c::CustomTextCell, l::Int, num::Int)\n\nCrop num characters from the line l of the custom text cell c. The number of cropped characters must consider the left and right alignment paddings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_latex_sn-Tuple{Int64}","page":"Library","title":"PrettyTables.ft_latex_sn","text":"ft_latex_sn(m_digits, [columns])\n\nFormat the numbers of the elements in the columns to a scientific notation using LaTeX. The number is first printed using sprintf1 functions with the g modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument m_digits.\n\nIf m_digits is a Vector, then columns must be also be a Vector with the same number of elements. If m_digits is a Integer, and columns is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if m_digits is a String and columns is a Vector, then the format will be applied only to the columns in columns.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_nomissing-Tuple{Missing, Int64, Int64}","page":"Library","title":"PrettyTables.ft_nomissing","text":"ft_nomissing(v, i::Int, j::Int)\n\nReplace missing with an empty string. If v is not Missing, then v is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_nonothing-Tuple{Nothing, Int64, Int64}","page":"Library","title":"PrettyTables.ft_nonothing","text":"ft_nonothing(v, i::Int, j::Int)\n\nReplace nothing with an empty string. If v is not Nothing, then v is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_printf-Tuple{String}","page":"Library","title":"PrettyTables.ft_printf","text":"ft_printf(ftv_str, [columns])\n\nApply the formats ftv_str (see the function sprintf1 of the package Formatting.jl) to the elements in the columns columns.\n\nIf ftv_str is a Vector, then columns must be also be a Vector with the same number of elements. If ftv_str is a String, and columns is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if ftv_str is a String and columns is a Vector, then the format will be applied only to the columns in columns.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_round-Tuple{Int64}","page":"Library","title":"PrettyTables.ft_round","text":"ft_round(digits, [columns])\n\nRound the elements in the columns to the number of digits.\n\nIf digits is a Vector, then columns must be also be a Vector with the same number of elements. If digits is a Number, and columns is not specified (or is empty), then the rounding will be applied to the entire table. Otherwise, if digits is a Number and columns is a Vector, then the elements in the columns columns will be rounded to the number of digits digits.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.get_printable_cell_line-Tuple{CustomTextCell, Int64}","page":"Library","title":"PrettyTables.get_printable_cell_line","text":"get_printable_cell_line(c::CustomTextCell, l::Int)\n\nReturn the printable line l of the custom text cell c. The printable cell line must consider the left and right alignment paddings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.get_rendered_line-Tuple{CustomTextCell, Int64}","page":"Library","title":"PrettyTables.get_rendered_line","text":"get_rendered_line(c::CustomTextCell, l::Int)\n\nReturn the rendered line l of the custom text cell l.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_cell-Tuple{Number, Number, Crayon}","page":"Library","title":"PrettyTables.hl_cell","text":"hl_cell(i::Number, j::Number, crayon::Crayon)\n\nHighlight the cell (i,j) with the crayon.\n\nhl_cell(cells::AbstractVector{NTuple(2,Int)}, crayon::Crayon)\n\nHighlights all the cells with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_cell-Tuple{Number, Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_cell","text":"hl_cell(i::Number, j::Number, decoration::HtmlDecoration)\n\nHighlight the cell (i, j) with the decoration (see HtmlDecoration).\n\nhl_cell(cells::AbstractVector{NTuple(2,Int)}, decoration::HtmlDecoration)\n\nHighlights all the cells with the decoration (see HtmlDecoration).\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_col-Tuple{Number, Crayon}","page":"Library","title":"PrettyTables.hl_col","text":"hl_col(i::Number, crayon::Crayon)\n\nHighlight the entire column i with the crayon.\n\nhl_col(cols::AbstractVector{Int}, crayon::Crayon)\n\nHighlights all the columns in cols with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_col-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_col","text":"hl_col(i::Number, decoration::HtmlDecoration)\n\nHighlight the entire column i with the decoration.\n\nhl_col(cols::AbstractVector{Int}, decoration::HtmlDecoration)\n\nHighlights all the columns in cols with the decoration.\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_geq-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_geq","text":"hl_geq(n::Number, decoration::HtmlDecoration)\n\nHighlight all elements that are ≥ n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_geq-Tuple{Number}","page":"Library","title":"PrettyTables.hl_geq","text":"hl_geq(n::Number)\n\nHighlight all elements that ≥ n.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_gt-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_gt","text":"hl_gt(n::Number, decoration::HtmlDecoration)\n\nHighlight all elements that are > n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_gt-Tuple{Number}","page":"Library","title":"PrettyTables.hl_gt","text":"hl_gt(n::Number)\n\nHighlight all elements that are > n.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_leq-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_leq","text":"hl_leq(n::Number, decoration::HtmlDecoration)\n\nHighlight all elements that are ≤ n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_leq-Tuple{Number}","page":"Library","title":"PrettyTables.hl_leq","text":"hl_leq(n::Number)\n\nHighlight all elements that are ≤ n.\n\nnote: Note\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_lt-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_lt","text":"hl_lt(n::Number, decoration::HtmlDecoration)\n\nHighlight all elements that are < n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_lt-Tuple{Number}","page":"Library","title":"PrettyTables.hl_lt","text":"hl_lt(n::Number)\n\nHighlight all elements that are < n.\n\ninfo: Info\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_row-Tuple{Number, Crayon}","page":"Library","title":"PrettyTables.hl_row","text":"hl_row(i::Number, crayon::Crayon)\n\nHighlight the entire row i with the crayon.\n\nhl_row(rows::AbstractVector{Int}, crayon::Crayon)\n\nHighlights all the rows in rows with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_row-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_row","text":"hl_row(i::Number, decoration::HtmlDecoration)\n\nHighlight the entire row i with the decoration.\n\nhl_row(rows::AbstractVector{Int}, decoration::HtmlDecoration)\n\nHighlights all the rows in rows with the decoration.\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_value-Tuple{Any, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_value","text":"hl_value(v::Any, decoration::HtmlDecoration)\n\nHighlight all the values that matches data[i,j] == v using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_value-Tuple{Any}","page":"Library","title":"PrettyTables.hl_value","text":"hl_value(v::Any)\n\nHighlight all the values that matches data[i,j] == v.\n\ninfo: Info\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.include_pt_in_file-Tuple{AbstractString, AbstractString, Vararg{Any}}","page":"Library","title":"PrettyTables.include_pt_in_file","text":"include_pt_in_file(filename::AbstractString, mark::AbstractString, args...; kwargs...)\n\nInclude a table in the file filename using the mark.\n\nThis function will print a table using the arguments args and keywords kwargs in the function pretty_table (the IO must not be passed to args here). Then, it will search inside the file filename for the following section:\n\n<PrettyTables mark>\n...\n</PrettyTables>\n\nand will replace everything between the marks with the printed table. If the closing tag is in a separate line, then all characters before it will be kept. This is important to add comment tags.\n\nIf the user wants to also remove the opening and ending tags, then pass the keyword remove_tags = true.\n\nThe keyword tag_append can be used to pass a string that can be used to add a text after the opening tag. This is important for HTML where the comments have openning and closing tags. Thus, if tag_append = \" -->\", then the following can be used to add a table into HTML files:\n\n<!-- <PrettyTables mark> -->\n...\n<!-- </PrettyTables> -->\n\nBy default, this function will copy the original file to filename_backup. If this is not desired, then pass the keyword backup_file = false to the function.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.parse_cell_text-Tuple{CustomTextCell}","page":"Library","title":"PrettyTables.parse_cell_text","text":"parse_cell_text(c::CustomTextCell; kwargs...)\n\nParse the cell text and return a vector of String with the printable cell text, where each element in the vector is a new line.\n\nThe returned data must contain only the printable characters.\n\nThe following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of pretty_table, and the user must choose whether or not support them.\n\nautowrap::Bool: If true, the user wants to wrap the text in the cell. In   this case, the option column_width contains the column width so that the   text can be wrapped into multiple lines.\ncell_first_line_only::Bool: If true, the user only wants the first line.\ncolumn_width::Integer: The column width.\ncompact_printing::Bool: If true, the user wants compact printing (see   :compact options of IOContext).\nlimit_printing::Bool: If true, the user wants the cells to be converted   using the option :limit => true in IOContext.\nlinebreaks::Bool: If true, the user wants line breaks inside the cells.\nrenderer::Union{Val{:print}, Val{:show}}: The render that the user wants to   convert the cells to strings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.pretty_table-Tuple{Any}","page":"Library","title":"PrettyTables.pretty_table","text":"pretty_table([io::IO | String | HTML,] table;  kwargs...)\n\nPrint to io the table.\n\nIf io is omitted, then it defaults to stdout. If String is passed in the place of io, then a String with the printed table will be returned by the function. If HTML is passed in the place of io, then an HTML object is returned with the printed table.\n\nWhen printing, it will be verified if table complies with Tables.jl API. If it is compliant, then this interface will be used to print the table. If it is not compliant, then only the following types are supported:\n\nAbstractVector: any vector can be printed.\nAbstractMatrix: any matrix can be printed.\nDict: any Dict can be printed. In this case, the special keyword  sortkeys can be used to select whether or not the user wants to print the  dictionary with the keys sorted. If it is false, then the elements will be  printed on the same order returned by the functions keys and values.  Notice that this assumes that the keys are sortable, if they are not, then  an error will be thrown.\n\nKeywords\n\nalignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the   columns (see the section Alignment).\nbackend::Union{Symbol, T_BACKENDS}: Select which back-end will be used to   print the table (see the section Backend). Notice that the   additional configuration in kwargs... depends on the selected backend.\ncell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   A tuple of functions with the signature f(data, i, j) that overrides the   alignment of the cell (i, j) to the value returned by f. It can also be a   single function, when it is assumed that only one alignment function is   required, or nothing, when no cell alignment modification will be   performed. If the function f does not return a valid alignment symbol as   shown in section Alignment, then it will be discarded. For   convenience, it can also be a dictionary of type (i, j) => a that   overrides the alignment of the cell (i, j) to a. a must be a symbol   like specified in the section Alignment. (Default = nothing)\n\nnote: Note\nIf more than one alignment function is passed to cell_alignment, then the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.\n\ncell_first_line_only::Bool: If true, then only the first line of each cell   will be printed. (Default = false)\ncompact_printing::Bool: Select if the option :compact will be used when   printing the data. (Default = true)\nformatters::Union{Nothing, Function, Tuple}: See the section   Formatters.\nheader::Union{Symbol, Vector{Symbol}}: The header must be a tuple of   vectors. Each one must have the number of elements equal to the number of   columns in the table. The first vector is considered the header and the   others are the subheaders. If it is nothing, then a default value based on   the type will be used. If a single vector is passed, then it will be   considered the header. (Default = nothing)\nheader_alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the   header columns (see the section Alignment). If the symbol that   specifies the alignment is :s for a specific column, then the same   alignment in the keyword alignment for that column will be used.   (Default = :s)\nheader_cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   This keyword has the same structure of cell_alignment but in this case it   operates in the header. Thus, (i, j) will be a cell in the header matrix   that contains the header and sub-headers. This means that the data field   in the functions will be the same value passed in the keyword header.   (Default = nothing)\n\nnote: Note\nIf more than one alignment function is passed to header_cell_alignment,   then the functions will be evaluated in the same order of the tuple. The   first one that returns a valid alignment symbol for each cell is applied,   and the rest is discarded.\n\nlimit_printing::Bool: If true, then the cells will be converted using the   property :limit => true of IOContext. (Default = true)\nmax_num_of_columns::Int: The maximum number of table columns that will be   rendered. If it is lower than 0, then all columns will be rendered.   (Default = -1)\nmax_num_of_rows::Int: The maximum number of table rows that will be   rendered. If it is lower than 0, then all rows will be rendered.   (Default = -1)\nrenderer::Symbol: A symbol that indicates which function should be used to   convert an object to a string. It can be :print to use the function   print or :show to use the function show. Notice that this selection is   applicable only to the table data. Headers, sub-headers, and row name column   are always rendered with print. (Default = :print)\nrow_labels::Union{Nothing, AbstractVector}: A vector containing the row   labels that will be appended to the left of the table. If it is nothing,   then the column with the row labels will not be shown. Notice that the size   of this vector must match the number of rows in the table.   (Default = nothing)\nrow_label_alignment::Symbol: Alignment of the column with the row labels   (see the section Alignment).\nrow_label_column_title::AbstractString: Title of the column with the row   labels. (Default = \"\")\nrow_number_column_title::AbstractString: Title of the column with the row   numbers. (Default = \"Row\")\nshow_header::Bool: If true, then the header will be printed. Notice that   all keywords and parameters related to the header and sub-headers will be   ignored. (Default = false)\nshow_row_number::Bool: If true, then a new column will be printed showing   the row number. (Default = false)\nshow_subheader::Bool: If true, then the sub-header will be printed, i.e.   the header will contain only one line. Notice that this option has no effect   if show_header = false. (Default = false)\ntitle::AbstractString: The title of the table. If it is empty, then no title   will be printed. (Default = \"\")\ntitle_alignment::Symbol: Alignment of the title, which must be a symbol as   explained in the section Alignment. This argument is ignored in the   LaTeX backend. (Default = :l)\n\nnote: Note\nNotice that all back-ends have the keyword tf to specify the table printing format. Thus, if the keyword backend is not present or if it is nothing, then the back-end will be automatically inferred from the type of the keyword tf. In this case, if tf is also not present, then it just fall-back to the text back-end unless HTML is passed as the first argument. In this case, the default back-end is set to HTML.\n\nIf String is used, then the keyword color selects whether or not the table will be converted to string with or without colors. The default value is false. Notice that this option only has effect in text backend.\n\nAlignment\n\nThe keyword alignment can be a Symbol or a vector of Symbol.\n\nIf it is a symbol, we have the following behavior:\n\n:l or :L: the text of all columns will be left-aligned;\n:c or :C: the text of all columns will be center-aligned;\n:r or :R: the text of all columns will be right-aligned;\nOtherwise it defaults to :r.\n\nIf it is a vector, then it must have the same number of symbols as the number of columns in data. The i-th symbol in the vector specify the alignment of the -i*-th column using the same symbols as described previously.\n\nnote: Note\nIn HTML backend, the user can select :n ou :N to print the cell without any alignment annotation.\n\n\n\nPretty table text back-end\n\nThis back-end produces text tables. This back-end can be used by selecting back-end = :text.\n\nKeywords\n\nalignment_anchor_fallback::Symbol: This keyword controls the line alignment   when using the regex alignment anchors if a match is not found. If it is   :l, then the left of the line will be aligned with the anchor. If it is   :c, then the line center will be aligned with the anchor. Otherwise, the   end of the line will be aligned with the anchor. (Default = :l)\nalignment_anchor_fallback_override::Dict{Int, Symbol}: A Dict{Int, Symbol}   to override the behavior of fallback_alignment_anchor for a specific   column. Example: Dict(3 => :c) changes the fallback alignment anchor   behavior for :c only for the column 3.\nalignment_anchor_regex::Dict{Int, AbstractVector{Regex}}: A dictionary   Dict{Int, AbstractVector{Regex}} with a set of regexes that is used to   align the values in the columns (keys). The characters at the first regex   match (or anchor) of each line in every cell of the column will be aligned.   The regex match is searched in the same order as the regexes appear on the   vector. The regex matching is applied after the cell conversion to string,   which includes the formatters. If no match is found for a specific line,   then the alignment of this line depends on the options   alignment_anchor_fallback and alignment_anchor_fallback_override. If the   key 0 is present, then the related regexes will be used to align all the   columns. In this case, all the other keys will be neglected. Example:   Dict(2 => [r\"\\.\"]) aligns the decimal point of the cells in the second   column. (Default = Dict{Int, Vector{Regex}}())\nautowrap::Bool: If true, then the text will be wrapped on spaces to fit   the column. Notice that this function requires linebreaks = true and the   column must have a fixed size (see columns_width).\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 0 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in hlines, but   the indices here are related to the printed rows of the body. Thus, if 1   is added to body_hlines, then a horizontal line will be drawn after the   first data row. (Default = Int[])\nbody_hlines_format::Union{Nothing, NTuple{4, Char}}: A tuple of 4 characters   specifying the format of the horizontal lines that will be drawn by   body_hlines. The characters must be the left intersection, the middle   intersection, the right intersection, and the row. If it is nothing, then   it will use the same format specified in tf. (Default = nothing)\ncolumns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying   the width of each column. If the width is equal or lower than 0, then it   will be automatically computed to fit the large cell in the column. If it is   a single integer, then this number will be used as the size of all columns.   (Default = 0)\ncrop::Symbol: Select the printing behavior when the data is bigger than the   available display size (see display_size). It can be :both to crop on   vertical and horizontal direction, :horizontal to crop only on horizontal   direction, :vertical to crop only on vertical direction, or :none to do   not crop the data at all. If the io has :limit => true, then crop is   set to :both by default. Otherwise, it is set to :none by default.\ncrop_num_lines_at_beginning::Int: Number of lines to be left at the   beginning of the printing when vertically cropping the output. Notice that   the lines required to show the title are automatically computed.   (Default = 0)\ncrop_subheader::Bool: If true, then the sub-header size will not be taken   into account when computing the column size. Hence, the print algorithm can   crop it to save space. This has no effect if the user selects a fixed column   width. (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of   the cells in the continuation row. This row is printed if the table is   vertically cropped. (Default = :c)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the   display size (num. of rows, num. of columns) that is available to print the   table. It is used to crop the data depending on the value of the keyword   crop. Notice that if a dimension is not positive, then it will be treated   as unlimited. (Default = displaysize(io))\nellipsis_line_skip::Integer: An integer defining how many lines will be   skipped from showing the ellipsis that indicates the text was cropped.   (Default = 0)\nequal_columns_width::Bool: If true, then all the columns will have the   same width. (Default = false)\nhighlighters::Union{Highlighter, Tuple}: An instance of Highlighter or a   tuple with a list of text highlighters (see the section Text   highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the horizontal lines will be drawn. It can be nothing, :all, :none or   a vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   TextFormat).\nIf it is :all, then all horizontal lines will be drawn.\nIf it is :none, then no horizontal line will be drawn.\nIf it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if 0 is in hlines, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.   Finally, for convenience, the top and bottom lines can be drawn by   adding the symbols :begin and :end to this vector, respectively, and   the line after the header can be drawn by adding the symbol :header.\n\ninfo: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.\n\nlinebreaks::Bool: If true, then \\n will break the line inside the   cells. (Default = false)\nmaximum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers   specifying the maximum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the maximum width of all columns. Notice that the parameter   columns_width has precedence over this one. (Default = 0)\nminimum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers   specifying the minimum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the minimum width of all columns. Notice that the parameter   columns_width has precedence over this one. (Default = 0)\nnewline_at_end::Bool: If false, then the table will not end with a newline   character. (Default = true)\noverwrite::Bool: If true, then the same number of lines in the printed   table will be deleted from the output io. This can be used to update the   table in the display continuously. (Default = false)\nrow_number_alignment::Symbol: Select the alignment of the row number column   (see the section Alignment). (Default = :r)\nshow_omitted_cell_summary::Bool: If true, then a summary will be printed   after the table with the number of columns and rows that were omitted.   (Default = true)\ntf::TextFormat: Table format used to print the table (see   TextFormat). (Default = tf_unicode)\ntitle_autowrap::Bool: If true, then the title text will be wrapped   considering the title size. Otherwise, lines larger than the title size will   be cropped. (Default = false)\ntitle_same_width_as_table::Bool: If true, then the title width will match   that of the table. Otherwise, the title size will be equal to the display   width. (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it   is :bottom, then the data, if required, will be cropped in the bottom. On   the other hand, if it is :middle, then the data will be cropped in the   middle if necessary. (Default = :bottom)\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the vertical lines will be drawn. It can be nothing, :all, :none or a   vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   TextFormat).\nIf it is :all, then all vertical lines will be drawn.\nIf it is :none, then no vertical line will be drawn.\nIf it is a vector of integers, then the vertical lines will be drawn only   after the columns in the vector. Notice that the top line will be drawn   if 0 is in vlines. Furthermore, it is important to mention that the   column number in this variable is related to the printed column.   Thus, it is affected by the options row_labels and show_row_number.   Finally, for convenience, the left and right vertical lines can be drawn   by adding the symbols :begin and :end to this vector, respectively,   and the line after the header can be drawn by adding the symbol   :header.\n\nThe following keywords related to crayons are available to customize the output decoration:\n\nborder_crayon::Crayon: Crayon to print the border.\nheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print the header.\nomitted_cell_summary_crayon::Crayon: Crayon used to print the omitted cell   summary.\nrow_label_crayon::Crayon: Crayon to print the row labels.\nrow_label_header_crayon::Crayon: Crayon to print the header of the column   with the row labels.\nrow_number_header_crayon::Crayon: Crayon for the header of the column with   the row numbers.\nsubheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print   sub-headers.\ntext_crayon::Crayon: Crayon to print default text.\ntitle_crayon::Crayon: Crayon to print the title.\n\nThe keywords header_crayon and subheader_crayon can be a Crayon or a Vector{Crayon}. In the first case, the Crayon will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.\n\nCrayons\n\nA Crayon is an object that handles a style for text printed on terminals. It is defined in the package Crayons.jl. There are many options available to customize the style, such as foreground color, background color, bold text, etc.\n\nA Crayon can be created in two different ways:\n\njulia> Crayon(foreground = :blue, background = :black, bold = :true)\n\njulia> crayon\"blue bg:black bold\"\n\nFor more information, see the package documentation.\n\nText highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure Highlighter that contains three fields:\n\nf::Function: Function with the signature f(data, i, j) in which should   return true if the element (i, j) in data must be highlighter, or   false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is   the highlighter. This function must return the Crayon to be applied to the   cell that must be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the   default fd is used.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, then the cell (i, j) will be highlighted.\n\nIf the function f returns true, then the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.\n\nA highlighter can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\ninfo: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nPretty table HTML backend\n\nThis backend produces HTML tables. This backend can be used by selecting backend = Val(:html).\n\nKeywords\n\nallow_html_in_cells::Bool: By default, special characters like <, >,   \", etc. are replaced in HTML backend to generate valid code. However, this   algorithm blocks the usage of HTML code inside of the cells. If this keyword   is true, then the escape algorithm will not be applied, allowing HTML   code inside all the cells. In this case, the user must ensure that the   output code is valid. If only few cells have HTML code, wrap then in a   HtmlCell object instead. (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of   the cells in the continuation row. This row is printed if the table is   vertically cropped. (Default = :r)\nhighlighters::Union{HtmlHighlighter, Tuple}: An instance of   HtmlHighlighter or a tuple with a list of HTML highlighters (see   the section HTML highlighters).\nlinebreaks::Bool: If true, then \\n will be replaced by <br>.   (Default = false)\nmaximum_columns_width::String: A string with the maximum width of each   columns. This string must contain a size that is valid in HTML. If it is not   empty, then each cell will have the following style:\n\"max-width\": <value of maximum_column_width>\n\"overflow\": \"hidden\"\n\"text-overflow\": \"ellipsis\"\n\"white-space\": \"nowrap\"\nIf it is empty, no additional style is applied. (Default = \"\")\nminify::Bool: If true, then output will be displayed minified, i.e.   without unnecessary indentation or newlines. (Default = false)\nstandalone::Bool: If true, then a complete HTML page will be generated.   Otherwise, only the content between the tags <table> and </table> will   be printed (with the tags included). (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it   is :bottom, then the data, if required, will be cropped in the bottom. On   the other hand, if it is :middle, then the data will be cropped in the   middle if necessary. (Default = :bottom)\ntf::HtmlTableFormat: An instance of the structure HtmlTableFormat   that defines the general format of the HTML table.\ntop_left_str::String: String to be printed at the left position of the top   bar. (Default = \"\")\ntop_left_str_decoration::HtmlDecoration: Decoration used to print the   top-left string (see top_left_str). (Default = HtmlDecoration())\ntop_right_str::String: String to be printed at the right position of the   top bar. Notice that this string will be replaced with the omitted cell   summary if it must be displayed. (Default = \"\")\ntop_right_str_decoration::HtmlDecoration: Decoration used to print the   top-right string (see top_right_str). (Default = HtmlDecoration())\n\nHTML highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should   return true if the element (i,j) in data must be highlighted, or   false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is   the highlighter. This function must return the HtmlDecoration to be   applied to the cell that must be highlighted.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, then the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.\n\nIf the function f returns true, then the function fd(h, data, i, j) will be called and must return an element of type HtmlDecoration that contains the decoration to be applied to the cell.\n\nA HTML highlighter can be constructed using two helpers:\n\nHtmlHighlighter(f::Function, decoration::HtmlDecoration)\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\ninfo: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nPretty table LaTeX backend\n\nThis backend produces LaTeX tables. This backend can be used by selecting backend = Val(:latex).\n\nKeywords\n\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 1 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in hlines, but   the indices here are related to the printed rows of the body. Thus, if 1   is added to body_hlines, then a horizontal line will be drawn after the   first data row. (Default = Int[])\nhighlighters::Union{LatexHighlighter, Tuple}: An instance of   LatexHighlighter or a tuple with a list of LaTeX highlighters (see the   section LaTeX highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the horizontal lines will be drawn. It can be nothing, :all, :none or   a vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   LatexTableFormat).\nIf it is :all, then all horizontal lines will be drawn.\nIf it is :none, then no horizontal line will be drawn.\nIf it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if 0 is in hlines, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.   Finally, for convenience, the top and bottom lines can be drawn by   adding the symbols :begin and :end to this vector, respectively, and   the line after the header can be drawn by adding the symbol :header.\n\ninfo: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.\n\nlabel::AbstractString: The label of the table. If empty, then no label will   be added. (Default = \"\")\nlongtable_footer::Union{Nothing, AbstractString}: The string that will be   drawn in the footer of the tables before a page break. This only works if   table_type is :longtable. If it is nothing, then no footer will be   used. (Default = nothing)\nrow_number_alignment::Symbol: Select the alignment of the row number column   (see the section Alignment). (Default = :r)\ntable_type::Union{Nothing, Symbol}: Select which LaTeX environment will be   used to print the table. Currently supported options are :tabular for   tabular or :longtable for longtable. If it is nothing then the   default option of the table format will be used. (Default = nothing)\ntf::LatexTableFormat: An instance of the structure   LatexTableFormat that defines the general format of the LaTeX table.\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the vertical lines will be drawn. It can be :all, :none or a vector of   integers. In the first case (the default behavior), all vertical lines will   be drawn. In the second case, no vertical line will be drawn. In the third   case, the vertical lines will be drawn only after the columns in the vector.   Notice that the left border will be drawn if 0 is in vlines.   Furthermore, it is important to mention that the column number in this   variable is related to the printed columns. Thus, it is affected by   the columns added using the variable show_row_number. Finally, for   convenience, the left and right border can be drawn by adding the symbols   :begin and :end to this vector, respectively.   (Default = :none)\nwrap_table::Union{Nothing, String}: This variable controls whether to wrap   the table in a environment defined by the variable wrap_table_environment.   Defaults to true. When false, the printed table begins with   \\begin{tabular}. This option does not work with :longtable. If it is   nothing then the default option of the table format will be used.   (Default = nothing)\nwrap_table_environment::Union{Nothing, String}: Environment that will be   used to wrap the table if the option wrap_table is true. If it is   nothing then the default option of the table format will be used.   (Default = nothing)\n\nLaTeX highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure LatexHighlighter. It contains the following two fields:\n\nf::Function: Function with the signature f(data, i, j) in which should   return true if the element (i, j) in data must be highlighted, or   false otherwise.\nfd::Functions: A function with the signature f(data, i, j, str)::String in   which data is the matrix, (i, j) is the element position in the table,   and str is the data converted to string. This function must return a   string that will be placed in the cell.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, i and j are the element coordinates that are being tested. If this function returns true, then the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.\n\nIf the function f returns true, then the function fd(data, i, j, str) will be called and must return the LaTeX string that will be placed in the cell.\n\nThere are two helpers that can be used to create LaTeX highlighters:\n\nLatexHighlighter(f::Function, envs::Union{String,Vector{String}})\n\nLatexHighlighter(f::Function, fd::Function)\n\nThe first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.\n\nThus, for example:\n\nLatexHighlighter((data, i, j) -> true, [\"textbf\", \"small\"])\n\nwill wrap all the cells in the table in the following environment:\n\n\\textbf{\\small{<Cell text>}}\n\ninfo: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nFormatters\n\nThe keyword formatters can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:\n\nf(v, i, j)\n\nwhere v is the value in the cell, i is the row number, and j is the column number. Thus, it must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.\n\nThis keyword can also be a single function, meaning that only one formatter is available, or nothing, meaning that no formatter will be used.\n\nFor example, if we want to multiply all values in odd rows of the column 2 by π, then the formatter should look like:\n\nformatters = (v, i, j) -> (j == 2 && isodd(i)) ? v * π : v\n\nIf multiple formatters are available, then they will be applied in the same order as they are located in the tuple. Thus, for the following formatters:\n\nformatters = (f1, f2, f3)\n\neach element v in the table (i-th row and j-th column) will be formatted by:\n\nv = f1(v,i,j)\nv = f2(v,i,j)\nv = f3(v,i,j)\n\nThus, the user must be ensure that the type of v between the calls are compatible.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf, Vararg{Any}}","page":"Library","title":"PrettyTables.pretty_table_with_conf","text":"pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...)\n\nCall pretty_table using the default configuration in conf. The args... and kwargs... can be the same as those passed to pretty_tables. Notice that all the configurations in kwargs... will overwrite the ones in conf.\n\nThe object conf can be created by the function set_pt_conf in which the keyword parameters can be any one supported by the function pretty_table as shown in the following.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.reset!-Tuple{CustomTextCell}","page":"Library","title":"PrettyTables.reset!","text":"reset!(c::CustomTextCell)\n\nReset all fields in the custom text cell c.\n\nThis function is not required for the API. It is called before parsing the custom text cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables.set_pt_conf!","text":"set_pt_conf!(conf; kwargs...)\n\nApply the configurations in kwargs to the object conf.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.set_pt_conf-Tuple{}","page":"Library","title":"PrettyTables.set_pt_conf","text":"set_pt_conf(;kwargs...)\n\nCreate a new configuration object based on the arguments in kwargs.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.@html_cell_str-Tuple{Any}","page":"Library","title":"PrettyTables.@html_cell_str","text":"@html_cell_str(str)\n\nCreate a table cell with HTML code.\n\nExamples\n\njulia> html_cell\"<i>Italic text</i>\"\nHtmlCell{String}(\"<i>Italic text</i>\")\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex_cell_str-Tuple{Any}","page":"Library","title":"PrettyTables.@latex_cell_str","text":"@latex_cell_str(str)\n\nCreate a table cell with LaTeX code.\n\nExamples\n\njulia> latex_cell\"\textbf{Bold text}\"\nLatexCell{String}(\"\\textbf{Bold text}\")\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@pt-Tuple","page":"Library","title":"PrettyTables.@pt","text":"@pt(expr...)\n\nPretty print tables in expr to stdout using the global configurations selected with the macro @ptconf.\n\nMultiple tables can be printed by passing multiple expressions like:\n\n@pt table1 table2 table3\n\nThe user can select the table header by passing the expression:\n\n:header = [<Vector with the header>]\n\nNotice that the header is valid only for the next printed table. Hence:\n\n@pt :header = header1 table1 :header = header2 table2 table3\n\nwill print table1 using header1, table2 using header2, and table3 using the default header.\n\ninfo: Info\nWhen more than one table is passed to this macro, then multiple calls to pretty_table will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.\n\nExamples\n\njulia> @ptconf tf = tf_simple\n\njulia> @pt :header = [\"Time\",\"Velocity\"] [1:1:10 ones(10)] :header = [\"Time\",\"Position\"] [1:1:10 1:1:10]\n======= ===========\n  Time   Velocity\n======= ===========\n   1.0        1.0\n   2.0        1.0\n   3.0        1.0\n   4.0        1.0\n   5.0        1.0\n   6.0        1.0\n   7.0        1.0\n   8.0        1.0\n   9.0        1.0\n  10.0        1.0\n======= ===========\n======= ===========\n  Time   Position\n======= ===========\n     1          1\n     2          2\n     3          3\n     4          4\n     5          5\n     6          6\n     7          7\n     8          8\n     9          9\n    10         10\n======= ===========\n\njulia> @pt ones(3,3) + I + [1 2 3; 4 5 6; 7 8 9]\n========= ======== =========\n  Col. 1   Col. 2   Col. 3\n========= ======== =========\n     3.0      3.0      4.0\n     5.0      7.0      7.0\n     8.0      9.0     11.0\n========= ======== =========\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@ptconf-Tuple","page":"Library","title":"PrettyTables.@ptconf","text":"@ptconf(expr...)\n\nAdd configurations in expr to be used with the macro @pt.\n\nThe expression format must be:\n\nkeyword1 = value1 keyword2 = value2 ...\n\nin which the keywords can be any other possible keyword that can be used in the function pretty_table.\n\nwarning: Warning\nIf a keyword is not supported by the function pretty_table, then no error message is printed when calling @ptconf. However, an error will be thrown when @pt is called.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@ptconfclean-Tuple{}","page":"Library","title":"PrettyTables.@ptconfclean","text":"@ptconfclean()\n\nClean all global configurations to pretty print tables using the macro @pt.\n\n\n\n\n\n","category":"macro"},{"location":"man/formatters/#Formatters","page":"Formatters","title":"Formatters","text":"","category":"section"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"The keyword formatters can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"f(v, i, j)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"where v is the value in the cell, i is the row number, and j is the column number. Thus, it must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This keyword can also be a single function, meaning that only one formatter is available, or nothing, meaning that no formatter will be used.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"For example, if we want to multiply all values in odd rows of the column 2 by π, then the formatter should look like:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"formatters = (v, i, j) -> (j == 2 && isodd(i)) ? v * π : v","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If multiple formatters are available, then they will be applied in the same order as they are located in the tuple. Thus, for the following formatters:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"formatters = (f1, f2, f3)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"each element v in the table (i-th row and j-th column) will be formatted by:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"v = f1(v, i, j)\nv = f2(v, i, j)\nv = f3(v, i, j)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Thus, the user must be ensure that the type of v between the calls are compatible.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = Any[f(a) for a = 0:30:90, f in (sind, cosd, tand)];\n\njulia> formatter = (v, i, j) -> round(v, digits = 3);\n\njulia> pretty_table(data; formatters = formatter)\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    0.0 │    1.0 │    0.0 │\n│    0.5 │  0.866 │  0.577 │\n│  0.866 │    0.5 │  1.732 │\n│    1.0 │    0.0 │    Inf │\n└────────┴────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThe user can check if a value is undefined (#undef) inside a formatter by using the comparison v isa PrettyTables.UndefinedCell.","category":"page"},{"location":"man/formatters/#Predefined-formatters","page":"Formatters","title":"Predefined formatters","text":"","category":"section"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"There are a set of predefined formatters (with names ft_*) to make the usage simpler. They are defined in the file ./src/predefined_formatter.jl.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"function ft_printf(ftv_str, [columns])","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Apply the formats ftv_str (see @sprintf) to the elements in the columns columns.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If ftv_str is a Vector, then columns must be also be a Vector with the same number of elements. If ftv_str is a String, and columns is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if ftv_str is a String and columns is a Vector, then the format will be applied only to the columns in columns.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThis formatter will be applied only to the cells that are of type Number. The other types of cells will be left untouched.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = Any[ f(a) for a = 0:30:90, f in (sind, cosd, tand)];\n\njulia> pretty_table(data; formatters = ft_printf(\"%5.3f\"))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│  0.000 │  1.000 │  0.000 │\n│  0.500 │  0.866 │  0.577 │\n│  0.866 │  0.500 │  1.732 │\n│  1.000 │  0.000 │    Inf │\n└────────┴────────┴────────┘\n\njulia> pretty_table(data; formatters = ft_printf(\"%5.3f\", [1,3]))\n┌────────┬──────────┬────────┐\n│ Col. 1 │   Col. 2 │ Col. 3 │\n├────────┼──────────┼────────┤\n│  0.000 │      1.0 │  0.000 │\n│  0.500 │ 0.866025 │  0.577 │\n│  0.866 │      0.5 │  1.732 │\n│  1.000 │      0.0 │    Inf │\n└────────┴──────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nNow, this formatter uses the function sprintf1 from the package Formatting.jl that drastically improved the performance compared to the case with the macro @sprintf. Thanks to @RalphAS for the information!","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"function ft_round(digits, [columns])","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Round the elements in the columns columns to the number of digits in digits.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If digits is a Vector, then columns must be also be a Vector with the same number of elements. If digits is a Number, and columns is not specified (or is empty), then the rounding will be applied to the entire table. Otherwise, if digits is a Number and columns is a Vector, then the elements in the columns columns will be rounded to the number of digits digits.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = Any[ f(a) for a = 0:30:90, f in (sind, cosd, tand)];\n\njulia> pretty_table(data; formatters = ft_round(1))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│    0.0 │    1.0 │    0.0 │\n│    0.5 │    0.9 │    0.6 │\n│    0.9 │    0.5 │    1.7 │\n│    1.0 │    0.0 │    Inf │\n└────────┴────────┴────────┘\n\njulia> pretty_table(data; formatters = ft_round(1, [1, 3]))\n┌────────┬──────────┬────────┐\n│ Col. 1 │   Col. 2 │ Col. 3 │\n├────────┼──────────┼────────┤\n│    0.0 │      1.0 │    0.0 │\n│    0.5 │ 0.866025 │    0.6 │\n│    0.9 │      0.5 │    1.7 │\n│    1.0 │      0.0 │    Inf │\n└────────┴──────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"ft_nomissing","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This pre-defined formatter converts any cell that is missing to an empty string.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = [1 2 missing; 3 missing 4; 5 6 missing];\n\njulia> pretty_table(data)\n┌────────┬─────────┬─────────┐\n│ Col. 1 │  Col. 2 │  Col. 3 │\n├────────┼─────────┼─────────┤\n│      1 │       2 │ missing │\n│      3 │ missing │       4 │\n│      5 │       6 │ missing │\n└────────┴─────────┴─────────┘\n\njulia> pretty_table(data, formatters = ft_nomissing)\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│      1 │      2 │        │\n│      3 │        │      4 │\n│      5 │      6 │        │\n└────────┴────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"ft_nonothing","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This pre-defined formatter converts any cell that is nothing to an empty string.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = [1 2 nothing; 3 missing 4; 5 6 nothing];\n\njulia> pretty_table(data)\n┌────────┬─────────┬─────────┐\n│ Col. 1 │  Col. 2 │  Col. 3 │\n├────────┼─────────┼─────────┤\n│      1 │       2 │ nothing │\n│      3 │ missing │       4 │\n│      5 │       6 │ nothing │\n└────────┴─────────┴─────────┘\n\njulia> pretty_table(data, formatters = ft_nonothing)\n┌────────┬─────────┬────────┐\n│ Col. 1 │  Col. 2 │ Col. 3 │\n├────────┼─────────┼────────┤\n│      1 │       2 │        │\n│      3 │ missing │      4 │\n│      5 │       6 │        │\n└────────┴─────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Notice that ft_nomissing and ft_nonothing can be combined:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"julia> data = [1 2 nothing; 3 missing 4; 5 6 nothing];\n\njulia> pretty_table(data, formatters = (ft_nonothing, ft_nomissing))\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│      1 │      2 │        │\n│      3 │        │      4 │\n│      5 │      6 │        │\n└────────┴────────┴────────┘","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThe formatters keyword is supported in all back-ends.","category":"page"},{"location":"man/html_backend/#HTML-back-end","page":"HTML","title":"HTML back-end","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<script language=\"javascript\" type=\"text/javascript\">\n function resizeIframe(obj)\n {\n   obj.style.height = obj.contentWindow.document.body.scrollHeight + 10 + 'px';\n   obj.style.width = obj.contentWindow.document.body.scrollWidth + 100 + 'px';\n }\n</script>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The following options are available when the HTML backend is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"allow_html_in_cells::Bool: By default, special characters like <, >,   \", etc. are replaced in HTML backend to generate valid code. However, this   algorithm blocks the usage of HTML code inside of the cells. If this keyword   is true, then the escape algorithm will not be applied, allowing HTML   code inside all the cells. In this case, the user must ensure that the   output code is valid. If only few cells have HTML code, wrap then in a   HtmlCell object instead. (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of   the cells in the continuation row. This row is printed if the table is   vertically cropped. (Default = :r)\nhighlighters::Union{HtmlHighlighter, Tuple}: An instance of   HtmlHighlighter or a tuple with a list of HTML highlighters (see   the section HTML highlighters).\nlinebreaks::Bool: If true, then \\\\n will be replaced by <br>.   (Default = false)\nmaximum_columns_width::String: A string with the maximum width of each   columns. This string must contain a size that is valid in HTML. If it is not   empty, then each cell will have the following style:\n\"max-width\": <value of maximum_column_width>\n\"overflow\": \"hidden\"\n\"text-overflow\": \"ellipsis\"\n\"white-space\": \"nowrap\"\nIf it is empty, no additional style is applied. (Default = \"\")\nstandalone::Bool: If true, then a complete HTML page will be generated.   Otherwise, only the content between the tags <table> and </table> will   be printed (with the tags included). (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it   is :bottom, then the data, if required, will be cropped in the bottom. On   the other hand, if it is :middle, then the data will be cropped in the   middle if necessary. (Default = :bottom)\ntf::HtmlTableFormat: An instance of the structure HtmlTableFormat   that defines the general format of the HTML table.\ntop_left_str::String: String to be printed at the left position of the top   bar. (Default = \"\")\ntop_left_str_decoration::HtmlDecoration: Decoration used to print the   top-left string (see top_left_str). (Default = HtmlDecoration())\ntop_right_str::String: String to be printed at the right position of the   top bar. Notice that this string will be replaced with the omitted cell   summary if it must be displayed. (Default = \"\")\ntop_right_str_decoration::HtmlDecoration: Decoration used to print the   top-right string (see top_right_str). (Default = HtmlDecoration())","category":"page"},{"location":"man/html_backend/#HTML-highlighters","page":"HTML","title":"HTML highlighters","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"f::Function: Function with the signature f(data, i, j) in which should   return true if the element (i,j) in data must be highlighted, or   false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is   the highlighter. This function must return the HtmlDecoration to be   applied to the cell that must be highlighted.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The function f has the following signature:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"f(data, i, j)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"in which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, then the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"If the function f returns true, then the function fd(h, data, i, j) will be called and must return an element of type HtmlDecoration that contains the decoration to be applied to the cell.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"A HTML highlighter can be constructed using two helpers:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"HtmlHighlighter(f::Function, decoration::HtmlDecoration)\nHtmlHighlighter(f::Function, fd::Function)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"info: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"note: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"There are a set of pre-defined highlighters (with names hl_*) to make the usage simpler. They are defined in the file ./src/backends/html/predefined_highlighters.jl.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"julia> t = 0:1:20;\n\njulia> data = hcat(t, ones(length(t)) * 1, 1 * t, 0.5 .* t.^2);\n\njulia> header = ([\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n                 [ \"[s]\",       \"[m/s²]\",    \"[m/s]\",      \"[m]\"]);\n\njulia> hl_v = HtmlHighlighter((data, i, j) -> (j == 3) && data[i, 3] > 9, HtmlDecoration(color = \"blue\", font_weight = \"bold\"));\n\njulia> hl_p = HtmlHighlighter((data, i, j) -> (j == 4) && data[i, 4] > 10, HtmlDecoration(color = \"red\"));\n\njulia> hl_e = HtmlHighlighter((data, i, j) -> data[i, 1] == 10, HtmlDecoration(background = \"black\", color = \"white\"))\n\njulia> pretty_table(data; backend = Val(:html), header = header, highlighters = (hl_e, hl_p, hl_v), standalone = true)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_highlighters_example.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_highlighters_example.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/#HTML-table-formats","page":"HTML","title":"HTML table formats","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The following table formats are available when using the html back-end:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"tf_html_default (Default)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_default.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_default.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"tf_html_dark","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_dark.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_dark.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"tf_html_minimalist","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_minimalist.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_minimalist.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"tf_html_matrix","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_matrix.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_matrix.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"info: Info\nIn this case, the table format html_matrix was printed with the option noheader = true.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"tf_html_simple","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_simple.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_simple.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/text_backend/#Text-back-end","page":"Text","title":"Text back-end","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following options are available when the text backend is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"alignment_anchor_fallback::Symbol: This keyword controls the line alignment   when using the regex alignment anchors if a match is not found. If it is   :l, then the left of the line will be aligned with the anchor. If it is   :c, then the line center will be aligned with the anchor. Otherwise, the   end of the line will be aligned with the anchor. (Default = :l)\nalignment_anchor_fallback_override::Dict{Int, Symbol}: A Dict{Int, Symbol}   to override the behavior of fallback_alignment_anchor for a specific   column. Example: Dict(3 => :c) changes the fallback alignment anchor   behavior for :c only for the column 3.\nalignment_anchor_regex::Dict{Int, AbstractVector{Regex}}: A dictionary   Dict{Int, AbstractVector{Regex}} with a set of regexes that is used to   align the values in the columns (keys). The characters at the first regex   match (or anchor) of each line in every cell of the column will be aligned.   The regex match is searched in the same order as the regexes appear on the   vector. The regex matching is applied after the cell conversion to string,   which includes the formatters. If no match is found for a specific line,   then the alignment of this line depends on the options   alignment_anchor_fallback and alignment_anchor_fallback_override. If the   key 0 is present, then the related regexes will be used to align all the   columns. In this case, all the other keys will be neglected. Example:   Dict(2 => [r\"\\\\.\"]) aligns the decimal point of the cells in the second   column. (Default = Dict{Int, Vector{Regex}}())\nautowrap::Bool: If true, then the text will be wrapped on spaces to fit   the column. Notice that this function requires linebreaks = true and the   column must have a fixed size (see columns_width).\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 0 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in hlines, but   the indices here are related to the printed rows of the body. Thus, if 1   is added to body_hlines, then a horizontal line will be drawn after the   first data row. (Default = Int[])\nbody_hlines_format::Union{Nothing, NTuple{4, Char}}: A tuple of 4 characters   specifying the format of the horizontal lines that will be drawn by   body_hlines. The characters must be the left intersection, the middle   intersection, the right intersection, and the row. If it is nothing, then   it will use the same format specified in tf. (Default = nothing)\ncolumns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying   the width of each column. If the width is equal or lower than 0, then it   will be automatically computed to fit the large cell in the column. If it is   a single integer, then this number will be used as the size of all columns.   (Default = 0)\ncrop::Symbol: Select the printing behavior when the data is bigger than the   available display size (see display_size). It can be :both to crop on   vertical and horizontal direction, :horizontal to crop only on horizontal   direction, :vertical to crop only on vertical direction, or :none to do   not crop the data at all. If the io has :limit => true, then crop is   set to :both by default. Otherwise, it is set to :none by default.\ncrop_num_lines_at_beginning::Int: Number of lines to be left at the   beginning of the printing when vertically cropping the output. Notice that   the lines required to show the title are automatically computed.   (Default = 0)\ncrop_subheader::Bool: If true, then the sub-header size will not be taken   into account when computing the column size. Hence, the print algorithm can   crop it to save space. This has no effect if the user selects a fixed column   width. (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of   the cells in the continuation row. This row is printed if the table is   vertically cropped. (Default = :c)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the   display size (num. of rows, num. of columns) that is available to print the   table. It is used to crop the data depending on the value of the keyword   crop. Notice that if a dimension is not positive, then it will be treated   as unlimited. (Default = displaysize(io))\nellipsis_line_skip::Integer: An integer defining how many lines will be   skipped from showing the ellipsis that indicates the text was cropped.   (Default = 0)\nequal_columns_width::Bool: If true, then all the columns will have the   same width. (Default = false)\nhighlighters::Union{Highlighter, Tuple}: An instance of Highlighter or a   tuple with a list of text highlighters (see the section Text   highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the horizontal lines will be drawn. It can be nothing, :all, :none or   a vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   TextFormat).\nIf it is :all, then all horizontal lines will be drawn.\nIf it is :none, then no horizontal line will be drawn.\nIf it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if 0 is in hlines, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.   Finally, for convenience, the top and bottom lines can be drawn by   adding the symbols :begin and :end to this vector, respectively, and   the line after the header can be drawn by adding the symbol :header.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"linebreaks::Bool: If true, then \\\\n will break the line inside the   cells. (Default = false)\nmaximum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers   specifying the maximum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the maximum width of all columns. Notice that the parameter   columns_width has precedence over this one. (Default = 0)\nminimum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers   specifying the minimum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the minimum width of all columns. Notice that the parameter   columns_width has precedence over this one. (Default = 0)\nnewline_at_end::Bool: If false, then the table will not end with a newline   character. (Default = true)\noverwrite::Bool: If true, then the same number of lines in the printed   table will be deleted from the output io. This can be used to update the   table in the display continuously. (Default = false)\nrow_number_alignment::Symbol: Select the alignment of the row number column   (see the section Alignment). (Default = :r)\nshow_omitted_cell_summary::Bool: If true, then a summary will be printed   after the table with the number of columns and rows that were omitted.   (Default = true)\ntf::TextFormat: Table format used to print the table (see   TextFormat). (Default = tf_unicode)\ntitle_autowrap::Bool: If true, then the title text will be wrapped   considering the title size. Otherwise, lines larger than the title size will   be cropped. (Default = false)\ntitle_same_width_as_table::Bool: If true, then the title width will match   that of the table. Otherwise, the title size will be equal to the display   width. (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it   is :bottom, then the data, if required, will be cropped in the bottom. On   the other hand, if it is :middle, then the data will be cropped in the   middle if necessary. (Default = :bottom)\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the vertical lines will be drawn. It can be nothing, :all, :none or a   vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   TextFormat).\nIf it is :all, then all vertical lines will be drawn.\nIf it is :none, then no vertical line will be drawn.\nIf it is a vector of integers, then the vertical lines will be drawn only   after the columns in the vector. Notice that the top line will be drawn   if 0 is in vlines. Furthermore, it is important to mention that the   column number in this variable is related to the printed column.   Thus, it is affected by the options row_labels and show_row_number.   Finally, for convenience, the left and right vertical lines can be drawn   by adding the symbols :begin and :end to this vector, respectively,   and the line after the header can be drawn by adding the symbol   :header.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following keywords related to crayons are available to customize the output decoration:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"border_crayon::Crayon: Crayon to print the border.\nheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print the header.\nomitted_cell_summary_crayon::Crayon: Crayon used to print the omitted cell   summary.\nrow_label_crayon::Crayon: Crayon to print the row labels.\nrow_label_header_crayon::Crayon: Crayon to print the header of the column   with the row labels.\nrow_number_header_crayon::Crayon: Crayon for the header of the column with   the row numbers.\nsubheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print   sub-headers.\ntext_crayon::Crayon: Crayon to print default text.\ntitle_crayon::Crayon: Crayon to print the title.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The keywords header_crayon and subheader_crayon can be a Crayon or a Vector{Crayon}. In the first case, the Crayon will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf the renderer show is used, then all strings will be printed with surrounding quotes. However, if a formatter modifies a value and return a string, then those surrounding quotes will be removed if the original value is not a string.","category":"page"},{"location":"man/text_backend/#Crayons","page":"Text","title":"Crayons","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A Crayon is an object that handles a style for text printed on terminals. It is defined in the package Crayons.jl. There are many options available to customize the style, such as foreground color, background color, bold text, etc.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A Crayon can be created in two different ways:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> Crayon(foreground = :blue, background = :black, bold = :true)\n\njulia> crayon\"blue bg:black bold\"","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"For more information, see the Crayon.jl documentation.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe Crayon.jl package is re-exported by PrettyTables.jl. Hence, you do not need using Crayons to create a Crayon.","category":"page"},{"location":"man/text_backend/#Cropping","page":"Text","title":"Cropping","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The keyword crop can be used to define how the output will be cropped if the display has limits. The default behavior depends on the property :limit of the io. If io has :limit => true, the default value of crop is :both. Otherwise, if :limit => false or it is not defined at all, then crop defaults to :none.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If pretty_table is called without io, then stdout is wrapped in a IOContext with :limit => true.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The display size can be configured by the keyword display_size, which is a tuple of two Int with the number of rows and columns, respectively. If this keyword is not specified, then it is automatically obtained using the function displaysize(io).","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[1    false      1.0     0x01 ;\n                  2     true      2.0     0x02 ;\n                  3    false      3.0     0x03 ;\n                  4     true      4.0     0x04 ;\n                  5    false      5.0     0x05 ;\n                  6     true      6.0     0x06 ;];\n\njulia> pretty_table(data, display_size = (11, 30))\n┌────────┬────────┬────────┬──\n│ Col. 1 │ Col. 2 │ Col. 3 │ ⋯\n├────────┼────────┼────────┼──\n│      1 │  false │    1.0 │ ⋯\n│      2 │   true │    2.0 │ ⋯\n│      3 │  false │    3.0 │ ⋯\n│   ⋮    │   ⋮    │   ⋮    │ ⋱\n└────────┴────────┴────────┴──\n   1 column and 3 rows omitted\n\njulia> pretty_table(data, display_size = (11, 30), crop = :none)\n┌────────┬────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │\n├────────┼────────┼────────┼────────┤\n│      1 │  false │    1.0 │      1 │\n│      2 │   true │    2.0 │      2 │\n│      3 │  false │    3.0 │      3 │\n│      4 │   true │    4.0 │      4 │\n│      5 │  false │    5.0 │      5 │\n│      6 │   true │    6.0 │      6 │\n└────────┴────────┴────────┴────────┘","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIn vertical cropping, the header and the first table row is always printed.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nThe highlighters will work even in partially printed data.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If the user selects a fixed size for the columns (using the keyword columns_width), enables line breaks (using the keyword linebreaks), and sets autowrap = true, then the algorithm wraps the text on spaces to automatically fit the space.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = [\"One very very very big long long line\"; \"Another very very very big big long long line\"];\n\njulia> pretty_table(data, columns_width = 10, autowrap = true, linebreaks = true, show_row_number = true)\n┌─────┬────────────┐\n│ Row │     Col. 1 │\n├─────┼────────────┤\n│   1 │   One very │\n│     │  very very │\n│     │   big long │\n│     │  long line │\n│   2 │    Another │\n│     │  very very │\n│     │   very big │\n│     │   big long │\n│     │  long line │\n└─────┴────────────┘","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"It is also possible to change the vertical cropping behavior to crop the table in the middle instead of the bottom. This can be accomplished by passing the option vcrop_mode = :middle to pretty_table:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[1    false      1.0     0x01 ;\n                  2     true      2.0     0x02 ;\n                  3    false      3.0     0x03 ;\n                  4     true      4.0     0x04 ;\n                  5    false      5.0     0x05 ;\n                  6     true      6.0     0x06 ;];\n\njulia> pretty_table(data, display_size = (11, 30), vcrop_mode = :middle)\n┌────────┬────────┬────────┬──\n│ Col. 1 │ Col. 2 │ Col. 3 │ ⋯\n├────────┼────────┼────────┼──\n│      1 │  false │    1.0 │ ⋯\n│      2 │   true │    2.0 │ ⋯\n│   ⋮    │   ⋮    │   ⋮    │ ⋱\n│      6 │   true │    6.0 │ ⋯\n└────────┴────────┴────────┴──\n   1 column and 3 rows omitted","category":"page"},{"location":"man/text_backend/#Text-highlighters","page":"Text","title":"Text highlighters","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure Highlighter that contains three fields:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"f::Function: Function with the signature f(data, i, j) in which should   return true if the element (i, j) in data must be highlighted, or   false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is   the highlighter. This function must return the Crayon to be applied to the   cell that must be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the   default fd is used.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The function f has the following signature:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"f(data, i, j)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"in which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, then the cell (i, j) will be highlighted.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If the function f returns true, then the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A highlighter can be constructed using three helpers:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function; kwargs...)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function, crayon::Crayon)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will apply the crayon to the highlighted cell, and","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function, fd::Function)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will apply the Crayon returned by the function fd to the highlighted cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\njulia> h1 = Highlighter(f      = (data, i, j) -> (data[i, j] < 0.5),\n                        crayon = crayon\"red bold\" )\n\njulia> h2 = Highlighter((data,i,j) -> (data[i, j] > 0.5),\n                        bold       = true,\n                        foreground = :blue )\n\njulia> h3 = Highlighter(f      = (data, i, j) -> (data[i, j] == 0.5),\n                        crayon = Crayon(bold = true, foreground = :yellow) )\n\njulia> pretty_table(data, highlighters = (h1, h2, h3), compact_printing = false)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\njulia> hl_odd = Highlighter(f      = (data, i, j) -> i % 2 == 0,\n                            crayon = Crayon(background = :light_blue))\n\njulia> pretty_table(data, highlighters = hl_odd, formatters = ft_printf(\"%10.5f\"))","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"There are a set of pre-defined highlighters (with names hl_*) to make the usage simpler. They are defined in the file ./src/backends/text/predefined_highlighters.jl.","category":"page"},{"location":"man/text_backend/#Text-table-formats","page":"Text","title":"Text table formats","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following table formats are available when using the text back-end:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_unicode (Default)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"┌────────┬────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │\n├────────┼────────┼────────┼────────┤\n│      1 │  false │    1.0 │      1 │\n│      2 │   true │    2.0 │      2 │\n│      3 │  false │    3.0 │      3 │\n└────────┴────────┴────────┴────────┘","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_ascii_dots","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":".....................................\n: Col. 1 : Col. 2 : Col. 3 : Col. 4 :\n:........:........:........:........:\n:      1 :  false :    1.0 :      1 :\n:      2 :   true :    2.0 :      2 :\n:      3 :  false :    3.0 :      3 :\n:........:........:........:........:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_ascii_rounded","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":".--------.--------.--------.--------.\n| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n:--------+--------+--------+--------:\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |\n'--------'--------'--------'--------'","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_borderless","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"  Col. 1   Col. 2   Col. 3   Col. 4\n\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_compact","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":" -------- -------- -------- --------\n  Col. 1   Col. 2   Col. 3   Col. 4\n -------- -------- -------- --------\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3\n -------- -------- -------- --------","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_markdown","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n|--------|--------|--------|--------|\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_matrix","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"┌                     ┐\n│ 1   false   1.0   1 │\n│ 2    true   2.0   2 │\n│ 3   false   3.0   3 │\n└                     ┘","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nIn this case, the table format matrix was printed with the option show_header = false.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_mysql","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"+--------+--------+--------+--------+\n| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n+--------+--------+--------+--------+\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |\n+--------+--------+--------+--------+","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_simple","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"========= ======== ======== =========\n  Col. 1   Col. 2   Col. 3   Col. 4\n========= ======== ======== =========\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3\n========= ======== ======== =========","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_unicode_rounded","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"╭────────┬────────┬────────┬────────╮\n│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │\n├────────┼────────┼────────┼────────┤\n│      1 │  false │    1.0 │      1 │\n│      2 │   true │    2.0 │      2 │\n│      3 │  false │    3.0 │      3 │\n╰────────┴────────┴────────┴────────╯","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nThe format unicode_rounded should look awful on your browser, but it should be printed fine on your terminal.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)];\n\njulia> pretty_table(data, tf = tf_ascii_dots)\n..................................\n:   Col. 1 :   Col. 2 :   Col. 3 :\n:..........:..........:..........:\n:      0.0 :      1.0 :      0.0 :\n: 0.258819 : 0.965926 : 0.267949 :\n:      0.5 : 0.866025 :  0.57735 :\n: 0.707107 : 0.707107 :      1.0 :\n: 0.866025 :      0.5 :  1.73205 :\n: 0.965926 : 0.258819 :  3.73205 :\n:      1.0 :      0.0 :      Inf :\n:..........:..........:..........:\n\njulia> pretty_table(data, tf = tf_compact)\n ---------- ---------- ----------\n    Col. 1     Col. 2     Col. 3\n ---------- ---------- ----------\n       0.0        1.0        0.0\n  0.258819   0.965926   0.267949\n       0.5   0.866025    0.57735\n  0.707107   0.707107        1.0\n  0.866025        0.5    1.73205\n  0.965926   0.258819    3.73205\n       1.0        0.0        Inf\n ---------- ---------- ----------","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"It is also possible to define you own custom table by creating a new instance of the structure TextFormat. For example, let's say that you want a table like simple that does not print the bottom line:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)];\n\njulia> tf = TextFormat(up_right_corner     = '=',\n                       up_left_corner      = '=',\n                       bottom_left_corner  = '=',\n                       bottom_right_corner = '=',\n                       up_intersection     = ' ',\n                       left_intersection   = '=',\n                       right_intersection  = '=',\n                       middle_intersection = ' ',\n                       bottom_intersection = ' ',\n                       column              = ' ',\n                       row                 = '=',\n                       hlines              = [:begin, :header]);\n\njulia> pretty_table(data, tf = tf)\n=========== ========== ===========\n    Col. 1     Col. 2     Col. 3\n=========== ========== ===========\n       0.0        1.0        0.0\n  0.258819   0.965926   0.267949\n       0.5   0.866025    0.57735\n  0.707107   0.707107        1.0\n  0.866025        0.5    1.73205\n  0.965926   0.258819    3.73205\n       1.0        0.0        Inf\n","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"or that does not print the header line:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)];\n\njulia> tf = TextFormat(up_right_corner     = '=',\n                       up_left_corner      = '=',\n                       bottom_left_corner  = '=',\n                       bottom_right_corner = '=',\n                       up_intersection     = ' ',\n                       left_intersection   = '=',\n                       right_intersection  = '=',\n                       middle_intersection = ' ',\n                       bottom_intersection = ' ',\n                       column              = ' ',\n                       row                 = '=',\n                       hlines              = [:begin, :end]);\n\njulia> pretty_table(data, tf = tf)\n=========== ========== ===========\n    Col. 1     Col. 2     Col. 3\n       0.0        1.0        0.0\n  0.258819   0.965926   0.267949\n       0.5   0.866025    0.57735\n  0.707107   0.707107        1.0\n  0.866025        0.5    1.73205\n  0.965926   0.258819    3.73205\n       1.0        0.0        Inf\n=========== ========== ===========","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"For more information, see the documentation of the structure TextFormat.","category":"page"},{"location":"man/text_backend/#Custom-text-cells","page":"Text","title":"Custom text cells","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"PrettyTables.jl escapes all ANSI sequences by default so that every character in the cell is printable. This behavior let us to easily compute the cell size, which is essential to many features like alignment and cropping. However, there are specific cases in which the user wants to render a cell with escape sequences that does not produce printable characters. In this case, the user must create a custom text cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A custom text cell is an object of a type derived from CustomTextCell. Let's suppose that we want to create a custom cell called MyTextCell. This object must comply with the API by defining the following functions:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"append_suffix_to_line!(c::MyTextCell, l::Int, suffix::String)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Append the suffix to the line l of the custom cell text c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"apply_line_padding!(c::MyTextCell, l::Int, left_pad::Int, right_pad::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Apply to the line l of the custom text cell c the padding with left_pad spaces in the left and right_pad spaces in the right.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"crop_line!(c::MyTextCell, l::Int, num::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Crop num characters from the line l of the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"get_printable_cell_line(c::MyTextCell, l::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Return the printable line l of the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"get_rendered_line(c::MyTextCell, l::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Return the rendered line l of the custom text cell l.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"parse_cell_text(c::CustomTextCell; kwargs...)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Parse the cell text and return a vector of String with the printable cell text, where each element in the vector is a new line.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The returned data must contain only the printable characters.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of pretty_table, and the user must choose whether or not support them.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"autowrap::Bool: If true, the user wants to wrap the text in the cell. In   this case, the option column_width contains the column width so that the   text can be wrapped into multiple lines.\ncell_first_line_only::Bool: If true, the user only wants the first line.\ncolumn_width::Integer: The column width.\ncompact_printing::Bool: If true, the user wants compact printing (see   :compact options of IOContext).\nlimit_printing::Bool: If true, the user wants the cells to be converted   using the option :limit => true in IOContext.\nlinebreaks::Bool: If true, the user wants line breaks inside the cells.\nrenderer::Union{Val{:print}, Val{:show}}: The render that the user wants to   convert the cells to strings.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"reset!(c::CustomTextCell)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Reset all fields in the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe reset! function is not required for the API. It is called before parsing the custom text cell.","category":"page"},{"location":"man/text_backend/#UrlTextCell","page":"Text","title":"UrlTextCell","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"There is one custom text cell bundled with PrettyTables.jl called UrlTextCell. This type adds support for rendering implicit hyperlinks using the escape sequence \\e]8. Hence, the user can render a text that has a hyperlink associated with it.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A UrlTextCell can be created with the following function:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"UrlTextCell(text::String, url::String","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"which creates a URL cell with a specific text that points to an url.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> table = [\n        1 \"Ronan Arraes Jardim Chagas\" UrlTextCell(\"Ronan Arraes Jardim Chagas\", \"https://ronanarraes.com\")\n        2 \"Google\" UrlTextCell(\"Google\", \"https://google.com\")\n        3 \"Apple\" UrlTextCell(\"Apple\", \"https://apple.com\")\n        4 \"Emojis!\" UrlTextCell(\"😃\"^20, \"https://emojipedia.org/github/\")\n    ]\n\njulia> pretty_table(table)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"warning: Warning\nThis feature is not supported by all terminal emulators.","category":"page"},{"location":"man/alignment/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"The keyword alignment can be a Symbol or a vector of Symbol.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"If it is a symbol, we have the following behavior:","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":":l or :L: the text of all columns will be left-aligned;\n:c or :C: the text of all columns will be center-aligned;\n:r or :R: the text of all columns will be right-aligned;\nOtherwise it defaults to :r.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"If it is a vector, then it must have the same number of symbols as the number of columns in data. The i-th symbol in the vector specify the alignment of the i-th column using the same symbols as described previously.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"julia> data = Any[ f(a) for a = 0:30:90, f in (sind, cosd, tand)];\n\njulia> pretty_table(data; alignment=:l)\n┌──────────┬──────────┬─────────┐\n│ Col. 1   │ Col. 2   │ Col. 3  │\n├──────────┼──────────┼─────────┤\n│ 0.0      │ 1.0      │ 0.0     │\n│ 0.5      │ 0.866025 │ 0.57735 │\n│ 0.866025 │ 0.5      │ 1.73205 │\n│ 1.0      │ 0.0      │ Inf     │\n└──────────┴──────────┴─────────┘\n\njulia> pretty_table(data; alignment=[:l, :c, :r])\n┌──────────┬──────────┬─────────┐\n│ Col. 1   │  Col. 2  │  Col. 3 │\n├──────────┼──────────┼─────────┤\n│ 0.0      │   1.0    │     0.0 │\n│ 0.5      │ 0.866025 │ 0.57735 │\n│ 0.866025 │   0.5    │ 1.73205 │\n│ 1.0      │   0.0    │     Inf │\n└──────────┴──────────┴─────────┘","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"note: Note\nThe alignment keyword is supported in all back-ends.","category":"page"},{"location":"#PrettyTables.jl","page":"Home","title":"PrettyTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has the purpose to print data in matrices in a human-readable format. It was inspired in the functionality provided by ASCII Table Generator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"PrettyTables\")","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/usage.md\"\n    \"man/text_backend.md\"\n    \"man/html_backend.md\"\n    \"man/latex_backend.md\"\n    \"man/alignment.md\"\n    \"man/formatters.md\"\n    \"man/text_examples.md\"\n    \"man/html_examples.md\"\n    \"lib/library.md\"\n]\nDepth = 2","category":"page"},{"location":"man/latex_backend/#LaTeX-back-end","page":"LaTeX","title":"LaTeX back-end","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The following options are available when the LaTeX backend is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"body_hlines::Vector{Int}: A vector of Int indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 1 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in hlines, but   the indices here are related to the printed rows of the body. Thus, if 1   is added to body_hlines, then a horizontal line will be drawn after the   first data row. (Default = Int[])\nhighlighters::Union{LatexHighlighter, Tuple}: An instance of   LatexHighlighter or a tuple with a list of LaTeX highlighters (see the   section LaTeX highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the horizontal lines will be drawn. It can be nothing, :all, :none or   a vector of integers. (Default = nothing)\nIf it is nothing, which is the default, then the configuration will be   obtained from the table format in the variable tf (see   LatexTableFormat).\nIf it is :all, then all horizontal lines will be drawn.\nIf it is :none, then no horizontal line will be drawn.\nIf it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if 0 is in hlines, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header noheader.   Finally, for convenience, the top and bottom lines can be drawn by   adding the symbols :begin and :end to this vector, respectively, and   the line after the header can be drawn by adding the symbol :header.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"info: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"label::AbstractString: The label of the table. If empty, then no label will   be added. (Default = \"\")\nlongtable_footer::Union{Nothing, AbstractString}: The string that will be   drawn in the footer of the tables before a page break. This only works if   table_type is :longtable. If it is nothing, then no footer will be   used. (Default = nothing)\nrow_number_alignment::Symbol: Select the alignment of the row number column   (see the section Alignment). (Default = :r)\ntable_type::Union{Nothing, Symbol}: Select which LaTeX environment will be   used to print the table. Currently supported options are :tabular for   tabular or :longtable for longtable. If it is nothing then the   default option of the table format will be used. (Default = nothing)\ntf::LatexTableFormat: An instance of the structure   LatexTableFormat that defines the general format of the LaTeX table.\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where   the vertical lines will be drawn. It can be :all, :none or a vector of   integers. In the first case (the default behavior), all vertical lines will   be drawn. In the second case, no vertical line will be drawn. In the third   case, the vertical lines will be drawn only after the columns in the vector.   Notice that the left border will be drawn if 0 is in vlines.   Furthermore, it is important to mention that the column number in this   variable is related to the printed columns. Thus, it is affected by the   columns added using the variable show_row_number. Finally, for   convenience, the left and right border can be drawn by adding the symbols   :begin and :end to this vector, respectively.   (Default = :none)\nwrap_table::Union{Nothing, String}: This variable controls whether to wrap   the table in a environment defined by the variable wrap_table_environment.   Defaults to true. When false, the printed table begins with   \\\\begin{tabular}. This option does not work with :longtable. If it is   nothing then the default option of the table format will be used.   (Default = nothing)\nwrap_table_environment::Union{Nothing, String}: Environment that will be   used to wrap the table if the option wrap_table is true. If it is   nothing then the default option of the table format will be used.   (Default = nothing)","category":"page"},{"location":"man/latex_backend/#LaTeX-highlighters","page":"LaTeX","title":"LaTeX highlighters","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure LatexHighlighter. It contains the following two fields:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"f::Function: Function with the signature f(data, i, j) in which should   return true if the element (i, j) in data must be highlighted, or   false otherwise.\nfd::Functions: A function with the signature f(data, i, j, str)::String in   which data is the matrix, (i, j) is the element position in the table,   and str is the data converted to string. This function must return a   string that will be placed in the cell.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The function f has the following signature:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"f(data, i, j)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"in which data is a reference to the data that is being printed, i and j are the element coordinates that are being tested. If this function returns true, then the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"Notice that if multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the Tuple highlighters.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"If the function f returns true, then the function fd(data, i, j, str) will be called and must return the LaTeX string that will be placed in the cell.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"If only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"There are two helpers that can be used to create LaTeX highlighters:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"LatexHighlighter(f::Function, envs::Union{String,Vector{String}})\nLatexHighlighter(f::Function, fd::Function)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"Thus, for example:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"LatexHighlighter((data,i,j)->true, [\"textbf\", \"small\"])","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"will wrap all the cells in the table in the following environment:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"\\textbf{\\small{<Cell text>}}","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"info: Info\nIf only a single highlighter is wanted, then it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), then the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nIf the highlighters are used together with Formatters, then the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"julia> t = 0:1:20;\n\njulia> data = hcat(t, ones(length(t)) * 1, 1 * t, 0.5 .* t.^2);\n\njulia> header = ([\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n                 [ \"[s]\",  \"[m/s\\$^2\\$]\",    \"[m/s]\",      \"[m]\"]);\n\njulia> hl_v = LatexHighlighter((data, i, j) -> (j == 3) && data[i, 3] > 9, [\"color{blue}\",\"textbf\"]);\n\njulia> hl_p = LatexHighlighter((data, i, j) -> (j == 4) && data[i, 4] > 10, [\"color{red}\", \"textbf\"])\n\njulia> hl_e = LatexHighlighter((data, i, j) -> (i == 10), [\"cellcolor{black}\", \"color{white}\", \"textbf\"])\n\njulia> pretty_table(data, backend = Val(:latex), header = header, highlighters = (hl_e, hl_p, hl_v))","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: )","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nThe following LaTeX packages are required to render this example: colortbl and xcolor.","category":"page"},{"location":"man/latex_backend/#LaTeX-table-formats","page":"LaTeX","title":"LaTeX table formats","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The following table formats are available when using the LaTeX back-end:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"tf_latex_default (Default)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: )","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"tf_latex_double","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: )","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"tf_latex_modern","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: )","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nYou need the LaTeX package array to use the vertical divisions with this format.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"tf_latex_booktabs","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: )","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nYou need the LaTeX package booktabs to render this format.","category":"page"},{"location":"man/usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"CurrentModule = PrettyTables\nDocTestSetup = quote\n    using PrettyTables\nend","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The following function can be used to print data.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"function pretty_table([io::IO | String,] table;  kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Print to io the table table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"If io is omitted, then it defaults to stdout. If String is passed in the place of io, then a String with the printed table will be returned by the function. If HTML is passed in the place of io, then an HTML object is returned with the printed table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"When printing, it will be verified if table complies with Tables.jl API.  If it is is compliant, then this interface will be used to print the table. If it is not compliant, then only the following types are supported:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"AbstractVector: any vector can be printed.\nAbstractMatrix: any matrix can be printed.\nDict: any Dict can be printed. In this case, the special keyword  sortkeys can be used to select whether or not the user wants to print the  dictionary with the keys sorted. If it is false, then the elements will be  printed on the same order returned by the functions keys and values.  Notice that this assumes that the keys are sortable, if they are not, then  an error will be thrown.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The user can select which back-end will be used to print the tables using the keyword argument backend. Currently, the following back-ends are supported:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Text (backend = Val(:text)): prints the table in text mode. This is the  default selection if the keyword backend is absent.\nHTML (backend = Val(:html)): prints the table in HTML.\nLaTeX (backend = Val(:latex)): prints the table in LaTeX format.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Each back-end defines its own configuration keywords that can be passed using kwargs. However, the following keywords are valid for all back-ends:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the   columns (see the section Alignment).\nbackend::Union{Symbol, T_BACKENDS}: Select which back-end will be used to   print the table. Notice that the additional configuration in kwargs...   depends on the selected backend.\ncell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   A tuple of functions with the signature f(data, i, j) that overrides the   alignment of the cell (i, j) to the value returned by f. It can also be a   single function, when it is assumed that only one alignment function is   required, or nothing, when no cell alignment modification will be   performed. If the function f does not return a valid alignment symbol as   shown in section Alignment, then it will be discarded. For   convenience, it can also be a dictionary of type (i, j) => a that   overrides the alignment of the cell (i, j) to a. a must be a symbol   like specified in the section Alignment. (Default = nothing)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nIf more than one alignment function is passed to cell_alignment, then the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"cell_first_line_only::Bool: If true, then only the first line of each cell   will be printed. (Default = false)\ncompact_printing::Bool: Select if the option :compact will be used when   printing the data. (Default = true)\nformatters::Union{Nothing, Function, Tuple}: See the section   Formatters.\nheader::Union{Symbol, Vector{Symbol}}: The header must be a tuple of   vectors. Each one must have the number of elements equal to the number of   columns in the table. The first vector is considered the header and the   others are the subheaders. If it is nothing, then a default value based on   the type will be used. If a single vector is passed, then it will be   considered the header. (Default = nothing)\nheader_alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the   header columns (see the section Alignment). If the symbol that   specifies the alignment is :s for a specific column, then the same   alignment in the keyword alignment for that column will be used.   (Default = :s)\nheader_cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   This keyword has the same structure of cell_alignment but in this case it   operates in the header. Thus, (i, j) will be a cell in the header matrix   that contains the header and sub-headers. This means that the data field   in the functions will be the same value passed in the keyword header.   (Default = nothing)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nIf more than one alignment function is passed to header_cell_alignment,   then the functions will be evaluated in the same order of the tuple. The   first one that returns a valid alignment symbol for each cell is applied,   and the rest is discarded.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"limit_printing::Bool: If true, then the cells will be converted using the   property :limit => true of IOContext. (Default = true)\nmax_num_of_columns::Int: The maximum number of table columns that will be   rendered. If it is lower than 0, then all columns will be rendered.   (Default = -1)\nmax_num_of_rows::Int: The maximum number of table rows that will be   rendered. If it is lower than 0, then all rows will be rendered.   (Default = -1)\nrenderer::Symbol: A symbol that indicates which function should be used to   convert an object to a string. It can be :print to use the function   print or :show to use the function show. Notice that this selection is   applicable only to the table data. Headers, sub-headers, and row name column   are always rendered with print. (Default = :print)\nrow_labels::Union{Nothing, AbstractVector}: A vector containing the row   labels that will be appended to the left of the table. If it is nothing,   then the column with the row labels will not be shown. Notice that the size   of this vector must match the number of rows in the table.   (Default = nothing)\nrow_label_alignment::Symbol: Alignment of the column with the rows label   (see the section Alignment).\nrow_label_column_title::AbstractString: Title of the column with the row   labels. (Default = \"\")\nrow_number_column_title::AbstractString: Title of the column with the row   numbers. (Default = \"Row\")\nshow_header::Bool: If true, then the header will be printed. Notice that   all keywords and parameters related to the header and sub-headers will be   ignored. (Default = false)\nshow_row_number::Bool: If true, then a new column will be printed showing   the row number. (Default = false)\nshow_subheader::Bool: If true, then the sub-header will be printed, i.e.   the header will contain only one line. Notice that this option has no effect   if show_header = false. (Default = false)\ntitle::AbstractString: The title of the table. If it is empty, then no title   will be printed. (Default = \"\")\ntitle_alignment::Symbol: Alignment of the title, which must be a symbol as   explained in the section Alignment. This argument is ignored in the   LaTeX backend. (Default = :l)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nNotice that all back-ends have the keyword tf to specify the table printing format. Thus, if the keyword backend is not present or if it is nothing, then the back-end will be automatically inferred from the type of the keyword tf. In this case, if tf is also not present, then it just fall-back to the text back-end unless HTML is passed as the first argument. In this case, the default back-end is set to HTML.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"If String is used, then the keyword color selects whether or not the table will be converted to string with or without colors. The default value is false. Notice that this option only has effect in text backend.","category":"page"},{"location":"man/usage/#Examples","page":"Usage","title":"Examples","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"In the following, it is possible to see some examples for a quick start using the text back-end.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"julia> data = [1 2 3; 4 5 6];\n\njulia> pretty_table(data; header = [\"Column 1\", \"Column 2\", \"Column 3\"])\n┌──────────┬──────────┬──────────┐\n│ Column 1 │ Column 2 │ Column 3 │\n├──────────┼──────────┼──────────┤\n│        1 │        2 │        3 │\n│        4 │        5 │        6 │\n└──────────┴──────────┴──────────┘\n\njulia> pretty_table(data;\n                    header = ([\"Column 1\", \"Column 2\", \"Column 3\"],\n                              [\"A\", \"B\", \"C\"]))\n┌──────────┬──────────┬──────────┐\n│ Column 1 │ Column 2 │ Column 3 │\n│        A │        B │        C │\n├──────────┼──────────┼──────────┤\n│        1 │        2 │        3 │\n│        4 │        5 │        6 │\n└──────────┴──────────┴──────────┘\n\njulia> str = pretty_table(String, data;\n                          header = [\"Column 1\", \"Column 2\", \"Column 3\"]);\n\njulia> print(str)\n┌──────────┬──────────┬──────────┐\n│ Column 1 │ Column 2 │ Column 3 │\n├──────────┼──────────┼──────────┤\n│        1 │        2 │        3 │\n│        4 │        5 │        6 │\n└──────────┴──────────┴──────────┘","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"julia> dict = Dict(1 => \"Jan\", 2 => \"Feb\", 3 => \"Mar\", 4 => \"Apr\", 5 => \"May\", 6 => \"Jun\");\n\njulia> pretty_table(dict)\n┌───────┬────────┐\n│  Keys │ Values │\n│ Int64 │ String │\n├───────┼────────┤\n│     4 │    Apr │\n│     2 │    Feb │\n│     3 │    Mar │\n│     5 │    May │\n│     6 │    Jun │\n│     1 │    Jan │\n└───────┴────────┘\n\njulia> pretty_table(dict, sortkeys = true)\n┌───────┬────────┐\n│  Keys │ Values │\n│ Int64 │ String │\n├───────┼────────┤\n│     1 │    Jan │\n│     2 │    Feb │\n│     3 │    Mar │\n│     4 │    Apr │\n│     5 │    May │\n│     6 │    Jun │\n└───────┴────────┘","category":"page"},{"location":"man/usage/#Configuration","page":"Usage","title":"Configuration","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The following function can be used to print a table changing the default configurations of PrettyTables.jl:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It calls pretty_table using the default configuration in conf. The args... and kwargs... can be the same as those passed to pretty_tables. Notice that all the configurations in kwargs... will overwrite the ones in conf.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The object conf can be created by the function set_pt_conf in which the keyword parameters can be any one supported by the function pretty_table as shown in the following.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"julia> conf = set_pt_conf(tf = tf_markdown, alignment = :c);\n\njulia> data = [1 2 3; 4 5 6];\n\njulia> header = [\"Column 1\", \"Column 2\", \"Column 3\"];\n\njulia> pretty_table_with_conf(conf, data; header = header)\n| Column 1 | Column 2 | Column 3 |\n|----------|----------|----------|\n|    1     |    2     |    3     |\n|    4     |    5     |    6     |","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"A configuration object can be modified by the function set_pt_conf! and cleared by the function clear_pt_conf!.","category":"page"},{"location":"man/usage/#Helpers","page":"Usage","title":"Helpers","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The macro @pt was created to make it easier to pretty print tables to stdout. Its signature is:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"macro pt(expr...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"where the expression list expr contains the tables that should be printed like:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"@pt table1 table2 table3","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The user can select the table header by passing the expression:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":":header = [<Vector with the header>]","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Notice that the header is valid only for the next printed table. Hence:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"    @pt :header = header1 table1 :header = header2 table2 table3","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"will print table1 using header1, table2 using header2, and table3 using the default header.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The global configurations used to print tables with the macro @pt can be selected by:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"macro ptconf(expr...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"where expr format must be:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"keyword1 = value1 keyword2 = value2 ...","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The keywords can be any possible keyword that can be used in the function pretty_table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"All the configurations can be reseted by calling @ptconfclean.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"warning: Warning\nIf a keyword is not supported by the function pretty_table, then no error message is printed when calling @ptconf. However, an error will be thrown when @pt is called.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"info: Info\nWhen more than one table is passed to the macro @pt, then multiple calls to pretty_table will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"julia> data = [1 2 3; 4 5 6];\n\njulia> @pt data\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│      1 │      2 │      3 │\n│      4 │      5 │      6 │\n└────────┴────────┴────────┘\n\njulia> @pt :header = [\"Column 1\", \"Column 2\", \"Column 3\"] data :header = ([\"Column 1\", \"Column 2\", \"Column 3\"], [\"A\", \"B\", \"C\"]) data\n┌──────────┬──────────┬──────────┐\n│ Column 1 │ Column 2 │ Column 3 │\n├──────────┼──────────┼──────────┤\n│        1 │        2 │        3 │\n│        4 │        5 │        6 │\n└──────────┴──────────┴──────────┘\n┌──────────┬──────────┬──────────┐\n│ Column 1 │ Column 2 │ Column 3 │\n│        A │        B │        C │\n├──────────┼──────────┼──────────┤\n│        1 │        2 │        3 │\n│        4 │        5 │        6 │\n└──────────┴──────────┴──────────┘\n\njulia> @ptconf tf = tf_ascii_dots alignment = :c\n\njulia> @pt data\n............................\n: Col. 1 : Col. 2 : Col. 3 :\n:........:........:........:\n:   1    :   2    :   3    :\n:   4    :   5    :   6    :\n:........:........:........:\n\njulia> @ptconfclean\n\njulia> @pt data\n┌────────┬────────┬────────┐\n│ Col. 1 │ Col. 2 │ Col. 3 │\n├────────┼────────┼────────┤\n│      1 │      2 │      3 │\n│      4 │      5 │      6 │\n└────────┴────────┴────────┘","category":"page"}]
}
