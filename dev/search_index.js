var documenterSearchIndex = {"docs":
[{"location":"man/markdown_backend/#Markdown-Back-End","page":"Markdown","title":"Markdown Back End","text":"","category":"section"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"using PrettyTables","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"The following options are available when the markdown back end is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"allow_markdown_in_cells::Bool: By default, special markdown characters like *, _,   ~, etc. are escaped in markdown back end to generate valid output. However, this   algorithm blocks the usage of markdown code inside of the cells. If this keyword is   true, the escape algorithm will not be applied, allowing markdown code inside all   the cells. In this case, the user must ensure that the output code is valid.   (Default = false)\nhighlighters::Union{MarkdownHighlighter, Tuple}: An instance of MarkdownHighlighter or   a tuple with a list of Markdown highlighters (see the section   Markdown Highlighters).\nshow_omitted_cell_summary::Bool: If true, a summary will be printed after the table   with the number of columns and rows that were omitted.   (Default = false)","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"The following keywords are available to customize the output decoration:","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"header_decoration::MarkdownDecoration: Decoration applied to the header.   (Default = MarkdownDecoration(bold = true))\nrow_label_decoration::MarkdownDecoration: Decoration applied to the row label column.   (Default = MarkdownDecoration())\nrow_number_decoration::MarkdownDecoration: Decoration applied to the row number column.   (Default = MarkdownDecoration(bold = true))\nsubheader_decoration::MarkdownDecoration: Decoration applied to the sub-header.   (Default = MarkdownDecoration(code = true))","category":"page"},{"location":"man/markdown_backend/#Markdown-Highlighters","page":"Markdown","title":"Markdown Highlighters","text":"","category":"section"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure MarkdownHighlighter. It contains the following two public fields:","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"f::Function: Function with the signature f(data, i, j) in which should return true   if the element (i,j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the MarkdownDecoration to be applied to   the cell that must be highlighted.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"The function f has the following signature:","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"f(data, i, j)","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"in which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"If the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type MarkdownDecoration that contains the decoration to be applied to the cell.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"A markdown highlighter can be constructed using two helpers:","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"MarkdownHighlighter(f::Function, decoration::MarkdownDecoration)\n\nMarkdownHighlighter(f::Function, fd::Function)","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"The first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"info: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighters without being inside a Tuple.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"note: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"There are a set of pre-defined highlighters (with names hl_*) to make the usage simpler. They are defined in the file ./src/backends/markdown/predefined_highlighters.jl.","category":"page"},{"location":"man/markdown_backend/","page":"Markdown","title":"Markdown","text":"t = 0:1:20\n\ndata = hcat(t, ones(length(t)) * 1, 1 * t, 0.5 .* t.^2)\n\nheader = (\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ \"[s]\",       \"[m/sÂ²]\",    \"[m/s]\",      \"[m]\"]\n)\n\nhl_v = MarkdownHighlighter(\n    (data, i, j) -> (j == 3) && data[i, 3] > 9,\n    MarkdownDecoration(bold = true)\n)\n\nhl_p = MarkdownHighlighter(\n    (data, i, j) -> (j == 4) && data[i, 4] > 10,\n    MarkdownDecoration(italic = true)\n)\n\npretty_table(\n    data;\n    alignment = [:c, :r, :c, :l],\n    backend = Val(:markdown),\n    header = header,\n    highlighters = (hl_p, hl_v)\n)","category":"page"},{"location":"man/latex_backend/#LaTeX-Back-End","page":"LaTeX","title":"LaTeX Back End","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"using PrettyTables\nusing LaTeXStrings\nusing Latexify","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The following options are available when the LaTeX back end is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"body_hlines::Vector{Int}: A vector of Int indicating row numbers in which an   additional horizontal line should be drawn after the row. Notice that numbers lower than   1 and equal or higher than the number of printed rows will be neglected. This vector   will be appended to the one in hlines, but the indices here are related to the printed   rows of the body. Thus, if 1 is added to body_hlines, a horizontal line will be   drawn after the first data row.   (Default = Int[])\nhighlighters::Union{LatexHighlighter, Tuple}: An instance of LatexHighlighter or a   tuple with a list of LaTeX highlighters (see the section LaTeX Highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   horizontal lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see LatexTableFormat).\nIf it is :all, all horizontal lines will be drawn.\nIf it is :none, no horizontal line will be drawn.\nIf it is a vector of integers, the horizontal lines will be drawn only after the rows   in the vector. Notice that the top line will be drawn if 0 is in hlines, and the   header and sub-headers are considered as only 1 row. Furthermore, it is important to   mention that the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header noheader.  Finally, for   convenience, the top and bottom lines can be drawn by adding the symbols :begin   and :end to this vector, respectively, and the line after the header can be drawn   by adding the symbol :header.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"info: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"label::AbstractString: The label of the table. If empty, no label will be added.   (Default = \"\")\nlongtable_footer::Union{Nothing, AbstractString}: The string that will be drawn in the   footer of the tables before a page break. This only works if table_type is   :longtable. If it is nothing, no footer will be used.   (Default = nothing)\nrow_number_alignment::Symbol: Select the alignment of the row number column (see the   section Alignment).   (Default = :r)\ntable_type::Union{Nothing, Symbol}: Select which LaTeX environment will be used to print   the table. Currently supported options are :tabular for tabular or :longtable for   longtable. If it is nothing, the default option of the table format will be used.   (Default = nothing)\ntf::LatexTableFormat: An instance of the structure LatexTableFormat that   defines the general format of the LaTeX table.\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   vertical lines will be drawn. It can be :all, :none or a vector of integers. In the   first case (the default behavior), all vertical lines will be drawn. In the second case,   no vertical line will be drawn. In the third case, the vertical lines will be drawn only   after the columns in the vector.  Notice that the left border will be drawn if 0 is in   vlines.  Furthermore, it is important to mention that the column number in this   variable is related to the printed columns. Thus, it is affected by the columns   added using the variable show_row_number. Finally, for convenience, the left and right   border can be drawn by adding the symbols :begin and :end to this vector,   respectively.   (Default = :none)\nwrap_table::Union{Nothing, String}: This variable controls whether to wrap the table in   a environment defined by the variable wrap_table_environment.  Defaults to true.   When false, the printed table begins with \\\\begin{tabular}. This option does not   work with :longtable. If it is nothing, the default option of the table format will   be used.   (Default = nothing)\nwrap_table_environment::Union{Nothing, String}: Environment that will be used to wrap   the table if the option wrap_table is true. If it is nothing, the default option   of the table format will be used.   (Default = nothing)","category":"page"},{"location":"man/latex_backend/#LaTeX-Highlighters","page":"LaTeX","title":"LaTeX Highlighters","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword. Each highlighter is an instance of the structure LatexHighlighter. It contains the following two fields:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"f::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Functions: A function with the signature f(data, i, j, str)::String in which   data is the matrix, (i, j) is the element position in the table, and str is the   data converted to string. This function must return a string that will be placed in the   cell.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The function f has the following signature:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"f(data, i, j)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"in which data is a reference to the data that is being printed, i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element.  Otherwise, the default style will be used.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"Notice that if multiple highlighters are valid for the element (i, j),  the applied style will be equal to the first match considering the order in the Tuple highlighters.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"If the function f returns true, the function fd(data, i, j, str) will be called and must return the LaTeX string that will be placed in the cell.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"If only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"There are two helpers that can be used to create LaTeX highlighters:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"LatexHighlighter(f::Function, envs::Union{String,Vector{String}})\nLatexHighlighter(f::Function, fd::Function)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"Thus, for example:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"LatexHighlighter((data,i,j)->true, [\"textbf\", \"small\"])","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"will wrap all the cells in the table in the following environment:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"\\textbf{\\small{<Cell text>}}","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"info: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"t = 0:1:20\n\ndata = hcat(t, ones(length(t)) * 1, 1 * t, 0.5 .* t.^2)\n\nheader = (\n    [\"Time\", \"Acceleration\",         \"Velocity\", \"Distance\"],\n    [ \"[s]\",  latex_cell\"[m/s$^2$]\", \"[m/s]\",    \"[m]\"]\n)\n\nhl_v = LatexHighlighter((data, i, j) -> (j == 3) && data[i, 3] > 9, [\"color{blue}\",\"textbf\"]);\n\nhl_p = LatexHighlighter((data, i, j) -> (j == 4) && data[i, 4] > 10, [\"color{red}\", \"textbf\"])\n\nhl_e = LatexHighlighter((data, i, j) -> (i == 10), [\"cellcolor{black}\", \"color{white}\", \"textbf\"])\n\npretty_table(data; backend = Val(:latex), header = header, highlighters = (hl_e, hl_p, hl_v))","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"str = pretty_table(\n    String,\n    data;\n    backend = Val(:latex),\n    header = header,\n    highlighters = (hl_e, hl_p, hl_v)\n)\n\nrender(\n    LaTeXString(str),\n    MIME(\"image/png\");\n    name = \"latex_highlighter\",\n    packages = (\"colortbl\", \"xcolor\"),\n    open = false\n)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: LaTeX highlighter example)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nThe following LaTeX packages are required to render this example: colortbl and xcolor.","category":"page"},{"location":"man/latex_backend/#PrettyTables-and-Latexify-(LaTeXStrings)","page":"LaTeX","title":"PrettyTables and Latexify (LaTeXStrings)","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"To work with LaTeXStrings, you must wrap them in LatexCells. Otherwise, special LaTeX characters are converted or escaped.","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"using PrettyTables, Latexify\n\nc1 = LatexCell.([latexify(\"Î±\"), latexify(\"Î²\")]);\n\nc2 = [0.0, 1.0];\n\npretty_table([c1 c2], backend = Val(:latex))","category":"page"},{"location":"man/latex_backend/#LaTeX-Table-Formats","page":"LaTeX","title":"LaTeX Table Formats","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"The following table formats are available when using the LaTeX back end:","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"header = [\n  \"Header 1\" \"Header 2\" \"Header 3\" \"Header 4\"\n  \"Sub 1\"    \"Sub 2\"    \"Sub 3\"    \"Sub 4\"\n]\n\ndata = [\n    true  100.0 0x8080 \"String\"\n    false 200.0 0x0808 \"String\"\n    true  300.0 0x1986 \"String\"\n    false 400.0 0x1987 \"String\"\n]\n\nfor prefix in (\n    \"default\",\n    \"double\",\n    \"modern\",\n    \"booktabs\",\n)\n    local str\n\n    filename = \"latex_format_$prefix\"\n    tf       = Symbol(\"tf_latex_\" * prefix)\n\n    str = pretty_table(\n        String,\n        data;\n        backend = Val(:latex),\n        tf = @eval($tf),\n    )\n\n    render(\n      LaTeXString(str),\n      MIME(\"image/png\");\n      name = filename,\n      packages = (\"array\", \"booktabs\"),\n      open = false\n    )\nend","category":"page"},{"location":"man/latex_backend/#tf_latex_default-(**Default**)","page":"LaTeX","title":"tf_latex_default (Default)","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: `tf_latex_default`)","category":"page"},{"location":"man/latex_backend/#tf_latex_double","page":"LaTeX","title":"tf_latex_double","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: `tf_latex_double`)","category":"page"},{"location":"man/latex_backend/#tf_latex_modern","page":"LaTeX","title":"tf_latex_modern","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: `tf_latex_modern`)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nYou need the LaTeX package array to use the vertical divisions with this format.","category":"page"},{"location":"man/latex_backend/#tf_latex_booktabs","page":"LaTeX","title":"tf_latex_booktabs","text":"","category":"section"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"(Image: `tf_latex_booktabs`)","category":"page"},{"location":"man/latex_backend/","page":"LaTeX","title":"LaTeX","text":"note: Note\nYou need the LaTeX package booktabs to render this format.","category":"page"},{"location":"man/text_backend/#Text-Back-end","page":"Text","title":"Text Back end","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"using PrettyTables","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following options are available when the text back end is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"alignment_anchor_fallback::Symbol: This keyword controls the line alignment when using   the regex alignment anchors if a match is not found. If it is :l, the left of the line   will be aligned with the anchor. If it is :c, the line center will be aligned with the   anchor. Otherwise, the end of the line will be aligned with the anchor.   (Default = :l)\nalignment_anchor_fallback_override::Dict{Int, Symbol}: A Dict{Int, Symbol} to override   the behavior of fallback_alignment_anchor for a specific column. Example: Dict(3 =>   :c) changes the fallback alignment anchor behavior for :c only for the column 3.\nalignment_anchor_regex::Dict{Int, AbstractVector{Regex}}: A dictionary Dict{Int,   AbstractVector{Regex}} with a set of regexes that is used to align the values in the   columns (keys). The characters at the first regex match (or anchor) of each line in   every cell of the column will be aligned.  The regex match is searched in the same order   as the regexes appear on the vector. The regex matching is applied after the cell   conversion to string, which includes the formatters. If no match is found for a specific   line, the alignment of this line depends on the options alignment_anchor_fallback and   alignment_anchor_fallback_override. If the key 0 is present, the related regexes   will be used to align all the columns. In this case, all the other keys will be   neglected. Example: Dict(2 => [r\"\\.\"]) aligns the decimal point of the cells in the   second column.   (Default = Dict{Int, Vector{Regex}}())\nautowrap::Bool: If true, the text will be wrapped on spaces to fit the column. Notice   that this function requires linebreaks = true and the column must have a fixed size   (see columns_width).\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which an   additional horizontal line should be drawn after the row. Notice that numbers lower than   0 and equal or higher than the number of printed rows will be neglected. This vector   will be appended to the one in hlines, but the indices here are related to the printed   rows of the body. Thus, if 1 is added to body_hlines, a horizontal line will be   drawn after the first data row.   (Default = Int[])\nbody_hlines_format::Union{Nothing, NTuple{4, Char}}: A tuple of 4 characters specifying   the format of the horizontal lines that will be drawn by body_hlines. The characters   must be the left intersection, the middle intersection, the right intersection, and the   row. If it is nothing,  it will use the same format specified in tf.   (Default = nothing)\ncolumns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the width   of each column. If the width is equal or lower than 0, it will be automatically computed   to fit the large cell in the column. If it is a single integer, this number will be used   as the size of all columns.   (Default = 0)\ncrop::Symbol: Select the printing behavior when the data is bigger than the available   display size (see display_size). It can be :both to crop on vertical and horizontal   direction, :horizontal to crop only on horizontal direction, :vertical to crop only   on vertical direction, or :none to do not crop the data at all. If the io has   :limit => true, crop is set to :both by default. Otherwise, it is set to :none   by default.\ncrop_subheader::Bool: If true, the sub-header size will not be taken into account when   computing the column size. Hence, the print algorithm can crop it to save space. This   has no effect if the user selects a fixed column width.   (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of the cells in   the continuation row. This row is printed if the table is vertically cropped.   (Default = :c)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the display size   (num. of rows, num. of columns) that is available to print the table. It is used to crop   the data depending on the value of the keyword crop. Notice that if a dimension is not   positive, it will be treated as unlimited.   (Default = displaysize(io))\nellipsis_line_skip::Integer: An integer defining how many lines will be skipped from   showing the ellipsis that indicates the text was cropped.   (Default = 0)\nequal_columns_width::Bool: If true, all the columns will have the same width.   (Default = false)\nhighlighters::Union{Highlighter, Tuple}: An instance of Highlighter or a tuple with a   list of text highlighters (see the section Text Highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   horizontal lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see TextFormat).\nIf it is :all, all horizontal lines will be drawn.\nIf it is :none, no horizontal line will be drawn.\nIf it is a vector of integers, the horizontal lines will be drawn only after the rows   in the vector. Notice that the top line will be drawn if 0 is in hlines, and the   header and subheaders are considered as only 1 row. Furthermore, it is important to   mention that the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.  Finally,   for convenience, the top and bottom lines can be drawn by adding the symbols   :begin and :end to this vector, respectively, and the line after the header can   be drawn by adding the symbol :header.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"linebreaks::Bool: If true, \\\\n will break the line inside the cells.   (Default = false)\nmaximum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the   maximum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the maximum width of all columns.   Notice that the parameter columns_width has precedence over this one.   (Default = 0)\nminimum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the   minimum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the minimum width of all columns.   Notice that the parameter columns_width has precedence over this one.   (Default = 0)\nnewline_at_end::Bool: If false, the table will not end with a newline character.   (Default = true)\noverwrite::Bool: If true, the same number of lines in the printed table will be   deleted from the output io. This can be used to update the table in the display   continuously.   (Default = false)\nreserved_display_lines::Int: Number of lines to be left at the beginning of the printing   when vertically cropping the output. Notice that the lines required to show the title   are automatically computed.   (Default = 0)\nrow_number_alignment::Symbol: Select the alignment of the row number column (see the   section Alignment).   (Default = :r)\nshow_omitted_cell_summary::Bool: If true, a summary will be printed after the table   with the number of columns and rows that were omitted.   (Default = true)\ntf::TextFormat: Table format used to print the table (see TextFormat).   (Default = tf_unicode)\ntitle_autowrap::Bool: If true, the title text will be wrapped considering the title   size. Otherwise, lines larger than the title size will be cropped.   (Default = false)\ntitle_same_width_as_table::Bool: If true, the title width will match that of the   table. Otherwise, the title size will be equal to the display width.   (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it is   :bottom, the data, if required, will be cropped in the bottom. On the other hand, if   it is :middle, the data will be cropped in the middle if necessary.   (Default = :bottom)\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   vertical lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see TextFormat).\nIf it is :all, all vertical lines will be drawn.\nIf it is :none, no vertical line will be drawn.\nIf it is a vector of integers, the vertical lines will be drawn only after the columns   in the vector. Notice that the top line will be drawn if 0 is in vlines.   Furthermore, it is important to mention that the column number in this variable is   related to the printed column.  Thus, it is affected by the options row_labels   and show_row_number.  Finally, for convenience, the left and right vertical lines   can be drawn by adding the symbols :begin and :end to this vector, respectively,   and the line after the header can be drawn by adding the symbol :header.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following keywords related to crayons are available to customize the output decoration:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"border_crayon::Crayon: Crayon to print the border.\nheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print the header.\nomitted_cell_summary_crayon::Crayon: Crayon used to print the omitted cell summary.\nrow_label_crayon::Crayon: Crayon to print the row labels.\nrow_label_header_crayon::Crayon: Crayon to print the header of the column with the row   labels.\nrow_number_header_crayon::Crayon: Crayon for the header of the column with the row   numbers.\nsubheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print sub-headers.\ntext_crayon::Crayon: Crayon to print default text.\ntitle_crayon::Crayon: Crayon to print the title.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The keywords header_crayon and subheader_crayon can be a Crayon or a Vector{Crayon}. In the first case, the Crayon will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf the renderer show is used, all strings will be printed with surrounding quotes. However, if a formatter modifies a value and return a string, those surrounding quotes will be removed if the original value is not a string.","category":"page"},{"location":"man/text_backend/#Crayons","page":"Text","title":"Crayons","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A Crayon is an object that handles a style for text printed on terminals. It is defined in the package Crayons.jl. There are many options available to customize the style, such as foreground color, background color, bold text, etc.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A Crayon can be created in two different ways:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> Crayon(foreground = :blue, background = :black, bold = :true)\n\njulia> crayon\"blue bg:black bold\"","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"For more information, see the Crayon.jl documentation.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe Crayon.jl package is re-exported by PrettyTables.jl. Hence, you do not need using Crayons to create a Crayon.","category":"page"},{"location":"man/text_backend/#Cropping","page":"Text","title":"Cropping","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The keyword crop can be used to define how the output will be cropped if the display has limits. The default behavior depends on the property :limit of the io. If io has :limit => true, the default value of crop is :both.  Otherwise, if :limit => false or it is not defined at all, crop defaults to :none.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If pretty_table is called without io, stdout is wrapped in a IOContext with :limit => true.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The display size can be configured by the keyword display_size, which is a tuple of two Int with the number of rows and columns, respectively. If this keyword is not specified, it is automatically obtained using the function displaysize(io).","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n];\n\npretty_table(data, display_size = (11, 30))\n\npretty_table(data, display_size = (11, 30), crop = :none)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIn vertical cropping, the header and the first table row is always printed.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nThe highlighters will work even in partially printed data.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If the user selects a fixed size for the columns (using the keyword columns_width), enables line breaks (using the keyword linebreaks), and sets autowrap = true, the algorithm wraps the text on spaces to automatically fit the space.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = [\"One very very very big long long line\"; \"Another very very very big big long long line\"]\n\npretty_table(\n    data;\n    autowrap = true,\n    columns_width = 10,\n    linebreaks = true,\n    show_row_number = true\n)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"It is also possible to change the vertical cropping behavior to crop the table in the middle instead of the bottom. This can be accomplished by passing the option vcrop_mode = :middle to pretty_table:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = Any[\n    1    false      1.0     0x01\n    2     true      2.0     0x02\n    3    false      3.0     0x03\n    4     true      4.0     0x04\n    5    false      5.0     0x05\n    6     true      6.0     0x06\n]\n\npretty_table(data, display_size = (11, 30), vcrop_mode = :middle)","category":"page"},{"location":"man/text_backend/#Text-Highlighters","page":"Text","title":"Text Highlighters","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure Highlighter that contains three fields:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"f::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is the   highlighter. This function must return the Crayon to be applied to the cell that must   be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd   is used.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The function f has the following signature:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"f(data, i, j)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"in which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the cell (i, j) will be highlighted.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"If the function f returns true, the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A highlighter can be constructed using three helpers:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function; kwargs...)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function, crayon::Crayon)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will apply the crayon to the highlighted cell, and","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Highlighter(f::Function, fd::Function)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"where it will apply the Crayon returned by the function fd to the highlighted cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\njulia> h1 = Highlighter(f      = (data, i, j) -> (data[i, j] < 0.5),\n                        crayon = crayon\"red bold\" )\n\njulia> h2 = Highlighter((data,i,j) -> (data[i, j] > 0.5),\n                        bold       = true,\n                        foreground = :blue )\n\njulia> h3 = Highlighter(f      = (data, i, j) -> (data[i, j] == 0.5),\n                        crayon = Crayon(bold = true, foreground = :yellow) )\n\njulia> pretty_table(data, highlighters = (h1, h2, h3), compact_printing = false)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\njulia> hl_odd = Highlighter(f      = (data, i, j) -> i % 2 == 0,\n                            crayon = Crayon(background = :light_blue))\n\njulia> pretty_table(data, highlighters = hl_odd, formatters = ft_printf(\"%10.5f\"))","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"There are a set of pre-defined highlighters (with names hl_*) to make the usage simpler. They are defined in the file ./src/backends/text/predefined_highlighters.jl.","category":"page"},{"location":"man/text_backend/#Text-Table-Formats","page":"Text","title":"Text Table Formats","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following table formats are available when using the text back end:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_unicode (Default)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"ââââââââââ¬âââââââââ¬âââââââââ¬âââââââââ\nâ Col. 1 â Col. 2 â Col. 3 â Col. 4 â\nââââââââââ¼âââââââââ¼âââââââââ¼âââââââââ¤\nâ      1 â  false â    1.0 â      1 â\nâ      2 â   true â    2.0 â      2 â\nâ      3 â  false â    3.0 â      3 â\nââââââââââ´âââââââââ´âââââââââ´âââââââââ","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_ascii_dots","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":".....................................\n: Col. 1 : Col. 2 : Col. 3 : Col. 4 :\n:........:........:........:........:\n:      1 :  false :    1.0 :      1 :\n:      2 :   true :    2.0 :      2 :\n:      3 :  false :    3.0 :      3 :\n:........:........:........:........:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_ascii_rounded","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":".--------.--------.--------.--------.\n| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n:--------+--------+--------+--------:\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |\n'--------'--------'--------'--------'","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_borderless","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"  Col. 1   Col. 2   Col. 3   Col. 4\n\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_compact","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":" -------- -------- -------- --------\n  Col. 1   Col. 2   Col. 3   Col. 4\n -------- -------- -------- --------\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3\n -------- -------- -------- --------","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_markdown","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n|--------|--------|--------|--------|\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_matrix","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"â                     â\nâ 1   false   1.0   1 â\nâ 2    true   2.0   2 â\nâ 3   false   3.0   3 â\nâ                     â","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nIn this case, the table format matrix was printed with the option show_header = false.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_mysql","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"+--------+--------+--------+--------+\n| Col. 1 | Col. 2 | Col. 3 | Col. 4 |\n+--------+--------+--------+--------+\n|      1 |  false |    1.0 |      1 |\n|      2 |   true |    2.0 |      2 |\n|      3 |  false |    3.0 |      3 |\n+--------+--------+--------+--------+","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_simple","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"========= ======== ======== =========\n  Col. 1   Col. 2   Col. 3   Col. 4\n========= ======== ======== =========\n       1    false      1.0        1\n       2     true      2.0        2\n       3    false      3.0        3\n========= ======== ======== =========","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"tf_unicode_rounded","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"â­âââââââââ¬âââââââââ¬âââââââââ¬âââââââââ®\nâ Col. 1 â Col. 2 â Col. 3 â Col. 4 â\nââââââââââ¼âââââââââ¼âââââââââ¼âââââââââ¤\nâ      1 â  false â    1.0 â      1 â\nâ      2 â   true â    2.0 â      2 â\nâ      3 â  false â    3.0 â      3 â\nâ°âââââââââ´âââââââââ´âââââââââ´âââââââââ¯","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"note: Note\nThe format unicode_rounded should look awful on your browser, but it should be printed fine on your terminal.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\npretty_table(data, tf = tf_ascii_dots)\n\npretty_table(data, tf = tf_compact)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"It is also possible to define you own custom table by creating a new instance of the structure TextFormat. For example, let's say that you want a table like simple that does not print the bottom line:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\ntf = TextFormat(\n    up_right_corner     = '=',\n    up_left_corner      = '=',\n    bottom_left_corner  = '=',\n    bottom_right_corner = '=',\n    up_intersection     = ' ',\n    left_intersection   = '=',\n    right_intersection  = '=',\n    middle_intersection = ' ',\n    bottom_intersection = ' ',\n    column              = ' ',\n    row                 = '=',\n    hlines              = [:begin, :header]\n)\n\npretty_table(data, tf = tf)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"or that does not print the header line:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]\n\ntf = TextFormat(\n    up_right_corner     = '=',\n    up_left_corner      = '=',\n    bottom_left_corner  = '=',\n    bottom_right_corner = '=',\n    up_intersection     = ' ',\n    left_intersection   = '=',\n    right_intersection  = '=',\n    middle_intersection = ' ',\n    bottom_intersection = ' ',\n    column              = ' ',\n    row                 = '=',\n    hlines              = [:begin, :end]\n)\n\npretty_table(data, tf = tf)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"For more information, see the documentation of the structure TextFormat.","category":"page"},{"location":"man/text_backend/#Custom-Text-Cells","page":"Text","title":"Custom Text Cells","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"PrettyTables.jl escapes all ANSI sequences by default so that every character in the cell is printable. This behavior let us to easily compute the cell size, which is essential to many features like alignment and cropping.  However, there are specific cases in which the user wants to render a cell with escape sequences that does not produce printable characters. In this case, the user must create a custom text cell.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A custom text cell is an object of a type derived from CustomTextCell.  Let's suppose that we want to create a custom cell called MyTextCell. This object must comply with the API by defining the following functions:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"append_suffix_to_line!(c::MyTextCell, l::Int, suffix::String)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Append the suffix to the line l of the custom cell text c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"apply_line_padding!(c::MyTextCell, l::Int, left_pad::Int, right_pad::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Apply to the line l of the custom text cell c the padding with left_pad spaces in the left and right_pad spaces in the right.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"crop_line!(c::MyTextCell, l::Int, num::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Crop num characters from the line l of the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"get_printable_cell_line(c::MyTextCell, l::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Return the printable line l of the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"get_rendered_line(c::MyTextCell, l::Int)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Return the rendered line l of the custom text cell l.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"parse_cell_text(c::CustomTextCell; kwargs...)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Parse the cell text and return a vector of String with the printable cell text, where each element in the vector is a new line.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The returned data must contain only the printable characters.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"The following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of pretty_table, and the user must choose whether or not support them.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"autowrap::Bool: If true, the user wants to wrap the text in the cell. In this case,   the option column_width contains the column width so that the text can be wrapped into   multiple lines.\ncell_first_line_only::Bool: If true, the user only wants the first line.\ncolumn_width::Integer: The column width.\ncompact_printing::Bool: If true, the user wants compact printing (see :compact   options of IOContext).\nlimit_printing::Bool: If true, the user wants the cells to be converted using the   option :limit => true in IOContext.\nlinebreaks::Bool: If true, the user wants line breaks inside the cells.\nrenderer::Union{Val{:print}, Val{:show}}: The render that the user wants to convert the   cells to strings.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"reset!(c::CustomTextCell)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"Reset all fields in the custom text cell c.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"info: Info\nThe reset! function is not required for the API. It is called before parsing the custom text cell.","category":"page"},{"location":"man/text_backend/#UrlTextCell","page":"Text","title":"UrlTextCell","text":"","category":"section"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"There is one custom text cell bundled with PrettyTables.jl called UrlTextCell. This type adds support for rendering implicit hyperlinks using the escape sequence \\e]8. Hence, the user can render a text that has a hyperlink associated with it.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"A UrlTextCell can be created with the following function:","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"UrlTextCell(text::String, url::String","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"which creates a URL cell with a specific text that points to an url.","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"julia> table = [\n      1 \"Ronan Arraes Jardim Chagas\" UrlTextCell(\"Ronan Arraes Jardim Chagas\", \"https://ronanarraes.com\")\n      2 \"Google\" UrlTextCell(\"Google\", \"https://google.com\")\n      3 \"Apple\" UrlTextCell(\"Apple\", \"https://apple.com\")\n      4 \"Emojis!\" UrlTextCell(\"ð\"^20, \"https://emojipedia.org/github/\")\n  ]\n\njulia> pretty_table(table)","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"(Image: )","category":"page"},{"location":"man/text_backend/","page":"Text","title":"Text","text":"warning: Warning\nThis feature is not supported by all terminal emulators.","category":"page"},{"location":"man/alignment/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"using PrettyTables","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"The keyword alignment can be a Symbol or a vector of Symbol.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"If it is a symbol, we have the following behavior:","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":":l or :L: the text of all columns will be left-aligned;\n:c or :C: the text of all columns will be center-aligned;\n:r or :R: the text of all columns will be right-aligned;\nOtherwise it defaults to :r.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"If it is a vector, it must have the same number of symbols as the number of columns in data. The i-th symbol in the vector specify the alignment of the i-th column using the same symbols as described previously.","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"data = Any[f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\npretty_table(data; alignment=:l)\n\npretty_table(data; alignment=[:l, :c, :r])","category":"page"},{"location":"man/alignment/","page":"Alignment","title":"Alignment","text":"note: Note\nThe alignment keyword is supported in all back ends.","category":"page"},{"location":"man/html_examples/#HTML-Back-End-examples","page":"HTML Back End","title":"HTML Back End examples","text":"","category":"section"},{"location":"man/html_examples/","page":"HTML Back End","title":"HTML Back End","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/html_examples/","page":"HTML Back End","title":"HTML Back End","text":"Coming soon...","category":"page"},{"location":"man/html_backend/#HTML-Back-End","page":"HTML","title":"HTML Back End","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"using PrettyTables","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<script language=\"javascript\" type=\"text/javascript\">\n function resizeIframe(obj)\n {\n   obj.style.height = obj.contentWindow.document.body.scrollHeight + 10 + 'px';\n   obj.style.width = obj.contentWindow.document.body.scrollWidth + 100 + 'px';\n }\n</script>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The following options are available when the HTML back end is used. Those can be passed as keywords when calling the function pretty_table:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"allow_html_in_cells::Bool: By default, special characters like <, >, \", etc. are   replaced in HTML back end to generate valid code. However, this algorithm blocks the   usage of HTML code inside of the cells. If this keyword is true, the escape algorithm   will not be applied, allowing HTML code inside all the cells. In this case, the user   must ensure that the output code is valid. If only few cells have HTML code, wrap them   in a HtmlCell object instead.   (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of the cells in   the continuation row. This row is printed if the table is vertically cropped.   (Default = :r)\nhighlighters::Union{HtmlHighlighter, Tuple}: An instance of HtmlHighlighter or   a tuple with a list of HTML highlighters (see the section HTML Highlighters).\nlinebreaks::Bool: If true, \\\\n will be replaced by <br>.   (Default = false)\nmaximum_columns_width::String: A string with the maximum width of each columns. This   string must contain a size that is valid in HTML. If it is not empty, each cell will   have the following style:\n\"max-width\": <value of maximum_column_width>\n\"overflow\": \"hidden\"\n\"text-overflow\": \"ellipsis\"\n\"white-space\": \"nowrap\"\nIf it is empty, no additional style is applied.   (Default = \"\")\nstandalone::Bool: If true, a complete HTML page will be generated.  Otherwise, only   the content between the tags <table> and </table> will be printed (with the tags   included).   (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it is   :bottom, the data, if required, will be cropped in the bottom. On the other hand, if   it is :middle, the data will be cropped in the middle if necessary.   (Default = :bottom)\ntable_div_class::String: The class name for the table div. It is only used if   wrap_table_in_div is true.   (Default = \"\")\ntable_class::String: The class name for the table.   (Default = \"\")\ntable_style::Dict{String, String}: A dictionary containing the CSS properties and their   values to be added to the table style.   (Default = Dict{String, String}())\ntf::HtmlTableFormat: An instance of the structure HtmlTableFormat that defines   the general format of the HTML table.\ntop_left_str::String: String to be printed at the left position of the top bar.   (Default = \"\")\ntop_left_str_decoration::HtmlDecoration: Decoration used to print the top-left string   (see top_left_str).   (Default = HtmlDecoration())\ntop_right_str::String: String to be printed at the right position of the top bar. Notice   that this string will be replaced with the omitted cell summary if it must be displayed.   (Default = \"\")\ntop_right_str_decoration::HtmlDecoration: Decoration used to print the top-right string   (see top_right_str).   (Default = HtmlDecoration())\nwrap_table_in_div::Bool: If true, the table will be wrapped in a div.    (Default: false)","category":"page"},{"location":"man/html_backend/#HTML-Highlighters","page":"HTML","title":"HTML Highlighters","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"A set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"f::Function: Function with the signature f(data, i, j) in which should return true   if the element (i,j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return the HtmlDecoration to be applied to the cell   that must be highlighted.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The function f has the following signature:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"f(data, i, j)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"in which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element.  Otherwise, the default style will be used.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"If the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type HtmlDecoration that contains the decoration to be applied to the cell.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"A HTML highlighter can be constructed using two helpers:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"HtmlHighlighter(f::Function, decoration::HtmlDecoration)\nHtmlHighlighter(f::Function, fd::Function)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"info: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"note: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"note: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"There are a set of pre-defined highlighters (with names hl_*) to make the usage simpler. They are defined in the file ./src/backends/html/predefined_highlighters.jl.","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"t = 0:1:20\n\ndata = hcat(t, ones(length(t)) * 1, 1 * t, 0.5 .* t.^2)\n\nheader = (\n    [\"Time\", \"Acceleration\", \"Velocity\", \"Distance\"],\n    [ \"[s]\",       \"[m/sÂ²]\",    \"[m/s]\",      \"[m]\"]\n)\n\nhl_v = HtmlHighlighter(\n    (data, i, j) -> (j == 3) && data[i, 3] > 9,\n    HtmlDecoration(color = \"blue\", font_weight = \"bold\")\n)\n\nhl_p = HtmlHighlighter(\n    (data, i, j) -> (j == 4) && data[i, 4] > 10,\n    HtmlDecoration(color = \"red\")\n)\n\nhl_e = HtmlHighlighter(\n    (data, i, j) -> data[i, 1] == 10,\n    HtmlDecoration(background = \"black\", color = \"white\")\n)\n\npretty_table(\n    data;\n    backend = Val(:html),\n    header = header,\n    highlighters = (hl_e, hl_p, hl_v),\n    standalone = true\n)","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"mkpath(\"html_backend\")\n\nstr = pretty_table(\n    String,\n    data;\n    backend = Val(:html),\n    header = header,\n    highlighters = (hl_e, hl_p, hl_v),\n    standalone = true\n)\n\nopen(\"html_backend/html_highlighter_example.html\", \"w\") do f\n  write(f, str)\nend","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_highlighter_example.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_highlighter_example.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/#HTML-Table-Formats","page":"HTML","title":"HTML Table Formats","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"The following table formats are available when using the HTML back end:","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"mkpath(\"html_backend\")\n\nheader = [\n  \"Header 1\" \"Header 2\" \"Header 3\" \"Header 4\"\n  \"Sub 1\"    \"Sub 2\"    \"Sub 3\"    \"Sub 4\"\n]\n\ndata = [\n    true  100.0 0x8080 \"String\"\n    false 200.0 0x0808 \"String\"\n    true  300.0 0x1986 \"String\"\n    false 400.0 0x1987 \"String\"\n]\n\nfor prefix in (\n    \"default\",\n    \"dark\",\n    \"minimalist\",\n    \"matrix\",\n    \"simple\"\n)\n    local str\n\n    filename = \"html_format_$prefix.html\"\n    tf       = Symbol(\"tf_html_\" * prefix)\n\n    str = pretty_table(\n        String,\n        data;\n        backend = Val(:html),\n        standalone = true,\n        show_header = prefix == \"matrix\" ? false : true,\n        tf = @eval($tf),\n    )\n\n    open(\"html_backend/$filename\", \"w\") do f\n      write(f, str)\n    end\nend","category":"page"},{"location":"man/html_backend/#tf_html_default-(**Default**)","page":"HTML","title":"tf_html_default (Default)","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_default.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_default.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/#tf_html_dark","page":"HTML","title":"tf_html_dark","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_dark.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_dark.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/#tf_html_minimalist","page":"HTML","title":"tf_html_minimalist","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_minimalist.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_minimalist.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/#tf_html_matrix","page":"HTML","title":"tf_html_matrix","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_matrix.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_matrix.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"info: Info\nIn this case, the table format html_matrix was printed with the option show_header = false.","category":"page"},{"location":"man/html_backend/#tf_html_simple","page":"HTML","title":"tf_html_simple","text":"","category":"section"},{"location":"man/html_backend/","page":"HTML","title":"HTML","text":"<iframe src=\"html_format_simple.html\" frameborder=\"0\" scrolling=\"no\" onload=\"javascript:resizeIframe(this)\">\n  <p>Your browser does not support iframes. Click <a href=\"html_format_simple.html>here</a> to see the table.</p>\n</iframe>","category":"page"},{"location":"man/usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"using PrettyTables","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The following function can be used to print data.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"function pretty_table([io::IO | String,] table;  kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Print to io the table table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"If io is omitted, it defaults to stdout. If String is passed in the place of io, a String with the printed table will be returned by the function. If HTML is passed in the place of io, an HTML object is returned with the printed table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"When printing, it will be verified if table complies with Tables.jl API. If it is compliant, this interface will be used to print the table. If it is not compliant, only the following types are supported:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"AbstractVector: any vector can be printed.\nAbstractMatrix: any matrix can be printed.\nDict: any Dict can be printed. In this case, the special keyword sortkeys can be  used to select whether or not the user wants to print the dictionary with the keys  sorted. If it is false, the elements will be printed on the same order returned by the  functions keys and values.  Notice that this assumes that the keys are sortable, if  they are not,  an error will be thrown.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The user can select which back end will be used to print the tables using the keyword argument backend. Currently, the following back ends are supported:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Text (backend = Val(:text)): prints the table in text mode. This is the default  selection if the keyword backend is absent.\nHTML (backend = Val(:html)): prints the table in HTML.\nLaTeX (backend = Val(:latex)): prints the table in LaTeX format.\nMarkdown (backend = Val(:markdown)): prints the table in Markdown format.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Each back end defines its own configuration keywords that can be passed using kwargs. However, the following keywords are valid for all back ends:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the columns (see the   section Alignment).\nbackend::Union{Symbol, T_BACKENDS}: Select which back end will be used to print the   table. Notice that the additional configuration in kwargs...  depends on the selected   back end.\ncell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}: A tuple   of functions with the signature f(data, i, j) that overrides the alignment of the cell   (i, j) to the value returned by f. It can also be a single function, when it is   assumed that only one alignment function is required, or nothing, when no cell   alignment modification will be performed. If the function f does not return a valid   alignment symbol as shown in section Alignment, it will be discarded. For   convenience, it can also be a dictionary of type (i, j) => a that overrides the   alignment of the cell (i, j) to a. a must be a symbol like specified in the   section Alignment.   (Default = nothing)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nIf more than one alignment function is passed to cell_alignment,  the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"cell_first_line_only::Bool: If true, only the first line of each cell will be printed.   (Default = false)\ncompact_printing::Bool: Select if the option :compact will be used when printing the   data.   (Default = true)\nformatters::Union{Nothing, Function, Tuple}: See the section Formatters.\nheader::Union{Symbol, Vector{Symbol}}: The header must be a tuple of vectors. Each one   must have the number of elements equal to the number of columns in the table. The first   vector is considered the header and the others are the subheaders. If it is nothing, a   default value based on the type will be used. If a single vector is passed, it will be   considered the header.   (Default = nothing)\nheader_alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the header   columns (see the section Alignment). If the symbol that specifies the alignment   is :s for a specific column, the same alignment in the keyword alignment for that   column will be used.   (Default = :s)\nheader_cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   This keyword has the same structure of cell_alignment but in this case it operates in   the header. Thus, (i, j) will be a cell in the header matrix that contains the header   and sub-headers. This means that the data field in the functions will be the same   value passed in the keyword header.   (Default = nothing)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nIf more than one alignment function is passed to header_cell_alignment, the   functions will be evaluated in the same order of the tuple. The first one that returns   a valid alignment symbol for each cell is applied, and the rest is discarded.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"limit_printing::Bool: If true, the cells will be converted using the property :limit   => true of IOContext.   (Default = true)\nmax_num_of_columns::Int: The maximum number of table columns that will be rendered. If   it is lower than 0, all columns will be rendered.   (Default = -1)\nmax_num_of_rows::Int: The maximum number of table rows that will be rendered. If it is   lower than 0, all rows will be rendered.   (Default = -1)\nrenderer::Symbol: A symbol that indicates which function should be used to convert an   object to a string. It can be :print to use the function print or :show to use the   function show. Notice that this selection is applicable only to the table data.   Headers, sub-headers, and row name column are always rendered with print.   (Default = :print)\nrow_labels::Union{Nothing, AbstractVector}: A vector containing the row labels that will   be appended to the left of the table. If it is nothing, the column with the row labels   will not be shown. Notice that the size of this vector must match the number of rows in   the table.   (Default = nothing)\nrow_label_alignment::Symbol: Alignment of the column with the rows label (see the   section Alignment).\nrow_label_column_title::AbstractString: Title of the column with the row labels.   (Default = \"\")\nrow_number_column_title::AbstractString: Title of the column with the row numbers.   (Default = \"Row\")\nshow_header::Bool: If true, the header will be printed. Notice that all keywords and   parameters related to the header and sub-headers will be ignored.   (Default = false)\nshow_row_number::Bool: If true, a new column will be printed showing the row number.   (Default = false)\nshow_subheader::Bool: If true, the sub-header will be printed, i.e.  the header will   contain both the header and subheader. Notice that this option has no effect if show_header = false.   (Default = true)\ntitle::AbstractString: The title of the table. If it is empty, no title will be printed.   (Default = \"\")\ntitle_alignment::Symbol: Alignment of the title, which must be a symbol as explained in   the section Alignment. This argument is ignored in the LaTeX back end.   (Default = :l)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nNotice that all back ends have the keyword tf to specify the table printing format. Thus, if the keyword backend is not present or if it is nothing, the back end will be automatically inferred from the type of the keyword tf. In this case, if tf is also not present, it just fall-back to the text back end unless HTML is passed as the first argument. In this case, the default back end is set to HTML.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"If String is used, the keyword color selects whether or not the table will be converted to string with or without colors. The default value is false. Notice that this option only has effect in text backend.","category":"page"},{"location":"man/usage/#Examples","page":"Usage","title":"Examples","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"In the following, it is possible to see some examples for a quick start using the text back end.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"data = [1 2 3; 4 5 6];\n\npretty_table(data; header = [\"Column 1\", \"Column 2\", \"Column 3\"])\n\npretty_table(data; header = ([\"Column 1\", \"Column 2\", \"Column 3\"], [\"A\", \"B\", \"C\"]))\n\nstr = pretty_table(String, data; header = [\"Column 1\", \"Column 2\", \"Column 3\"])\n\nprint(str)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"dict = Dict(1 => \"Jan\", 2 => \"Feb\", 3 => \"Mar\", 4 => \"Apr\", 5 => \"May\", 6 => \"Jun\")\n\npretty_table(dict)\n\npretty_table(dict, sortkeys = true)","category":"page"},{"location":"man/usage/#Configuration","page":"Usage","title":"Configuration","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The following function can be used to print a table changing the default configurations of PrettyTables.jl:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It calls pretty_table using the default configuration in conf. The args...  and kwargs... can be the same as those passed to pretty_tables. Notice that all the configurations in kwargs... will overwrite the ones in conf.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The object conf can be created by the function set_pt_conf in which the keyword parameters can be any one supported by the function pretty_table as shown in the following.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"conf = set_pt_conf(tf = tf_markdown, alignment = :c)\n\ndata = [1 2 3; 4 5 6]\n\nheader = [\"Column 1\", \"Column 2\", \"Column 3\"]\n\npretty_table_with_conf(conf, data; header = header)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"A configuration object can be modified by the function set_pt_conf! and cleared by the function clear_pt_conf!.","category":"page"},{"location":"man/usage/#Helpers","page":"Usage","title":"Helpers","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The macro @pt was created to make it easier to pretty print tables to stdout. Its signature is:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"macro pt(expr...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"where the expression list expr contains the tables that should be printed like:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"@pt table1 table2 table3","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The user can select the table header by passing the expression:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":":header = [<Vector with the header>]","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Notice that the header is valid only for the next printed table. Hence:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"@pt :header = header1 table1 :header = header2 table2 table3","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"will print table1 using header1, table2 using header2, and table3 using the default header.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The global configurations used to print tables with the macro @pt can be selected by:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"macro ptconf(expr...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"where expr format must be:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"keyword1 = value1 keyword2 = value2 ...","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The keywords can be any possible keyword that can be used in the function pretty_table.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"All the configurations can be rested by calling @ptconfclean.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"warning: Warning\nIf a keyword is not supported by the function pretty_table, no error message is printed when calling @ptconf. However, an error will be thrown when @pt is called.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"info: Info\nWhen more than one table is passed to the macro @pt, multiple calls to pretty_table will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"data = [1 2 3; 4 5 6];\n\n@pt data\n\n@pt :header = [\"Column 1\", \"Column 2\", \"Column 3\"] data :header = ([\"Column 1\", \"Column 2\", \"Column 3\"], [\"A\", \"B\", \"C\"]) data\n\n@ptconf tf = tf_ascii_dots alignment = :c\n\n@pt data\n\n@ptconfclean\n\n@pt data","category":"page"},{"location":"man/text_examples/#Text-back-end-examples","page":"Text Back End","title":"Text back-end examples","text":"","category":"section"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"In the following, it is presented how the following matrix can be printed using the text back end.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> data = Any[ 1    false      1.0     0x01 ;\n                   2     true      2.0     0x02 ;\n                   3    false      3.0     0x03 ;\n                   4     true      4.0     0x04 ;\n                   5    false      5.0     0x05 ;\n                   6     true      6.0     0x06 ;]","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data, border_crayon = crayon\"yellow\")","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data, tf = tf_simple, border_crayon = crayon\"bold yellow\", header_crayon = crayon\"bold green\")","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data, tf = tf_markdown, show_row_number = true)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"The following example shows how formatters can be used to change how elements are printed.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> formatter = (v, i, j) -> begin\n           if j != 2\n               return isodd(i) ? i : 0\n           else\n               return v\n           end\n       end\n\njulia> pretty_table(data, tf = tf_ascii_rounded, formatters = formatter)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"The following example indicates how highlighters can be used to highlight the lowest and highest element in the data considering the columns 1, 3, and 5:","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> h1 = Highlighter((data, i, j) -> j in (1, 3, 4) && data[i, j] == maximum(data[2:end, [1, 3, 4]]),\n                        bold       = true,\n                        foreground = :blue )\n\njulia> h2 = Highlighter( (data,i,j)->j in (1, 3, 4) && data[i, j] == minimum(data[2:end,[1, 3, 4]]),\n                         bold       = true,\n                         foreground = :red )\n\njulia> pretty_table(data, highlighters = (h1, h2))","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"Since this package has support to the API defined by Tables.jl, many formats, e.g DataFrames.jl, can be pretty printed:","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:2:20, B = rand(10), C = rand(10))\n\njulia> pretty_table(df, formatters = ft_printf(\"%.3f\", [2, 3]), highlighters = (hl_lt(0.2), hl_gt(0.8)))","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"You can use body_hlines keyword to divide the table into interesting parts:","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data, body_hlines = [2, 4])","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"If you want to break lines inside the cells, you can set the keyword linebreaks to true. Hence, the characters \\n will cause a line break inside the cell.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> text = [\"This line contains\\nthe velocity [m/s]\" 10.0;\n               \"This line contains\\nthe acceleration [m/s^2]\" 1.0;\n               \"This line contains\\nthe time from the\\nbeginning of the simulation\" 10;]\n\njulia> pretty_table(text, linebreaks = true, body_hlines = [1, 2, 3])","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"The keyword show_header can be used to suppres the header, which leads to a very simplistic, compact format.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> pretty_table(data, tf = tf_borderless, show_header = false)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"By default, if the data is larger than the display, it will be cropped to fit it. This can be changed by using the keywords crop and display_size.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> data = rand(100, 10); pretty_table(data, highlighters = (hl_gt(0.5),))","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"You can use the keyword columns_width to select the width of each column, so that the data is cropped to fit the available space.","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> mat = rand(100, 4)\n\njulia> pretty_table(mat,\n                    highlighters = hl_gt(0.5),\n                    columns_width = [7, -1, 7, 8],\n                    compact_printing = false)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"If you want to save the printed table to a file, you can do:","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> open(\"output.txt\", \"w\") do f\n            pretty_table(f,data)\n       end","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"This package can also be used to create data reports in text format:","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> data = [\n    \"Torques\" \"\" \"\" \"\";\n    \"Atmospheric drag\" \".\"^10 10 \"10â»âµ Nm\";\n    \"Gravity gradient\" \".\"^10 3 \"10â»âµ Nm\";\n    \"Solar radiation pressure\" \".\"^10 0.1 \"10â»âµ Nm\";\n    \"Total\" \".\"^10 13.1 \"10â»âµ Nm\";\n    \"\" \"\" \"\" \"\"\n    \"Angular momentum\" \"\" \"\" \"\";\n    \"Atmospheric drag\" \".\"^10 6.5 \"Nms\";\n    \"Gravity gradient\" \".\"^10 3.0 \"Nms\";\n    \"Solar radiation pressure\" \".\"^10 1.0 \"Nms\";\n    \"Total\" \".\"^10 10.5 \"Nms\"\n]\n\njulia> pretty_table(\n    data;\n    body_hlines        = [1,7],\n    body_hlines_format = Tuple('â' for _ = 1:4),\n    cell_alignment     = Dict((1, 1) => :l, (7, 1) => :l),\n    formatters         = ft_printf(\"%10.1f\", 2),\n    highlighters       = (\n        hl_cell([(1, 1); (7, 1)], crayon\"bold\"),\n        hl_col(2, crayon\"dark_gray\"),\n        hl_row([5, 11], crayon\"bold yellow\")\n    ),\n    show_header        = false,\n    tf                 = tf_borderless\n)","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"The highlighters API can be used to dynamically highlight cells. In the next example, it is shown how the package ColorSchemes.jl can be integrated to build a table with a color map (the following example will be displayed better in a terminal that supports 24-bit color):","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"julia> using ColorSchemes\n\njulia> data = [sind(x) * cosd(y) for x in 0:10:180, y in 0:10:180]\n\njulia> hl = Highlighter((data, i, j) -> true,\n                        (h, data, i, j) -> begin\n                             color = get(colorschemes[:coolwarm], data[i, j], (-1, 1))\n                             return Crayon(foreground = (round(Int, color.r * 255),\n                                                         round(Int, color.g * 255),\n                                                         round(Int, color.b * 255)))\n                         end)\n\njulia> pretty_table(data;\n                    header = [\"x = $(x)Â°\" for x = 0:10:180],\n                    row_labels = [\"y = $(y)Â°\" for y = 0:10:180],\n                    highlighters = hl,\n                    formatters = ft_printf(\"%.2f\"))","category":"page"},{"location":"man/text_examples/","page":"Text Back End","title":"Text Back End","text":"(Image: )","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for PrettyTables.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [PrettyTables]","category":"page"},{"location":"lib/library/#PrettyTables.T_BACKENDS","page":"Library","title":"PrettyTables.T_BACKENDS","text":"T_BACKENDS\n\nTypes that define the supported back ends.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.AnsiTextCell","page":"Library","title":"PrettyTables.AnsiTextCell","text":"AnsiTextCell\n\nA text cell that supports rendering ANSI escape sequences without interfering with the table layout.\n\nFields\n\nPublic\n\nstring::String: The string with the cell text that can contain ANSI escape sequences.\n\nPrivate\n\n_rendered_lines::Union{Nothing, Vector{String}}: The lines with the rendered strings.\n_stripped_lines::Union{Nothing, Vector{String}}: The lines with the printable text.\n_crops::Union{Nothing, Vector{Int}}: Vector with the number of characters that must be   cropped at each line.\n_left_pads::Union{Nothing, Vector{Int}}: Left padding to be applied to each line.\n_right_pads::Union{Nothing, Vector{Int}}: Right padding to be applied to each line.\n_suffixes::Union{Nothing, Vector{String}}: Suffixed to be applied to each line.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.AnsiTextCell-Tuple{AbstractString}","page":"Library","title":"PrettyTables.AnsiTextCell","text":"AnsiTextCell(string::AbstractString)\n\nCreate an AnsiTextCell using string.\n\nAnsiTextCell(renderfn[; context])\n\nCreate an AnsiTextCell using a render function.\n\nrenderfn is a function with the following signature:\n\nrenderfn(io)::String\n\nthat renders a string that can contain ANSI sequences into io.\n\ncontext is a tuple of context arguments passed to an IOContext that renderfn receives. See IOContext for details on what arguments are available.\n\nUseful for supporting packages that have rich terminal outputs.\n\nExamples\n\nBelow are examples for wrappers around AnsiTextCell to print rich data into tables that make use of packages with rich terminal output.\n\nCrayons.jl\n\nApply custom decoration to text inside a cell.\n\nusing Crayons, PrettyTables\n\nb = crayon\"blue bold\"\ny = crayon\"yellow bold\"\ng = crayon\"green bold\"\n\npretty_table([AnsiTextCell(\"$(g)This $(y)is $(b)awesome!\") for _ in 1:5, _ in 1:5])\n\nImageInTerminal.jl\n\nShow images inside a table.\n\nusing ImageInTerminal, PrettyTables\n\nfunction ImageCell(img, size)\n    return AnsiTextCell(\n        io -> ImageInTerminal.imshow(io, img),\n        context = (:displaysize => size,),)\nend\n\nusing TestImages\nimg = testimage(\"lighthouse\")\npretty_table([ImageCell(img, (20, 20)) ImageCell(img, (40, 40))])\n\nUnicodePlots.jl\n\nShow a variety of plots in a table.\n\nusing UnicodePlots, PrettyTables\n\nfunction UnicodePlotCell(p)\n    return AnsiTextCell(\n        io -> show(io, p),\n        context = (:color => true,)\n    )\nend\n\npretty_table([\n    UnicodePlotCell(barplot(Dict(\"x\" => 10, \"y\" => 20)))\n    UnicodePlotCell(boxplot([1, 3, 3, 4, 6, 10]))\n])\n\nCommonMark.jl\n\nUse rich Markdown inside tables.\n\nusing CommonMark, PrettyTables\n\nfunction MarkdownCell(md)\n    return AnsiTextCell(\n        renderfn = io -> display(TextDisplay(io), md),\n        context = (:color => true,)\n    )\nend\n\npretty_table([MarkdownCell(cm\"**Hi**\") MarkdownCell(cm\"> quote\")])\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ColumnTable","page":"Library","title":"PrettyTables.ColumnTable","text":"struct ColumnTable\n\nThis structure helps to access elements that comply with the column access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.CustomTextCell","page":"Library","title":"PrettyTables.CustomTextCell","text":"abstract type CustomTextCell\n\nAbstract type of custom cells in the text backend.\n\nEach type must implement the following API:\n\nget_printable_cell_text: A function that must return a vector of strings with the   printable text, i.e. without any non-printable character.\nget_rendered_line: A function that must return the rendered line that will be printed to   the display.\napply_line_padding!: Apply a certain number of spaces to the left and right of a   specific line.\ncrop_line!: A function that must crop a certain number of printable characters from the   end of the line.\nappend_suffix_to_line!: Append a string suffix to a line of the custom cell.\napply_line_padding!: Apply left and right padding to a line of the custom cell.\ncrop_line!: Crop a certain number of characters from a line of the custom cell.\nget_printable_cell_line: Get a printable line of the custom cell.\nget_rendered_line: Get a rendered line of the custom cell.\nparse_cell_text: Parse the cell text and return a Vector{String} with the printable   lines.\nreset!: Reset all the temporary fields. This function is not required.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.Display","page":"Library","title":"PrettyTables.Display","text":"struct Display\n\nStore the information of the display and the current cursor position.\n\nnote: Note\nThis is not the real cursor position with respect to the display, but with respect to the point in which the table is printed.\n\nFields\n\nsize::Tuple{Int, Int}: Display size.\nrow::Int: Current row.\ncolumn::Int: Current column.\nhas_color::Bool: Indicates if the display has color support.\ncont_char::Char: The character that indicates the line is cropped.\ncont_reset::Bool: If true, the decoration will be reseted before printing the   continuation character. Otherwise, the decoration will be reseted after printing the   continuation character.\ncont_space_char::Char: Space character to be printed before cont_char.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.Highlighter","page":"Library","title":"PrettyTables.Highlighter","text":"struct Highlighter\n\nDefines the default highlighter of a table when using the text backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i,j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return the Crayon to be applied to the cell that must   be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd   is used.\n\nRemarks\n\nThis structure can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlCell","page":"Library","title":"PrettyTables.HtmlCell","text":"struct HtmlCell\n\nDefines a table cell that contains HTML code. It can be created using the macro @html_cell_str.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlDecoration","page":"Library","title":"PrettyTables.HtmlDecoration","text":"HtmlDecoration\n\nStructure that defines parameters to decorate a table cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlHighlighter","page":"Library","title":"PrettyTables.HtmlHighlighter","text":"HtmlHighlighter\n\nDefines the default highlighter of a table when using the html backend.\n\nFields\n\nf::Function: Function with the signature f(data,i,j) in which should return true if   the element (i,j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is the   highlighter. This function must return the HtmlDecoration to be applied to the cell   that must be highlighted.\ndecoration::HtmlDecoration: The HtmlDecoration to be applied to the highlighted cell   if the default fd is used.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nHtmlHighlighter(f::Function, decoration::HtmlDecoration)\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.HtmlTableFormat","page":"Library","title":"PrettyTables.HtmlTableFormat","text":"HtmlTableFormat\n\nFormat that will be used to print the HTML table. All parameters are strings compatible with the corresponding HTML property.\n\nFields\n\ncss::String: CSS to be injected at the end of the <style> section.\ntable_width::String: Table width.\n\nRemarks\n\nBesides the usual HTML tags related to the tables (table, td,th,tr, etc.), there are three important classes that can be used to format tables using the variablecss`.\n\nheader: This is the class of the header (first line).\nsubheader: This is the class of the sub-headers (all the rest of the lines in the header   section).\nheaderLastRow: The last row of the header section has additionally this class.\nrowNumber: All the cells related to the row number have this class. Thus, the row number   header can be styled using th.rowNumber and the row numbers cells can be styled using   td.rowNumber.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexCell","page":"Library","title":"PrettyTables.LatexCell","text":"struct LatexCell\n\nDefines a table cell that contains LaTeX code. It can be created using the macro @latex_cell_str.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexHighlighter","page":"Library","title":"PrettyTables.LatexHighlighter","text":"LatexHighlighter\n\nDefines the default highlighter of a table when using the LaTeX backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd: A function with the signature f(data, i, j, str)::String in which data is the   matrix, (i, j) is the element position in the table, and str is the data converted   to string. This function must return a string that will be placed in the cell.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nLatexHighlighter(f::Function, envs::Union{String, Vector{String}})\n\nLatexHighlighter(f::Function, fd::Function)\n\nThe first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.\n\nThus, for example:\n\nLatexHighlighter((data, i, j)->true, [\"textbf\", \"small\"])\n\nwill wrap all the cells in the table in the following environment:\n\n\\textbf{\\small{<Cell text>}}\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.LatexTableFormat","page":"Library","title":"PrettyTables.LatexTableFormat","text":"struct LatexTableFormat\n\nThis structure defines the format of the LaTeX table.\n\nFields\n\ntop_line::String: Top line of the table.\nheader_line::String: Line that separate the header from the table body.\nmid_line::String: Line printed in the middle of the table.\nbottom_line::String: Bottom line of the table.\nleft_vline::String: Left vertical line of the table.\nmid_vline::String: Vertical line in the middle of the table.\nright_vline::String: Right vertical line of the table.\nheader_envs::Vector{String}: LaTeX environments that will be used in each header cell.\nsubheader_envs::Vector{String}: LaTeX environments that will be used in each sub-header   cell.\nhlines::Vector{Symbol}: Horizontal lines that must be drawn by default.\nvlines::Union{Symbol, Vector{Symbol}}: Vertical lines that must be drawn by default.\ntable_type::Symbol: Select the type of table that should be used for this format.\nwrap_table::Bool: Select if the table must be wrapped inside the environment defined by   wrap_table_environment.\nwrap_table_environment::String: Environment in which the table will be wrapped if   wrap_table is true.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownDecoration","page":"Library","title":"PrettyTables.MarkdownDecoration","text":"struct MarkdownDecoration\n\nStructure that defines parameters to decorate a table cell in Markdown back end.\n\nFields\n\nbold::Bool: Bold text.\nitalic::Bool: Italic text.\nstrikethrough::Bool: Strikethrough.\ncode::Bool: Code.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.MarkdownHighlighter","page":"Library","title":"PrettyTables.MarkdownHighlighter","text":"struct MarkdownHighlighter\n\nDefines the default highlighter of a table when using the markdown backend.\n\nFields\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the MarkdownDecoration to be applied to the   cell that must be highlighted.\ndecoration::MarkdownDecoration: The MarkdownDecoration to be applied to the   highlighted cell if the default fd is used.\n\nRemarks\n\nThis structure can be constructed using two helpers:\n\nMarkdownHighlighter(f::Function, decoration::MarkdownDecoration)\n\nMarkdownHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrettyTablesConf","page":"Library","title":"PrettyTables.PrettyTablesConf","text":"struct PrettyTablesConf\n\nType of the object that holds a pre-defined set of configurations for PrettyTables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.PrintInfo","page":"Library","title":"PrettyTables.PrintInfo","text":"struct PrintInfo\n\nThis structure stores the information required so that the back ends can print the tables.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.ProcessedTable","page":"Library","title":"PrettyTables.ProcessedTable","text":"struct ProcessedTable\n\nThis struct contains the processed table, which handles additional columns, etc.  All the backend functions have access to this object.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.ProcessedTable-Tuple{Any, Any}","page":"Library","title":"PrettyTables.ProcessedTable","text":"ProcessedTable(data::Any, header::Any; kwargs...)\n\nCreate a processed table with data and header.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.RowPrintingState","page":"Library","title":"PrettyTables.RowPrintingState","text":"struct RowPrintingState\n\nStructure that hold the state of the row printing state machine.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.RowTable","page":"Library","title":"PrettyTables.RowTable","text":"struct RowTable\n\nThis structure helps to access elements that comply with the row access specification of Tables.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextCrayons","page":"Library","title":"PrettyTables.TextCrayons","text":"struct TextCrayons\n\nStructure that holds all the crayons in the text backend.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.TextFormat","page":"Library","title":"PrettyTables.TextFormat","text":"struct TextFormat\n\nFields\n\nup_right_corner::Char: Character in the up right corner.\nup_left_corner::Char: Character in the up left corner.\nbottom_left_corner::Char: Character in the bottom left corner.\nbottom_right_corner::Char: Character in the bottom right corner.\nup_intersection::Char: Character in the intersection of lines in the up part.\nleft_intersection::Char: Character in the intersection of lines in the left part.\nright_intersection::Char: Character in the intersection of lines in the right part.\nmiddle_intersection::Char: Character in the intersection of lines in the middle of the   table.\nbottom_intersection::Char: Character in the intersection of the lines in the bottom   part.\ncolumn::Char: Character in a vertical line inside the table.\nrow::Char: Character in a horizontal line inside the table.\nhlines::Vector{Symbol}: Horizontal lines that must be drawn by default.\nvlines::Union{Symbol, Vector{Symbol}}: Vertical lines that must be drawn by default.\n\nPre-defined formats\n\nThe following pre-defined formats are available: unicode (default), mysql, compact, markdown, simple, ascii_rounded, and ascii_dots.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.UndefinedCell","page":"Library","title":"PrettyTables.UndefinedCell","text":"struct UndefinedCell\n\nInternal structure to indicate that a cell has an undefined reference.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables.UrlTextCell","page":"Library","title":"PrettyTables.UrlTextCell","text":"UrlTextCell\n\nA text cell that contains a URL and is rendered using the ANSI escape sequence \\e8].\n\nwarning: Warning\nSome terminals do not support this feature, leading to a layout problem in the printed table.\n\nFields\n\nPublic\n\ntext::String: The label of the URL.\nurl::String: The URL.\n\nPrivate\n\n_crop::Int: Number of characters in the text that must be cropped when rendering the   URL.\n_left_pad::Int: Number of spaces to be added to the left of the text when rendering the   URL.\n_right_pad::Int: Number of spaces to be added to the right of the text when rendering   the URL.\n_suffix::String: Suffix to be appended to the text when rendering the URL.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#PrettyTables._add_column!","page":"Library","title":"PrettyTables._add_column!","text":"_add_column!(ptable::ProcessedTable, new_column::AbstractVector, new_header::Vector{String} = String[\"\"]; kwargs...) -> Nothing\n\nAdd a new column new_column with header new_header to ptable.\n\nKeywords\n\nalignment::Symbol: Alignment for the new column. (Default = :r)\nheader_alignment::Symbol: Alignment for the new column header. (Default = :s)\nid::Symbol: Identification symbol for the new column.   (Default = :additional_column)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._apply_markdown_decoration-Tuple{String, MarkdownDecoration}","page":"Library","title":"PrettyTables._apply_markdown_decoration","text":"_apply_markdown_decoration(str::String, d::MarkdownDecoration) -> String\n\nApply the markdown decoration d to str.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._aprint","page":"Library","title":"PrettyTables._aprint","text":"_aprint(buf::IO[, v]; indentation = 0, nspace = 2, minify = false) -> Nothing\n\nPrint the variable v to the buffer buf at the indentation level indentation. Each level has nspaces spaces. If minify is true, then the text is printed without breaklines or padding.\n\nIf v is not present, only the indentation spaces will be printed.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._aprintln","page":"Library","title":"PrettyTables._aprintln","text":"_aprintln(buf::IO, [v,] indentation = 0, nspaces = 2, minify = false) -> Nothing\n\nSame as _aprint, but a new line will be added at the end. Notice that this newline is not added if minify is true Notice that this newline is not added if minify is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#PrettyTables._check_hline-Tuple{PrettyTables.ProcessedTable, Vector{Int64}, AbstractVector, Int64}","page":"Library","title":"PrettyTables._check_hline","text":"_check_hline(ptable::ProcessedTable, hlines, body_hlines::AbstractVector, i::Int) -> Bool\n\nCheck if there is a horizontal line after the ith row of ptable considering the options hlines and body_hlines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._check_vline-Tuple{PrettyTables.ProcessedTable, AbstractVector, Int64}","page":"Library","title":"PrettyTables._check_vline","text":"_check_vline(ptable::ProcessedTable, vlines::AbstractVector, j::Int) -> Bool\n\nCheck if there is a vertical line after the jth column of ptable considering the option vlines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables._conf_to_nt","text":"_conf_to_nt(conf::PrettyTablesConf) -> NamedTuple\n\nConvert the configuration object conf to a named tuple so that it can be passed to pretty_table.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._convert_axes-Tuple{Any, Int64}","page":"Library","title":"PrettyTables._convert_axes","text":"_convert_axes(data::Any, i::Int) -> Int\n\nConvert the axes from the printed table data i to the axes in data.\n\nnote: Note\ni refers to the i-th element that will be printed.\n\n\n\n_convert_axes(data::Any, i::Int, j::Int) -> Int\n\nConvert the axes from the printed table data (i, j) to the axes in data.\n\nnote: Note\n(i, j) refers to the i-th data row and j-th data column that will be printed.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._count_hlines-Tuple{PrettyTables.ProcessedTable, Vector{Int64}, Vector{Int64}}","page":"Library","title":"PrettyTables._count_hlines","text":"_count_hlines(ptable::ProcessedTable, hlines::Vector{Int}, body_hlines::Vector{Int}) -> Int\n\nCount the number of horizontal lines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._count_vlines-Tuple{PrettyTables.ProcessedTable, Vector{Int64}}","page":"Library","title":"PrettyTables._count_vlines","text":"_count_vlines(ptable::ProcessedTable, vlines::Vector{Int}) -> Int\n\nCount the number of vertical lines.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._data_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._data_size","text":"_data_size(ptable::ProcessedTable) -> Int, Int\n\nReturn a tuple with the original data size.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_cell_alignment-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._get_cell_alignment","text":"_get_cell_alignemnt(ptable::ProcessedTable, i::Int, j::Int) -> Symbol\n\nGet the alignment of the ptable cell in ith row and jth column.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_column_alignment-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_column_alignment","text":"_get_column_alignment(ptable::ProcessedTable, j::Int) -> Symbol\n\nReturn the alignment of the jth column in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_column_id-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_column_id","text":"_get_column_id(ptable::ProcessedTable, j::Int) -> Symbol\n\nReturn the identification symbol of the column j of ptable. If the column is from the original data, :__ORIGINAL_DATA__ is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_data_column_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_data_column_index","text":"_get_data_column_index(ptable::ProcessedTable, j::Int) -> Int\n\nGet the index of the jth data column in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_data_row_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_data_row_index","text":"_get_data_row_index(ptable::ProcessedTable, i::Int) -> Int\n\nGet the index of the ith data row in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_element-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._get_element","text":"_get_element(ptable::ProcessedTable, i::Int, j::Int) -> Any\n\nGet the element (i, j) if ptable. This function always considers the additional columns and the header.\n\nNotice that i and j must be related to the row and column that will be printed. The actual index inside the data is handle internally in this function.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_header_element-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_header_element","text":"_get_header_element(ptable::ProcessedTable, j::Int) -> Any\n\nGet the jth header element in ptable. This function always considers the additional columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_num_of_hidden_columns-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._get_num_of_hidden_columns","text":"_get_num_of_hidden_columns(ptable::ProcessedTable) -> Int\n\nReturn the number of hidden columns (see option max_num_of_columns).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_num_of_hidden_rows-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._get_num_of_hidden_rows","text":"_get_num_of_hidden_rows(ptable::ProcessedTable) -> Int\n\nReturn the number of hidden rows (see option max_num_of_rows).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_row_id-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_row_id","text":"_get_row_id(ptable::ProcessedTable, j::Int) -> Symbol\n\nReturn the identification symbol of the row i of ptable. If the row is part of the header, it returns :__HEADER__: or :__SUBHEADER__. Otherwise it returns :__ORIGINAL_DATA__ because we do not have the functionality to add new rows yet.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._get_table_column_index-Tuple{PrettyTables.ProcessedTable, Int64}","page":"Library","title":"PrettyTables._get_table_column_index","text":"_get_table_column_index(ptable::ProcessedTable, jr::Int) -> Union{Nothing, Int}\n\nGet the table column index related to a data table index jr in ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._header_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._header_size","text":"_header_size(ptable::ProcessedTable) -> Int, Int\n\nReturn a tuple with the header size.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._is_cell_alignment_overridden-Tuple{PrettyTables.ProcessedTable, Int64, Int64}","page":"Library","title":"PrettyTables._is_cell_alignment_overridden","text":"_is_cell_alignment_overridden(ptable::ProcessedTable, i::Int, j::Int) -> Bool\n\nReturn true is the alignment of the cell (i, j) is overridden using the keyword option cell_alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._num_additional_columns-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._num_additional_columns","text":"_num_additional_columns(ptable::ProcessedTable) -> Int\n\nReturn the number of additional columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._process_hlines-Tuple{PrettyTables.ProcessedTable, Symbol}","page":"Library","title":"PrettyTables._process_hlines","text":"_process_hlines(ptable::ProcessedTable, hlines) -> Union{Symbol, Vector{Int}}\n\nProcess the horizontal lines hlines considering the processed table ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._process_vlines-Tuple{PrettyTables.ProcessedTable, Symbol}","page":"Library","title":"PrettyTables._process_vlines","text":"_process_vlines(ptable::ProcessedTable, vlines) -> Union{Symbol, Vector{Int}}\n\nProcess the vertical lines vlines considering the processed table ptable.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._size","text":"_size(ptable::ProcessedTable) -> Int, Int\n\nReturn a tuple with the current size of the table, considering the header, and the additional columns, but also the maximum number of rows and columns that user wants.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables._total_size-Tuple{PrettyTables.ProcessedTable}","page":"Library","title":"PrettyTables._total_size","text":"_total_size(ptable::ProcessedTable) -> Int\n\nReturn the total table size neglecting the options max_num_of_columns and max_num_of_rows.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.append_suffix_to_line!-Tuple{CustomTextCell, Int64, String}","page":"Library","title":"PrettyTables.append_suffix_to_line!","text":"append_suffix_to_line!(c::CustomTextCell, l::Int, suffix::String)\n\nAppend the suffix to the line l of the custom cell text c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.apply_line_padding!-Tuple{CustomTextCell, Int64, Int64, Int64}","page":"Library","title":"PrettyTables.apply_line_padding!","text":"apply_line_padding!(c::CustomTextCell, l::Int, left_pad::Int, right_pad::Int)\n\nApply to the line l of the custom text cell c the padding with left_pad spaces in the left and right_pad spaces in the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables.clear_pt_conf!","text":"clear_pt_conf!(conf::PrettyTablesConf) -> Nothing\n\nClear all configurations in conf.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.compact_type_str-Tuple{Any}","page":"Library","title":"PrettyTables.compact_type_str","text":"compact_type_str(T) -> String\n\nReturn a string with a compact representation of type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.crop_line!-Tuple{CustomTextCell, Int64, Int64}","page":"Library","title":"PrettyTables.crop_line!","text":"crop_line!(c::CustomTextCell, l::Int, num::Int)\n\nCrop num characters from the line l of the custom text cell c. The number of cropped characters must consider the left and right alignment paddings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_latex_sn-Tuple{Int64}","page":"Library","title":"PrettyTables.ft_latex_sn","text":"ft_latex_sn(m_digits::Int, [columns::AbstractVector{Int}]) -> Function\n\nFormat the numbers of the elements in the columns to a scientific notation using LaTeX. The number is first printed using Printf functions with the g modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument m_digits.\n\nIf m_digits is a Vector, columns must be also be a Vector with the same number of elements. If m_digits is a Integer, and columns is not specified (or is empty), the format will be applied to the entire table.  Otherwise, if m_digits is a String and columns is a Vector, the format will be applied only to the columns in columns.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_nomissing-Tuple{Missing, Int64, Int64}","page":"Library","title":"PrettyTables.ft_nomissing","text":"ft_nomissing(v::Any, i::Int, j::Int) -> Any\n\nReplace missing with an empty string. If v is not Missing, v is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_nonothing-Tuple{Nothing, Int64, Int64}","page":"Library","title":"PrettyTables.ft_nonothing","text":"ft_nonothing(v, i::Int, j::Int) -> Any\n\nReplace nothing with an empty string. If v is not Nothing, v is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_printf-Tuple{String}","page":"Library","title":"PrettyTables.ft_printf","text":"ft_printf(ftv_str::Union{String, Vector{String}}, [columns::AbstractVector{Int}]) -> Function\n\nApply the formats ftv_str (see the Printf standard library) to the elements in the columns columns.\n\nIf ftv_str is a Vector, columns must be also be a Vector with the same number of elements. If ftv_str is a String, and columns is not specified (or is empty), the format will be applied to the entire table.  Otherwise, if ftv_str is a String and columns is a Vector, the format will be applied only to the columns in columns.\n\ninfo: Info\nThis formatter will be applied only to the cells that are of type Number.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.ft_round-Tuple{Int64}","page":"Library","title":"PrettyTables.ft_round","text":"ft_round(digits::Union{Int, AbstractVector{Int}}, [columns::AbstractVector{Int}]) -> Function\n\nRound the elements in the columns to the number of digits.\n\nIf digits is a Vector, columns must be also be a Vector with the same number of elements. If digits is a Number, and columns is not specified (or is empty), the rounding will be applied to the entire table.  Otherwise, if digits is a Number and columns is a Vector, the elements in the columns columns will be rounded to the number of digits digits.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.get_printable_cell_line-Tuple{CustomTextCell, Int64}","page":"Library","title":"PrettyTables.get_printable_cell_line","text":"get_printable_cell_line(c::CustomTextCell, l::Int)\n\nReturn the printable line l of the custom text cell c. The printable cell line must consider the left and right alignment paddings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.get_rendered_line-Tuple{CustomTextCell, Int64}","page":"Library","title":"PrettyTables.get_rendered_line","text":"get_rendered_line(c::CustomTextCell, l::Int)\n\nReturn the rendered line l of the custom text cell l.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_cell-Tuple{Number, Number, Crayon}","page":"Library","title":"PrettyTables.hl_cell","text":"hl_cell(i::Number, j::Number, crayon::Crayon) -> Highlighter\n\nHighlight the cell (i,j) with the crayon.\n\nhl_cell(cells::AbstractVector{NTuple(2,Int)}, crayon::Crayon) -> Highlighter\n\nHighlights all the cells with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_cell-Tuple{Number, Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_cell","text":"hl_cell(i::Number, j::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight the cell (i, j) with the decoration (see HtmlDecoration).\n\nhl_cell(cells::AbstractVector{NTuple(2,Int)}, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlights all the cells with the decoration (see HtmlDecoration).\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_cell-Tuple{Number, Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_cell","text":"hl_cell(i::Number, j::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight the cell (i, j) with the decoration (see MarkdownDecoration).\n\nhl_cell(cells::AbstractVector{NTuple(2,Int)}, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlights all the cells with the decoration (see MarkdownDecoration).\n\ninfo: Info\nThose functions return a MarkdownHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_col-Tuple{Number, Crayon}","page":"Library","title":"PrettyTables.hl_col","text":"hl_col(i::Number, crayon::Crayon) -> Highlighter\n\nHighlight the entire column i with the crayon.\n\nhl_col(cols::AbstractVector{Int}, crayon::Crayon) -> Highlighter\n\nHighlights all the columns in cols with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_col-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_col","text":"hl_col(i::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight the entire column i with the decoration.\n\nhl_col(cols::AbstractVector{Int}, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlights all the columns in cols with the decoration.\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_col-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_col","text":"hl_col(i::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight the entire column i with the decoration.\n\nhl_col(cols::AbstractVector{Int}, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlights all the columns in cols with the decoration.\n\ninfo: Info\nThose functions return a MarkdownHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_geq-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_geq","text":"hl_geq(n::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight all elements that are â¥ n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_geq-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_geq","text":"hl_geq(n::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight all elements that are â¥ n using the decoration.\n\ninfo: Info\nThis function returns a MarkdownHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_geq-Tuple{Number}","page":"Library","title":"PrettyTables.hl_geq","text":"hl_geq(n::Number) -> Highlighter\n\nHighlight all elements that â¥ n.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_gt-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_gt","text":"hl_gt(n::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight all elements that are > n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_gt-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_gt","text":"hl_gt(n::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight all elements that are > n using the decoration.\n\ninfo: Info\nThis function returns a MarkdownHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_gt-Tuple{Number}","page":"Library","title":"PrettyTables.hl_gt","text":"hl_gt(n::Number) -> Highlighter\n\nHighlight all elements that are > n.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_leq-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_leq","text":"hl_leq(n::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight all elements that are â¤ n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_leq-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_leq","text":"hl_leq(n::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight all elements that are â¤ n using the decoration.\n\ninfo: Info\nThis function returns a MarkdownHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_leq-Tuple{Number}","page":"Library","title":"PrettyTables.hl_leq","text":"hl_leq(n::Number) -> Highlighter\n\nHighlight all elements that are â¤ n.\n\nnote: Note\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_lt-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_lt","text":"hl_lt(n::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight all elements that are < n using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_lt-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_lt","text":"hl_lt(n::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight all elements that are < n using the decoration.\n\ninfo: Info\nThis function returns a MarkdownHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_lt-Tuple{Number}","page":"Library","title":"PrettyTables.hl_lt","text":"hl_lt(n::Number) -> Highlighter\n\nHighlight all elements that are < n.\n\ninfo: Info\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_row-Tuple{Number, Crayon}","page":"Library","title":"PrettyTables.hl_row","text":"hl_row(i::Number, crayon::Crayon) -> Highlighter\n\nHighlight the entire row i with the crayon.\n\nhl_row(rows::AbstractVector{Int}, crayon::Crayon) -> Highlighter\n\nHighlights all the rows in rows with the crayon.\n\ninfo: Info\nThose functions return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_row-Tuple{Number, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_row","text":"hl_row(i::Number, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight the entire row i with the decoration.\n\nhl_row(rows::AbstractVector{Int}, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlights all the rows in rows with the decoration.\n\ninfo: Info\nThose functions return a HtmlHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_row-Tuple{Number, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_row","text":"hl_row(i::Number, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight the entire row i with the decoration.\n\nhl_row(rows::AbstractVector{Int}, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlights all the rows in rows with the decoration.\n\ninfo: Info\nThose functions return a MarkdownHighlighter to be used with the HTML backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_value-Tuple{Any, HtmlDecoration}","page":"Library","title":"PrettyTables.hl_value","text":"hl_value(v::Any, decoration::HtmlDecoration) -> HtmlHighlighter\n\nHighlight all the values that matches data[i,j] == v using the decoration.\n\ninfo: Info\nThis function returns a HtmlHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_value-Tuple{Any, MarkdownDecoration}","page":"Library","title":"PrettyTables.hl_value","text":"hl_value(v::Any, decoration::MarkdownDecoration) -> MarkdownHighlighter\n\nHighlight all the values that matches data[i,j] == v using the decoration.\n\ninfo: Info\nThis function returns a MarkdownHighlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.hl_value-Tuple{Any}","page":"Library","title":"PrettyTables.hl_value","text":"hl_value(v::Any) -> Highlighter\n\nHighlight all the values that matches data[i,j] == v.\n\ninfo: Info\nThis function return a Highlighter to be used with the text backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.include_pt_in_file-Tuple{AbstractString, AbstractString, Vararg{Any}}","page":"Library","title":"PrettyTables.include_pt_in_file","text":"include_pt_in_file(filename::AbstractString, mark::AbstractString, args...; kwargs...) -> Nothing\n\nInclude a table in the file filename using the mark.\n\nThis function will print a table using the arguments args and keywords kwargs in the function pretty_table (the IO must not be passed to args here). Then, it will search inside the file filename for the following section:\n\n<PrettyTables mark>\n...\n</PrettyTables>\n\nand will replace everything between the marks with the printed table. If the closing tag is in a separate line, all characters before it will be kept. This is important to add comment tags.\n\nIf the user wants to also remove the opening and ending tags, pass the keyword remove_tags = true.\n\nThe keyword tag_append can be used to pass a string that can be used to add a text after the opening tag. This is important for HTML where the comments have opening and closing tags. Thus, if tag_append = \" -->\", the following can be used to add a table into HTML files:\n\n<!-- <PrettyTables mark> -->\n...\n<!-- </PrettyTables> -->\n\nBy default, this function will copy the original file to filename_backup. If this is not desired, pass the keyword backup_file = false to the function.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.parse_cell_text-Tuple{CustomTextCell}","page":"Library","title":"PrettyTables.parse_cell_text","text":"parse_cell_text(c::CustomTextCell; kwargs...)\n\nParse the cell text and return a vector of String with the printable cell text, where each element in the vector is a new line.\n\nThe returned data must contain only the printable characters.\n\nThe following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of pretty_table, and the user must choose whether or not support them.\n\nautowrap::Bool: If true, the user wants to wrap the text in the cell. In this case,   the option column_width contains the column width so that the text can be wrapped into   multiple lines.\ncell_first_line_only::Bool: If true, the user only wants the first line.\ncolumn_width::Integer: The column width.\ncompact_printing::Bool: If true, the user wants compact printing (see :compact   options of IOContext).\nlimit_printing::Bool: If true, the user wants the cells to be converted using the   option :limit => true in IOContext.\nlinebreaks::Bool: If true, the user wants line breaks inside the cells.\nrenderer::Union{Val{:print}, Val{:show}}: The render that the user wants to convert the   cells to strings.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.pretty_table-Tuple{Any}","page":"Library","title":"PrettyTables.pretty_table","text":"pretty_table([io::IO | String | HTML,] table;  kwargs...)\n\nPrint to io the table.\n\nIf io is omitted, it defaults to stdout. If String is passed in the place of io, a String with the printed table will be returned by the function. If HTML is passed in the place of io, an HTML object is returned with the printed table.\n\nWhen printing, it will be verified if table complies with Tables.jl API. If it is compliant, this interface will be used to print the table. If it is not compliant, only the following types are supported:\n\nAbstractVector: any vector can be printed.\nAbstractMatrix: any matrix can be printed.\nDict: any Dict can be printed. In this case, the special keyword sortkeys can be  used to select whether or not the user wants to print the dictionary with the keys  sorted. If it is false, the elements will be printed on the same order returned by the  functions keys and values. Notice that this assumes that the keys are sortable, if  they are not, an error will be thrown.\n\nKeywords\n\nalignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the columns (see the   section Alignment).\nbackend::Union{Symbol, T_BACKENDS}: Select which back end will be used to print the   table (see the section Back End). Notice that the additional configuration in   kwargs... depends on the selected back end.\ncell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}: A tuple   of functions with the signature f(data, i, j) that overrides the alignment of the cell   (i, j) to the value returned by f. It can also be a single function, when it is   assumed that only one alignment function is required, or nothing, when no cell   alignment modification will be performed. If the function f does not return a valid   alignment symbol as shown in section Alignment, it will be discarded. For convenience,   it can also be a dictionary of type (i, j) => a that overrides the alignment of the   cell (i, j) to a. a must be a symbol like specified in the section Alignment.   (Default = nothing)\n\nnote: Note\nIf more than one alignment function is passed to cell_alignment, the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.\n\ncell_first_line_only::Bool: If true, only the first line of each cell will be printed.   (Default = false)\ncompact_printing::Bool: Select if the option :compact will be used when printing the   data.   (Default = true)\nformatters::Union{Nothing, Function, Tuple}: See the section Formatters.\nheader::Union{Symbol, Vector{Symbol}}: The header must be a tuple of vectors. Each one   must have the number of elements equal to the number of columns in the table. The first   vector is considered the header and the others are the subheaders. If it is nothing, a   default value based on the type will be used. If a single vector is passed, it will be   considered the header.   (Default = nothing)\nheader_alignment::Union{Symbol, Vector{Symbol}}: Select the alignment of the header   columns (see the section Alignment). If the symbol that specifies the alignment is   :s for a specific column, the same alignment in the keyword alignment for that   column will be used.   (Default = :s)\nheader_cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}:   This keyword has the same structure of cell_alignment but in this case it operates in   the header. Thus, (i, j) will be a cell in the header matrix that contains the header   and sub-headers. This means that the data field in the functions will be the same   value passed in the keyword header.   (Default = nothing)\n\nnote: Note\nIf more than one alignment function is passed to header_cell_alignment, the   functions will be evaluated in the same order of the tuple. The first one that returns   a valid alignment symbol for each cell is applied, and the rest is discarded.\n\nlimit_printing::Bool: If true, the cells will be converted using the property :limit   => true of IOContext.   (Default = true)\nmax_num_of_columns::Int: The maximum number of table columns that will be rendered. If   it is lower than 0, all columns will be rendered.   (Default = -1)\nmax_num_of_rows::Int: The maximum number of table rows that will be rendered. If it is   lower than 0, all rows will be rendered.   (Default = -1)\nrenderer::Symbol: A symbol that indicates which function should be used to convert an   object to a string. It can be :print to use the function print or :show to use the   function show. Notice that this selection is applicable only to the table data.   Headers, sub-headers, and row name column are always rendered with print.   (Default = :print)\nrow_labels::Union{Nothing, AbstractVector}: A vector containing the row labels that will   be appended to the left of the table. If it is nothing, the column with the row labels   will not be shown. Notice that the size of this vector must match the number of rows in   the table.   (Default = nothing)\nrow_label_alignment::Symbol: Alignment of the column with the row labels (see the   section Alignment).\nrow_label_column_title::AbstractString: Title of the column with the row labels.   (Default = \"\")\nrow_number_column_title::AbstractString: Title of the column with the row numbers.   (Default = \"Row\")\nshow_header::Bool: If true, the header will be printed. Notice that all keywords and   parameters related to the header and sub-headers will be ignored.   (Default = false)\nshow_row_number::Bool: If true, a new column will be printed showing the row number.   (Default = false)\nshow_subheader::Bool: If true, the sub-header will be printed, i.e. the header will   contain both the header and subheader. Notice that this option has no effect if   show_header = false.   (Default = true)\ntitle::AbstractString: The title of the table. If it is empty, no title will be printed.   (Default = \"\")\ntitle_alignment::Symbol: Alignment of the title, which must be a symbol as   explained in the section Alignment. This argument is ignored in the   LaTeX back end.   (Default = :l)\n\nnote: Note\nNotice that all back ends have the keyword tf to specify the table printing format. Thus, if the keyword backend is not present or if it is nothing, the back end will be automatically inferred from the type of the keyword tf. In this case, if tf is also not present, it just fall-back to the text back end unless HTML is passed as the first argument. In this case, the default back end is set to HTML.\n\nIf String is used, the keyword color selects whether or not the table will be converted to string with or without colors. The default value is false. Notice that this option only has effect in text back end.\n\nAlignment\n\nThe keyword alignment can be a Symbol or a vector of Symbol.\n\nIf it is a symbol, we have the following behavior:\n\n:l or :L: the text of all columns will be left-aligned;\n:c or :C: the text of all columns will be center-aligned;\n:r or :R: the text of all columns will be right-aligned;\nOtherwise it defaults to :r.\n\nIf it is a vector, it must have the same number of symbols as the number of columns in data. The i-th symbol in the vector specify the alignment of the -i*-th column using the same symbols as described previously.\n\nnote: Note\nIn HTML back end, the user can select :n ou :N to print the cell without any alignment annotation.\n\n\n\nText Back End\n\nThis back end produces text tables. This back end can be used by selecting backend = :text.\n\nKeywords\n\nalignment_anchor_fallback::Symbol: This keyword controls the line alignment when using   the regex alignment anchors if a match is not found. If it is :l, the left of the line   will be aligned with the anchor. If it is :c, the line center will be aligned with the   anchor. Otherwise, the end of the line will be aligned with the anchor.   (Default = :l)\nalignment_anchor_fallback_override::Dict{Int, Symbol}: A Dict{Int, Symbol} to override   the behavior of fallback_alignment_anchor for a specific column. Example:   Dict(3 => :c) changes the fallback alignment anchor behavior for :c only for the   column 3.\nalignment_anchor_regex::Dict{Int, AbstractVector{Regex}}: A dictionary   Dict{Int, AbstractVector{Regex}} with a set of regexes that is used to align the   values in the columns (keys). The characters at the first regex match (or anchor) of   each line in every cell of the column will be aligned.  The regex match is searched in   the same order as the regexes appear on the vector. The regex matching is applied after   the cell conversion to string, which includes the formatters. If no match is found for a   specific line, the alignment of this line depends on the options   alignment_anchor_fallback and alignment_anchor_fallback_override. If the key 0 is   present, the related regexes will be used to align all the columns. In this case, all   the other keys will be neglected. Example: Dict(2 => [r\"\\.\"]) aligns the decimal   point of the cells in the second column.   (Default = Dict{Int, Vector{Regex}}())\nautowrap::Bool: If true, the text will be wrapped on spaces to fit the column. Notice   that this function requires linebreaks = true and the column must have a fixed size   (see columns_width).\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which an   additional horizontal line should be drawn after the row. Notice that numbers lower than   0 and equal or higher than the number of printed rows will be neglected. This vector   will be appended to the one in hlines, but the indices here are related to the printed   rows of the body. Thus, if 1 is added to body_hlines, a horizontal line will be   drawn after the first data row.   (Default = Int[])\nbody_hlines_format::Union{Nothing, NTuple{4, Char}}: A tuple of 4 characters specifying   the format of the horizontal lines that will be drawn by body_hlines. The characters   must be the left intersection, the middle intersection, the right intersection, and the   row. If it is nothing, it will use the same format specified in tf.   (Default = nothing)\ncolumns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the width   of each column. If the width is equal or lower than 0, it will be automatically computed   to fit the large cell in the column. If it is a single integer, this number will be used   as the size of all columns.   (Default = 0)\ncrop::Symbol: Select the printing behavior when the data is bigger than the available   display size (see display_size). It can be :both to crop on vertical and horizontal   direction, :horizontal to crop only on horizontal direction, :vertical to crop only   on vertical direction, or :none to do not crop the data at all. If the io has   :limit => true, crop is set to :both by default. Otherwise, it is set to :none   by default.\ncrop_subheader::Bool: If true, the sub-header size will not be taken into account when   computing the column size. Hence, the print algorithm can crop it to save space. This   has no effect if the user selects a fixed column width.   (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of the cells in   the continuation row. This row is printed if the table is vertically cropped.   (Default = :c)\ndisplay_size::Tuple{Int, Int}: A tuple of two integers that defines the display size   (num. of rows, num. of columns) that is available to print the table. It is used to crop   the data depending on the value of the keyword crop. Notice that if a dimension is not   positive, it will be treated as unlimited.   (Default = displaysize(io))\nellipsis_line_skip::Integer: An integer defining how many lines will be skipped from   showing the ellipsis that indicates the text was cropped.   (Default = 0)\nequal_columns_width::Bool: If true, all the columns will have the same width.   (Default = false)\nhighlighters::Union{Highlighter, Tuple}: An instance of Highlighter or a tuple with a   list of text highlighters (see the section Text highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   horizontal lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see TextFormat).\nIf it is :all, all horizontal lines will be drawn.\nIf it is :none, no horizontal line will be drawn.\nIf it is a vector of integers, the horizontal lines will be drawn only after the rows   in the vector. Notice that the top line will be drawn if 0 is in hlines, and the   header and subheaders are considered as only 1 row. Furthermore, it is important to   mention that the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.  Finally,   for convenience, the top and bottom lines can be drawn by adding the symbols   :begin and :end to this vector, respectively, and the line after the header can   be drawn by adding the symbol :header.\n\ninfo: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.\n\nlinebreaks::Bool: If true, \\n will break the line inside the cells.   (Default = false)\nmaximum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the   maximum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the maximum width of all columns.   Notice that the parameter columns_width has precedence over this one.   (Default = 0)\nminimum_columns_width::Union{Int, AbstractVector{Int}}: A set of integers specifying the   minimum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the minimum width of all columns.   Notice that the parameter columns_width has precedence over this one.   (Default = 0)\nnewline_at_end::Bool: If false, the table will not end with a newline character.   (Default = true)\noverwrite::Bool: If true, the same number of lines in the printed table will be   deleted from the output io. This can be used to update the table in the display   continuously.   (Default = false)\nreserved_display_lines::Int: Number of lines to be left at the beginning of the printing   when vertically cropping the output. Notice that the lines required to show the title   are automatically computed.   (Default = 0)\nrow_number_alignment::Symbol: Select the alignment of the row number column (see the   section Alignment).   (Default = :r)\nshow_omitted_cell_summary::Bool: If true, a summary will be printed after the table   with the number of columns and rows that were omitted.   (Default = true)\ntf::TextFormat: Table format used to print the table (see TextFormat).   (Default = tf_unicode)\ntitle_autowrap::Bool: If true, the title text will be wrapped considering the title   size. Otherwise, lines larger than the title size will be cropped.   (Default = false)\ntitle_same_width_as_table::Bool: If true, the title width will match that of the   table. Otherwise, the title size will be equal to the display width.   (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it is   :bottom, the data, if required, will be cropped in the bottom. On the other hand, if   it is :middle, the data will be cropped in the middle if necessary.   (Default = :bottom)\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   vertical lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see TextFormat).\nIf it is :all, all vertical lines will be drawn.\nIf it is :none, no vertical line will be drawn.\nIf it is a vector of integers, the vertical lines will be drawn only after the columns   in the vector. Notice that the left line will be drawn if 0 is in vlines.   Furthermore, it is important to mention that the column number in this variable is   related to the printed column. Thus, it is affected by the options row_labels   and show_row_number.  Finally, for convenience, the left and right vertical lines   can be drawn by adding the symbols :begin and :end to this vector, respectively.\n\nThe following keywords related to crayons are available to customize the output decoration:\n\nborder_crayon::Crayon: Crayon to print the border.\nheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print the header.\nomitted_cell_summary_crayon::Crayon: Crayon used to print the omitted cell summary.\nrow_label_crayon::Crayon: Crayon to print the row labels.\nrow_label_header_crayon::Crayon: Crayon to print the header of the column with the row   labels.\nrow_number_header_crayon::Crayon: Crayon for the header of the column with the row   numbers.\nsubheader_crayon::Union{Crayon, Vector{Crayon}}: Crayon to print sub-headers.\ntext_crayon::Crayon: Crayon to print default text.\ntitle_crayon::Crayon: Crayon to print the title.\n\nThe keywords header_crayon and subheader_crayon can be a Crayon or a Vector{Crayon}. In the first case, the Crayon will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.\n\nCrayons\n\nA Crayon is an object that handles a style for text printed on terminals. It is defined in the package Crayons.jl. There are many options available to customize the style, such as foreground color, background color, bold text, etc.\n\nA Crayon can be created in two different ways:\n\njulia> Crayon(foreground = :blue, background = :black, bold = :true)\n\njulia> crayon\"blue bg:black bold\"\n\nFor more information, see the package documentation.\n\nText highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure Highlighter that contains three fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighter, or false otherwise.\nfd::Function: Function with the signature f(h,data,i,j) in which h is the   highlighter. This function must return the Crayon to be applied to the cell that must   be highlighted.\ncrayon::Crayon: The Crayon to be applied to the highlighted cell if the default fd   is used.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the cell (i, j) will be highlighted.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return a Crayon that will be applied to the cell.\n\nA highlighter can be constructed using three helpers:\n\nHighlighter(f::Function; kwargs...)\n\nwhere it will construct a Crayon using the keywords in kwargs and apply it to the highlighted cell,\n\nHighlighter(f::Function, crayon::Crayon)\n\nwhere it will apply the crayon to the highlighted cell, and\n\nHighlighter(f::Function, fd::Function)\n\nwhere it will apply the Crayon returned by the function fd to the highlighted cell.\n\ninfo: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nHTML Back End\n\nThis back end produces HTML tables. This back end can be used by selecting backend = Val(:html).\n\nKeywords\n\nallow_html_in_cells::Bool: By default, special characters like <, >, \", etc. are   replaced in HTML back end to generate valid code. However, this algorithm blocks the   usage of HTML code inside of the cells. If this keyword is true, the escape algorithm   will not be applied, allowing HTML code inside all the cells. In this case, the user   must ensure that the output code is valid. If only few cells have HTML code, wrap in a   HtmlCell object instead.   (Default = false)\ncontinuation_row_alignment::Symbol: A symbol that defines the alignment of the cells in   the continuation row. This row is printed if the table is vertically cropped.   (Default = :r)\nhighlighters::Union{HtmlHighlighter, Tuple}: An instance of HtmlHighlighter or   a tuple with a list of HTML highlighters (see the section HTML highlighters).\nlinebreaks::Bool: If true, \\n will be replaced by <br>. (Default = false)\nmaximum_columns_width::String: A string with the maximum width of each columns. This   string must contain a size that is valid in HTML. If it is not empty, each cell will   have the following style:\n\"max-width\": <value of maximum_column_width>\n\"overflow\": \"hidden\"\n\"text-overflow\": \"ellipsis\"\n\"white-space\": \"nowrap\"\nIf it is empty, no additional style is applied.   (Default = \"\")\nminify::Bool: If true, output will be displayed minified, i.e. without unnecessary   indentation or newlines.   (Default = false)\nstandalone::Bool: If true, a complete HTML page will be generated. Otherwise, only   the content between the tags <table> and </table> will be printed (with the tags   included).   (Default = false)\nvcrop_mode::Symbol: This variable defines the vertical crop behavior. If it is   :bottom, the data, if required, will be cropped in the bottom. On the other hand, if   it is :middle, the data will be cropped in the middle if necessary.   (Default = :bottom)\ntable_div_class::String: The class name for the table div. It is only used if   wrap_table_in_div is true.   (Default = \"\")\ntable_class::String: The class name for the table.   (Default = \"\")\ntable_style::Dict{String, String}: A dictionary containing the CSS properties and their   values to be added to the table style.   (Default = Dict{String, String}())\ntf::HtmlTableFormat: An instance of the structure HtmlTableFormat that defines   the general format of the HTML table.\ntop_left_str::String: String to be printed at the left position of the top bar.   (Default = \"\")\ntop_left_str_decoration::HtmlDecoration: Decoration used to print the top-left string   (see top_left_str).   (Default = HtmlDecoration())\ntop_right_str::String: String to be printed at the right position of the top bar. Notice   that this string will be replaced with the omitted cell summary if it must be displayed.   (Default = \"\")\ntop_right_str_decoration::HtmlDecoration: Decoration used to print the top-right string   (see top_right_str).   (Default = HtmlDecoration())\nwrap_table_in_div::Bool: If true, the table will be wrapped in a div.   (Default: false)\n\nHTML highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure HtmlHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i,j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature f(h, data, i, j) in which h is the   highlighter. This function must return the HtmlDecoration to be applied to the cell   that must be highlighted.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element.  Otherwise, the default style will be used.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type HtmlDecoration that contains the decoration to be applied to the cell.\n\nA HTML highlighter can be constructed using two helpers:\n\nHtmlHighlighter(f::Function, decoration::HtmlDecoration)\n\nHtmlHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\ninfo: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nLaTeX Back End\n\nThis back end produces LaTeX tables. This back end can be used by selecting backend = Val(:latex).\n\nKeywords\n\nbody_hlines::Vector{Int}: A vector of Int indicating row numbers in which an   additional horizontal line should be drawn after the row. Notice that numbers lower than   1 and equal or higher than the number of printed rows will be neglected. This vector   will be appended to the one in hlines, but the indices here are related to the printed   rows of the body. Thus, if 1 is added to body_hlines, a horizontal line will be   drawn after the first data row.   (Default = Int[])\nhighlighters::Union{LatexHighlighter, Tuple}: An instance of LatexHighlighter or a   tuple with a list of LaTeX highlighters (see the section LaTeX highlighters).\nhlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   horizontal lines will be drawn. It can be nothing, :all, :none or a vector of   integers.   (Default = nothing)\nIf it is nothing, which is the default, the configuration will be obtained from the   table format in the variable tf (see LatexTableFormat).\nIf it is :all, all horizontal lines will be drawn.\nIf it is :none, no horizontal line will be drawn.\nIf it is a vector of integers, the horizontal lines will be drawn only after the rows   in the vector. Notice that the top line will be drawn if 0 is in hlines, and the   header and subheaders are considered as only 1 row. Furthermore, it is important to   mention that the row number in this variable is related to the printed rows.   Thus, it is affected by the option to suppress the header show_header.  Finally,   for convenience, the top and bottom lines can be drawn by adding the symbols   :begin and :end to this vector, respectively, and the line after the header can   be drawn by adding the symbol :header.\n\ninfo: Info\nThe values of body_hlines will be appended to this vector. Thus, horizontal lines can be drawn even if hlines is :none.\n\nlabel::AbstractString: The label of the table. If empty, no label will be added.   (Default = \"\")\nlongtable_footer::Union{Nothing, AbstractString}: The string that will be drawn in the   footer of the tables before a page break. This only works if table_type is   :longtable. If it is nothing, no footer will be used.   (Default = nothing)\nrow_number_alignment::Symbol: Select the alignment of the row number column (see the   section Alignment).   (Default = :r)\ntable_type::Union{Nothing, Symbol}: Select which LaTeX environment will be used to print   the table. Currently supported options are :tabular for tabular or :longtable for   longtable. If it is nothing the default option of the table format will be used.   (Default = nothing)\ntf::LatexTableFormat: An instance of the structure LatexTableFormat that   defines the general format of the LaTeX table.\nvlines::Union{Nothing, Symbol, AbstractVector}: This variable controls where the   vertical lines will be drawn. It can be :all, :none or a vector of integers. In the   first case (the default behavior), all vertical lines will be drawn. In the second case,   no vertical line will be drawn. In the third case, the vertical lines will be drawn only   after the columns in the vector.  Notice that the left border will be drawn if 0 is in   vlines.  Furthermore, it is important to mention that the column number in this   variable is related to the printed columns. Thus, it is affected by the columns   added using the variable show_row_number. Finally, for convenience, the left and right   border can be drawn by adding the symbols :begin and :end to this vector,   respectively.   (Default = :none)\nwrap_table::Union{Nothing, String}: This variable controls whether to wrap the table in   a environment defined by the variable wrap_table_environment.  Defaults to true.   When false, the printed table begins with \\begin{tabular}. This option does not   work with :longtable. If it is nothing the default option of the table format will   be used.   (Default = nothing)\nwrap_table_environment::Union{Nothing, String}: Environment that will be used to wrap   the table if the option wrap_table is true. If it is nothing the default option of   the table format will be used.   (Default = nothing)\n\nLaTeX highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure LatexHighlighter. It contains the following two fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i, j) in data must be highlighted, or false otherwise.\nfd::Functions: A function with the signature f(data, i, j, str)::String in which   data is the matrix, (i, j) is the element position in the table, and str is the   data converted to string. This function must return a string that will be placed in the   cell.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element.  Otherwise, the default style will be used.\n\nIf the function f returns true, the function fd(data, i, j, str) will be called and must return the LaTeX string that will be placed in the cell.\n\nThere are two helpers that can be used to create LaTeX highlighters:\n\nLatexHighlighter(f::Function, envs::Union{String,Vector{String}})\n\nLatexHighlighter(f::Function, fd::Function)\n\nThe first will apply recursively all the LaTeX environments in envs to the highlighted text whereas the second let the user select the desired decoration by specifying the function fd.\n\nThus, for example:\n\nLatexHighlighter((data, i, j) -> true, [\"textbf\", \"small\"])\n\nwill wrap all the cells in the table in the following environment:\n\n\\textbf{\\small{<Cell text>}}\n\ninfo: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nMarkdown Back End\n\nThis back end produces Markdown tables. This back end can be used by selecting backend = Val(:markdown).\n\nKeywords\n\nallow_markdown_in_cells::Bool: By default, special markdown characters like *, _,   ~, etc. are escaped in markdown back end to generate valid output. However, this   algorithm blocks the usage of markdown code inside of the cells. If this keyword is   true, the escape algorithm will not be applied, allowing markdown code inside all   the cells. In this case, the user must ensure that the output code is valid.   (Default = false)\nhighlighters::Union{MarkdownHighlighter, Tuple}: An instance of MarkdownHighlighter or   a tuple with a list of Markdown highlighters (see the section   Markdown Highlighters).\nlinebreaks::Bool: If true, \\n will be replaced by <br>.   (Default = false)\nshow_omitted_cell_summary::Bool: If true, a summary will be printed after the table   with the number of columns and rows that were omitted.   (Default = false)\n\nThe following keywords are available to customize the output decoration:\n\nheader_decoration::MarkdownDecoration: Decoration applied to the header.   (Default = MarkdownDecoration(bold = true))\nrow_label_decoration::MarkdownDecoration: Decoration applied to the row label column.   (Default = MarkdownDecoration())\nrow_number_decoration::MarkdownDecoration: Decoration applied to the row number column.   (Default = MarkdownDecoration(bold = true))\nsubheader_decoration::MarkdownDecoration: Decoration applied to the sub-header.   (Default = MarkdownDecoration(code = true))\n\nMarkdown Highlighters\n\nA set of highlighters can be passed as a Tuple to the highlighters keyword.  Each highlighter is an instance of the structure MarkdownHighlighter. It contains the following two public fields:\n\nf::Function: Function with the signature f(data, i, j) in which should return true   if the element (i,j) in data must be highlighted, or false otherwise.\nfd::Function: Function with the signature fd(h, data, i, j) in which h is the   highlighter. This function must return the MarkdownDecoration to be applied to   the cell that must be highlighted.\n\nThe function f has the following signature:\n\nf(data, i, j)\n\nin which data is a reference to the data that is being printed, and i and j are the element coordinates that are being tested. If this function returns true, the highlight style will be applied to the (i, j) element. Otherwise, the default style will be used.\n\nIf the function f returns true, the function fd(h, data, i, j) will be called and must return an element of type MarkdownDecoration that contains the decoration to be applied to the cell.\n\nA markdown highlighter can be constructed using two helpers:\n\nMarkdownHighlighter(f::Function, decoration::MarkdownDecoration)\n\nMarkdownHighlighter(f::Function, fd::Function)\n\nThe first will apply a fixed decoration to the highlighted cell specified in decoration whereas the second let the user select the desired decoration by specifying the function fd.\n\ninfo: Info\nIf only a single highlighter is wanted, it can be passed directly to the keyword highlighter without being inside a Tuple.\n\nnote: Note\nIf multiple highlighters are valid for the element (i, j), the applied style will be equal to the first match considering the order in the tuple highlighters.\n\nnote: Note\nIf the highlighters are used together with Formatters, the change in the format will not affect the parameter data passed to the highlighter function f. It will always receive the original, unformatted value.\n\n\n\nFormatters\n\nThe keyword formatters can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:\n\nf(v, i, j)\n\nwhere v is the value in the cell, i is the row number, and j is the column number. Thus, it must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.\n\nThis keyword can also be a single function, meaning that only one formatter is available, or nothing, meaning that no formatter will be used.\n\nFor example, if we want to multiply all values in odd rows of the column 2 by Ï, the formatter should look like:\n\nformatters = (v, i, j) -> (j == 2 && isodd(i)) ? v * Ï : v\n\nIf multiple formatters are available, they will be applied in the same order as they are located in the tuple. Thus, for the following formatters:\n\nformatters = (f1, f2, f3)\n\neach element v in the table (i-th row and j-th column) will be formatted by:\n\nv = f1(v,i,j)\nv = f2(v,i,j)\nv = f3(v,i,j)\n\nThus, the user must be ensure that the type of v between the calls are compatible.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf, Vararg{Any}}","page":"Library","title":"PrettyTables.pretty_table_with_conf","text":"pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...) -> Nothing\n\nCall pretty_table using the default configuration in conf. The args... and kwargs... can be the same as those passed to pretty_tables. Notice that all the configurations in kwargs... will overwrite the ones in conf.\n\nThe object conf can be created by the function set_pt_conf in which the keyword parameters can be any one supported by the function pretty_table as shown in the following.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.reset!-Tuple{CustomTextCell}","page":"Library","title":"PrettyTables.reset!","text":"reset!(c::CustomTextCell)\n\nReset all fields in the custom text cell c.\n\nThis function is not required for the API. It is called before parsing the custom text cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}","page":"Library","title":"PrettyTables.set_pt_conf!","text":"set_pt_conf!(conf; kwargs...) -> Nothing\n\nApply the configurations in kwargs to the object conf.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.set_pt_conf-Tuple{}","page":"Library","title":"PrettyTables.set_pt_conf","text":"set_pt_conf(; kwargs...) -> Nothing\n\nCreate a new configuration object based on the arguments in kwargs.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#PrettyTables.@html_cell_str-Tuple{Any}","page":"Library","title":"PrettyTables.@html_cell_str","text":"@html_cell_str(str)\n\nCreate a table cell with HTML code.\n\nExamples\n\njulia> html_cell\"<i>Italic text</i>\"\nHtmlCell{String}(\"<i>Italic text</i>\")\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@latex_cell_str-Tuple{Any}","page":"Library","title":"PrettyTables.@latex_cell_str","text":"@latex_cell_str(str)\n\nCreate a table cell with LaTeX code.\n\nExamples\n\njulia> latex_cell\"\textbf{Bold text}\"\nLatexCell{String}(\"\\textbf{Bold text}\")\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@pt-Tuple","page":"Library","title":"PrettyTables.@pt","text":"@pt(expr...)\n\nPretty print tables in expr to stdout using the global configurations selected with the macro @ptconf.\n\nMultiple tables can be printed by passing multiple expressions like:\n\n@pt table1 table2 table3\n\nThe user can select the table header by passing the expression:\n\n:header = [<Vector with the header>]\n\nNotice that the header is valid only for the next printed table. Hence:\n\n@pt :header = header1 table1 :header = header2 table2 table3\n\nwill print table1 using header1, table2 using header2, and table3 using the default header.\n\ninfo: Info\nWhen more than one table is passed to this macro, then multiple calls to pretty_table will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.\n\nExamples\n\njulia> @ptconf tf = tf_simple\n\njulia> @pt :header = [\"Time\",\"Velocity\"] [1:1:10 ones(10)] :header = [\"Time\",\"Position\"] [1:1:10 1:1:10]\n======= ===========\n  Time   Velocity\n======= ===========\n   1.0        1.0\n   2.0        1.0\n   3.0        1.0\n   4.0        1.0\n   5.0        1.0\n   6.0        1.0\n   7.0        1.0\n   8.0        1.0\n   9.0        1.0\n  10.0        1.0\n======= ===========\n======= ===========\n  Time   Position\n======= ===========\n     1          1\n     2          2\n     3          3\n     4          4\n     5          5\n     6          6\n     7          7\n     8          8\n     9          9\n    10         10\n======= ===========\n\njulia> @pt ones(3,3) + I + [1 2 3; 4 5 6; 7 8 9]\n========= ======== =========\n  Col. 1   Col. 2   Col. 3\n========= ======== =========\n     3.0      3.0      4.0\n     5.0      7.0      7.0\n     8.0      9.0     11.0\n========= ======== =========\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@ptconf-Tuple","page":"Library","title":"PrettyTables.@ptconf","text":"@ptconf(expr...)\n\nAdd configurations in expr to be used with the macro @pt.\n\nThe expression format must be:\n\nkeyword1 = value1 keyword2 = value2 ...\n\nin which the keywords can be any other possible keyword that can be used in the function pretty_table.\n\nwarning: Warning\nIf a keyword is not supported by the function pretty_table, then no error message is printed when calling @ptconf. However, an error will be thrown when @pt is called.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#PrettyTables.@ptconfclean-Tuple{}","page":"Library","title":"PrettyTables.@ptconfclean","text":"@ptconfclean()\n\nClean all global configurations to pretty print tables using the macro @pt.\n\n\n\n\n\n","category":"macro"},{"location":"man/formatters/#Formatters","page":"Formatters","title":"Formatters","text":"","category":"section"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"CurrentModule = PrettyTables","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"using PrettyTables","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"The keyword formatters can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"f(v, i, j)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"where v is the value in the cell, i is the row number, and j is the column number. Thus, it must return the formatted value of the cell (i, j) that has the value v. Notice that the returned value will be converted to string after using the function sprint.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This keyword can also be a single function, meaning that only one formatter is available, or nothing, meaning that no formatter will be used.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"For example, if we want to multiply all values in odd rows of the column 2 by Ï, the formatter should look like:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"formatters = (v, i, j) -> (j == 2 && isodd(i)) ? v * Ï : v","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If multiple formatters are available, they will be applied in the same order as they are located in the tuple. Thus, for the following formatters:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"formatters = (f1, f2, f3)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"each element v in the table (i-th row and j-th column) will be formatted by:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"v = f1(v, i, j)\nv = f2(v, i, j)\nv = f3(v, i, j)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Thus, the user must be ensure that the type of v between the calls are compatible.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = Any[f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\nformatter = (v, i, j) -> round(v, digits = 3)\n\npretty_table(data; formatters = formatter)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThe user can check if a value is undefined (#undef) inside a formatter by using the comparison v isa PrettyTables.UndefinedCell.","category":"page"},{"location":"man/formatters/#Predefined-Formatters","page":"Formatters","title":"Predefined Formatters","text":"","category":"section"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"There are a set of predefined formatters (with names ft_*) to make the usage simpler. They are defined in the file ./src/predefined_formatter.jl.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"function ft_printf(ftv_str, [columns])","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Apply the formats ftv_str (see @sprintf) to the elements in the columns columns.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If ftv_str is a Vector, columns must be also be a Vector with the same number of elements. If ftv_str is a String, and columns is not specified (or is empty), the format will be applied to the entire table.  Otherwise, if ftv_str is a String and columns is a Vector, the format will be applied only to the columns in columns.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThis formatter will be applied only to the cells that are of type Number. The other types of cells will be left untouched.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = Any[ f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\npretty_table(data; formatters = ft_printf(\"%5.3f\"))\n\npretty_table(data; formatters = ft_printf(\"%5.3f\", [1,3]))","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"function ft_round(digits, [columns])","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Round the elements in the columns columns to the number of digits in digits.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"If digits is a Vector, columns must be also be a Vector with the same number of elements. If digits is a Number, and columns is not specified (or is empty), the rounding will be applied to the entire table.  Otherwise, if digits is a Number and columns is a Vector, the elements in the columns columns will be rounded to the number of digits digits.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = Any[ f(a) for a = 0:30:90, f in (sind, cosd, tand)]\n\npretty_table(data; formatters = ft_round(1))\n\npretty_table(data; formatters = ft_round(1, [1, 3]))","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"ft_nomissing","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This pre-defined formatter converts any cell that is missing to an empty string.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = [1 2 missing; 3 missing 4; 5 6 missing]\n\npretty_table(data)\n\npretty_table(data, formatters = ft_nomissing)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"ft_nonothing","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"This pre-defined formatter converts any cell that is nothing to an empty string.","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = [1 2 nothing; 3 missing 4; 5 6 nothing]\n\npretty_table(data)\n\npretty_table(data, formatters = ft_nonothing)","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"Notice that ft_nomissing and ft_nonothing can be combined:","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"data = [1 2 nothing; 3 missing 4; 5 6 nothing]\n\npretty_table(data, formatters = (ft_nonothing, ft_nomissing))","category":"page"},{"location":"man/formatters/","page":"Formatters","title":"Formatters","text":"note: Note\nThe formatters keyword is supported in all back ends.","category":"page"},{"location":"#PrettyTables.jl","page":"Home","title":"PrettyTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PrettyTables","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia package PrettyTables.jl has the purpose to print data in matrices in a human-readable format. It was inspired in the functionality provided by ASCII Table Generator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Welcome figure)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"PrettyTables\")","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/usage.md\"\n    \"man/text_backend.md\"\n    \"man/html_backend.md\"\n    \"man/latex_backend.md\"\n    \"man/markdown_backend.md\"\n    \"man/alignment.md\"\n    \"man/formatters.md\"\n    \"man/text_examples.md\"\n    \"man/html_examples.md\"\n    \"lib/library.md\"\n]\nDepth = 2","category":"page"}]
}
