<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Pretty Tables</title><link rel="canonical" href="https://ronisbr.github.io/PrettyTables.jl/stable/lib/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Pretty Tables logo"/></a><div class="docs-package-name"><span class="docs-autofit">Pretty Tables</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/usage/">Usage</a></li><li><span class="tocitem">Back-ends</span><ul><li><a class="tocitem" href="../../man/text_backend/">Text</a></li><li><a class="tocitem" href="../../man/html_backend/">HTML</a></li><li><a class="tocitem" href="../../man/latex_backend/">LaTeX</a></li></ul></li><li><a class="tocitem" href="../../man/alignment/">Alignment</a></li><li><a class="tocitem" href="../../man/filters/">Filters</a></li><li><a class="tocitem" href="../../man/formatters/">Formatters</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../man/text_examples/">Text back-end</a></li><li><a class="tocitem" href="../../man/html_examples/">HTML back-end</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ronisbr/PrettyTables.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>PrettyTables.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.T_BACKENDS" href="#PrettyTables.T_BACKENDS"><code>PrettyTables.T_BACKENDS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_BACKENDS</code></pre><p>Types that define the supported backends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.AnsiTextCell" href="#PrettyTables.AnsiTextCell"><code>PrettyTables.AnsiTextCell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnsiTextCell</code></pre><p>A text cell that supports rendering ANSI escape sequences without interfering with the table layout.</p><p><strong>Fields</strong></p><p><strong>Public</strong></p><ul><li><code>string::String</code>: The string with the cell text that can contain ANSI escape   sequences.</li></ul><p><strong>Private</strong></p><ul><li><code>_rendered_lines::Union{Nothing, Vector{String}}</code>: The lines with the rendered   strings.</li><li><code>_stripped_lines::Union{Nothing, Vector{String}}</code>: The lines with the   printable text.</li><li><code>_crops::Dict{Int, Int}</code>: Dictionary with the number of characters that must   be cropped.</li><li><code>_left_pads::Dict{Int, Int}</code>: Left padding to be applied to each line.</li><li><code>_right_pads::Dict{Int, Int}</code>: Right padding to be applied to each line.</li><li><code>_suffixes::Dict{Int, String}</code>: Suffixed to be applied to each line.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/ansi_text_cell.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.AnsiTextCell-Tuple{AbstractString}" href="#PrettyTables.AnsiTextCell-Tuple{AbstractString}"><code>PrettyTables.AnsiTextCell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AnsiTextCell(string::AbstractString)</code></pre><p>Create an <a href="#PrettyTables.AnsiTextCell"><code>AnsiTextCell</code></a> using <code>string</code>.</p><pre><code class="language-none">AnsiTextCell(renderfn[; context])</code></pre><p>Create an <a href="#PrettyTables.AnsiTextCell"><code>AnsiTextCell</code></a> using a render function.</p><p><code>renderfn</code> is a function with the following signature:</p><pre><code class="language-none">renderfn(io)::String</code></pre><p>that renders a string that can contain ANSI sequences into <code>io</code>.</p><p><code>context</code> is a tuple of context arguments passed to an <code>IOContext</code> that <code>renderfn</code> receives. See <a href="lib/@ref"><code>IOContext</code></a> for details on what arguments are available.</p><p>Useful for supporting packages that have rich terminal outputs.</p><p><strong>Examples</strong></p><p>Below are examples for wrappers around <code>AnsiTextCell</code> to print rich data into tables that make use of packages with rich terminal output.</p><p><strong>Crayons.jl</strong></p><p>Apply custom decoration to text inside a cell.</p><pre><code class="language-julia">using Crayons, PrettyTables

b = crayon&quot;blue bold&quot;
y = crayon&quot;yellow bold&quot;
g = crayon&quot;green bold&quot;

pretty_table([AnsiTextCell(&quot;$(g)This $(y)is $(b)awesome!&quot;) for _ in 1:5, _ in 1:5])</code></pre><p><strong>ImageInTerminal.jl</strong></p><p>Show images inside a table.</p><pre><code class="language-julia">using ImageInTerminal, PrettyTables

function ImageCell(img, size)
    return AnsiTextCell(
        io -&gt; ImageInTerminal.imshow(io, img),
        context = (:displaysize =&gt; size,),)
end

using TestImages
img = testimage(&quot;lighthouse&quot;)
pretty_table([ImageCell(img, (20, 20)) ImageCell(img, (40, 40))])</code></pre><p><strong>UnicodePlots.jl</strong></p><p>Show a variety of plots in a table.</p><pre><code class="language-julia">using UnicodePlots, PrettyTables

function UnicodePlotCell(p)
    return AnsiTextCell(
        io -&gt; show(io, p),
        context = (:color =&gt; true,)
    )
end

pretty_table([
    UnicodePlotCell(barplot(Dict(&quot;x&quot; =&gt; 10, &quot;y&quot; =&gt; 20)))
    UnicodePlotCell(boxplot([1, 3, 3, 4, 6, 10]))
])</code></pre><p><strong>CommonMark.jl</strong></p><p>Use rich Markdown inside tables.</p><pre><code class="language-julia">using CommonMark, PrettyTables

function MarkdownCell(md)
    return AnsiTextCell(
        renderfn = io -&gt; display(TextDisplay(io), md),
        context = (:color =&gt; true,)
    )
end

pretty_table([MarkdownCell(cm&quot;**Hi**&quot;) MarkdownCell(cm&quot;&gt; quote&quot;)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/ansi_text_cell.jl#L49-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ColumnTable" href="#PrettyTables.ColumnTable"><code>PrettyTables.ColumnTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ColumnTable</code></pre><p>This structure helps to access elements that comply with the column access specification of Tables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/types.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.CustomTextCell" href="#PrettyTables.CustomTextCell"><code>PrettyTables.CustomTextCell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CustomTextCell</code></pre><p>Abstract type of custom cells in the text backend.</p><p>Each type must implement the following API:</p><ul><li><p><code>get_printable_cell_text</code>: A function that must return a vector of strings   with the printable text, <em>i.e.</em> without any non-printable character.</p></li><li><p><code>get_rendered_line</code>: A function that must return the rendered line that will   be printed to the display.</p></li><li><p><code>apply_line_padding!</code>: Apply a certain number of spaces to the left and right   of a specific line.</p></li><li><p><code>crop_line!</code>: A function that must crop a certain number of printable   characters from the end of the line.</p></li><li><p><code>append_suffix_to_line!</code>: Append a string suffix to a line of the custom cell.</p></li><li><p><code>apply_line_padding!</code>: Apply left and right padding to a line of the custom   cell.</p></li><li><p><code>crop_line!</code>: Crop a certain number of characters from a line of the custom   cell.</p></li><li><p><code>get_printable_cell_line</code>: Get a printable line of the custom cell.</p></li><li><p><code>get_rendered_line</code>: Get a rendered line of the custom cell.</p></li><li><p><code>parse_cell_text</code>: Parse the cell text and return a <code>Vector{String}</code> with the   printable lines.</p></li><li><p><code>reset!</code>: Reset all the temporary fields. This function is not required.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/types.jl#L136-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.Display" href="#PrettyTables.Display"><code>PrettyTables.Display</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Display</code></pre><p>Store the information of the display and the current cursor position.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is not the real cursor position with respect to the display, but with respect to the point in which the table is printed.</p></div></div><p><strong>Fields</strong></p><ul><li><code>size::Tuple{Int, Int}</code>: Display size.</li><li><code>row::Int</code>: Current row.</li><li><code>col::Int</code>: Current column.</li><li><code>has_color::Bool</code>: Indicates if the display has color support.</li><li><code>cont_char::Char</code>: The character that indicates the line is cropped.</li><li><code>cont_space_char::Char</code>: Space character to be printed before <code>cont_char</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/types.jl#L106-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLDecoration" href="#PrettyTables.HTMLDecoration"><code>PrettyTables.HTMLDecoration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLDecoration</code></pre><p>Structure that defines parameters to decorate a table cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLHighlighter" href="#PrettyTables.HTMLHighlighter"><code>PrettyTables.HTMLHighlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLHighlighter</code></pre><p>Defines the default highlighter of a table when using the html backend.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: Function with the signature <code>f(data,i,j)</code> in which should   return <code>true</code> if the element <code>(i,j)</code> in <code>data</code> must be highlighter, or   <code>false</code> otherwise.</li><li><code>fd::Function</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is   the highlighter. This function must return the <code>HTMLDecoration</code> to be   applied to the cell that must be highlighted.</li><li><code>decoration::HTMLDecoration</code>: The <code>HTMLDecoration</code> to be applied to the   highlighted cell if the default <code>fd</code> is used.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using two helpers:</p><pre><code class="language-none">HTMLHighlighter(f::Function, decoration::HTMLDecoration)

HTMLHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply a fixed decoration to the highlighted cell specified in <code>decoration</code> whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/types.jl#L111-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLTableFormat" href="#PrettyTables.HTMLTableFormat"><code>PrettyTables.HTMLTableFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLTableFormat</code></pre><p>Format that will be used to print the HTML table. All parameters are strings compatible with the corresponding HTML property.</p><p><strong>Fields</strong></p><ul><li><code>css::String</code>: CSS to be injected at the end of the <code>&lt;style&gt;</code> section.</li><li><code>table_width::String</code>: Table width.</li></ul><p><strong>Remarks</strong></p><p>Besides the usual HTML tags related to the tables (<code>table</code>, <code>td,</code>th<code>,</code>tr<code>, etc.), there are three important classes that can be used to format tables using the variable</code>css`.</p><ul><li><code>header</code>: This is the class of the header (first line).</li><li><code>subheader</code>: This is the class of the sub-headers (all the rest of the lines   in the header section).</li><li><code>headerLastRow</code>: The last row of the header section has additionally this   class.</li><li><code>rowNumber</code>: All the cells related to the row number have this class. Thus,   the row number header can be styled using <code>th.rowNumber</code> and the   row numbers cells can be styled using <code>td.rowNumber</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/types.jl#L40-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.Highlighter" href="#PrettyTables.Highlighter"><code>PrettyTables.Highlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Highlighter</code></pre><p>Defines the default highlighter of a table when using the text backend.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should   return <code>true</code> if the element <code>(i,j)</code> in <code>data</code> must be highlighter, or   <code>false</code> otherwise.</li><li><code>fd::Function</code>: Function with the signature <code>f(h, data, i, j)</code> in which <code>h</code> is   the highlighter. This function must return the <code>Crayon</code> to be applied to the   cell that must be highlighted.</li><li><code>crayon::Crayon</code>: The <code>Crayon</code> to be applied to the highlighted cell if the   default <code>fd</code> is used.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using three helpers:</p><pre><code class="language-none">Highlighter(f::Function; kwargs...)</code></pre><p>where it will construct a <code>Crayon</code> using the keywords in <code>kwargs</code> and apply it to the highlighted cell,</p><pre><code class="language-none">Highlighter(f::Function, crayon::Crayon)</code></pre><p>where it will apply the <code>crayon</code> to the highlighted cell, and</p><pre><code class="language-none">Highlighter(f::Function, fd::Function)</code></pre><p>where it will apply the <code>Crayon</code> returned by the function <code>fd</code> to the highlighted cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/types.jl#L60-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.LatexHighlighter" href="#PrettyTables.LatexHighlighter"><code>PrettyTables.LatexHighlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LatexHighlighter</code></pre><p>Defines the default highlighter of a table when using the LaTeX backend.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should   return <code>true</code> if the element <code>(i, j)</code> in <code>data</code> must be highlighted, or   <code>false</code> otherwise.</li><li><code>fd</code>: A function with the signature <code>f(data, i, j, str)::String</code> in which   <code>data</code> is the matrix, <code>(i, j)</code> is the element position in the table, and   <code>str</code> is the data converted to string. This function must return a string   that will be placed in the cell.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using two helpers:</p><pre><code class="language-none">LatexHighlighter(f::Function, envs::Union{String, Vector{String}})

LatexHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply recursively all the LaTeX environments in <code>envs</code> to the highlighted text whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><p>Thus, for example:</p><pre><code class="language-none">LatexHighlighter((data, i, j)-&gt;true, [&quot;textbf&quot;, &quot;small&quot;])</code></pre><p>will wrap all the cells in the table in the following environment:</p><pre><code class="language-none">\textbf{\small{&lt;Cell text&gt;}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/latex/types.jl#L57-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.LatexTableFormat" href="#PrettyTables.LatexTableFormat"><code>PrettyTables.LatexTableFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LatexTableFormat</code></pre><p>This structure defines the format of the LaTeX table.</p><p><strong>Fields</strong></p><ul><li><code>top_line::String</code>: Top line of the table.</li><li><code>header_line::String</code>: Line that separate the header from the table body.</li><li><code>mid_line::String</code>: Line printed in the middle of the table.</li><li><code>bottom_line::String</code>: Bottom line of the table.</li><li><code>left_vline::String</code>: Left vertical line of the table.</li><li><code>mid_vline::String</code>: Vertical line in the middle of the table.</li><li><code>right_vline::String</code>: Right vertical line of the table.</li><li><code>header_envs::Vector{String}</code>: LaTeX environments that will be used in each   header cell.</li><li><code>subheader_envs::Vector{String}</code>: LaTeX environments that will be used in each   sub-header cell.</li><li><code>hlines::Vector{Symbol}</code>: Horizontal lines that must be drawn by default.</li><li><code>vlines::Union{Symbol, Vector{Symbol}}</code>: Vertical lines that must be drawn by   default.</li><li><code>table_type::Symbol</code>: Select the type of table that should be used for this   format.</li><li><code>wrap_table::Bool</code>: Select if the table must be wrapped inside the environment   defined by <code>wrap_table_environment</code>.</li><li><code>wrap_table_environment::String</code>: Environment in which the table will be   wrapped if <code>wrap_table</code> is true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/latex/types.jl#L12-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.PrettyTablesConf" href="#PrettyTables.PrettyTablesConf"><code>PrettyTables.PrettyTablesConf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PrettyTablesConf</code></pre><p>Type of the object that holds a pre-defined set of configurations for PrettyTables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/types.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.PrintInfo" href="#PrettyTables.PrintInfo"><code>PrettyTables.PrintInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PrintInfo</code></pre><p>This structure stores the information required so that the backends can print the tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/types.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.RowTable" href="#PrettyTables.RowTable"><code>PrettyTables.RowTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RowTable</code></pre><p>This structure helps to access elements that comply with the row access specification of Tables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/types.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.TextFormat" href="#PrettyTables.TextFormat"><code>PrettyTables.TextFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TextFormat</code></pre><p><strong>Fields</strong></p><ul><li><code>up_right_corner::Char</code>: Character in the up right corner.</li><li><code>up_left_corner::Char</code>: Character in the up left corner.</li><li><code>bottom_left_corner::Char</code>: Character in the bottom left corner.</li><li><code>bottom_right_corner::Char</code>: Character in the bottom right corner.</li><li><code>up_intersection::Char</code>: Character in the intersection of lines in the up   part.</li><li><code>left_intersection::Char</code>: Character in the intersection of lines in the left   part.</li><li><code>right_intersection::Char</code>: Character in the intersection of lines in the   right part.</li><li><code>middle_intersection::Char</code>: Character in the intersection of lines in the   middle of the table.</li><li><code>bottom_intersection::Char</code>: Character in the intersection of the lines in the   bottom part.</li><li><code>column::Char</code>: Character in a vertical line inside the table.</li><li><code>left_border::Char</code>: Character used as the left border.</li><li><code>right_border::Char</code>: Character used as the right border.</li><li><code>row::Char</code>: Character in a horizontal line inside the table.</li><li><code>hlines::Vector{Symbol}</code>: Horizontal lines that must be drawn by default.</li><li><code>vlines::Union{Symbol, Vector{Symbol}}</code>: Vertical lines that must be drawn by   default.</li></ul><p><strong>Pre-defined formats</strong></p><p>The following pre-defined formats are available: <code>unicode</code> (<strong>default</strong>), <code>mysql</code>, <code>compact</code>, <code>markdown</code>, <code>simple</code>, <code>ascii_rounded</code>, and <code>ascii_dots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/types.jl#L12-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.URLTextCell" href="#PrettyTables.URLTextCell"><code>PrettyTables.URLTextCell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">URLTextCell</code></pre><p>A text cell that contains a URL and is rendered using the ANSI escape sequence <code>\e8]</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Some terminals <strong>do not</strong> support this feature, leading to a layout problem in the printed table.</p></div></div><p><strong>Fields</strong></p><p><strong>Public</strong></p><ul><li><code>text::String</code>: The label of the URL.</li><li><code>url::String</code>: The URL.</li></ul><p><strong>Private</strong></p><ul><li><code>_crop::Int</code>: Number of characters in the text that must be cropped when   rendering the URL.</li><li><code>_left_pad::Int</code>: Number of spaces to be added to the left of the text when   rendering the URL.</li><li><code>_right_pad::Int</code>: Number of spaces to be added to the right of the text when   rendering the URL.</li><li><code>_suffix::String</code>: Suffix to be appended to the text when rendering the URL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/url_text_cell.jl#L12-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._aprint" href="#PrettyTables._aprint"><code>PrettyTables._aprint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_aprint(buf::IO, [v,] indentation = 0, nspace = 2, minify = false)</code></pre><p>Print the variable <code>v</code> to the buffer <code>buf</code> at the indentation level <code>indentation</code>. Each level has <code>nspaces</code> spaces. If <code>minify</code> is <code>true</code>, then the text is printed without breaklines or padding.</p><p>If <code>v</code> is not present, then only the indentation spaces will be printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/misc.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._aprintln" href="#PrettyTables._aprintln"><code>PrettyTables._aprintln</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_aprintln(buf::IO, [v,] indentation = 0, nspaces = 2, minify = false)</code></pre><p>Same as <code>_aprint</code>, but a new line will be added at the end. Notice that this newline is not added if <code>minify</code> is <code>true</code> Notice that this newline is not added if <code>minify</code> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/misc.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}" href="#PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}"><code>PrettyTables._conf_to_nt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_conf_to_nt(conf::PrettyTablesConf)</code></pre><p>Convert the configuration object <code>conf</code> to a named tuple so that it can be passed to <code>pretty_table</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/configuration.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._crop_str" href="#PrettyTables._crop_str"><code>PrettyTables._crop_str</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_crop_str(str, crop_size, lstr = -1)</code></pre><p>Return a cropped string of <code>str</code> with size <code>crop_size</code>.</p><p>If the last character before the crop does not fit due to its width, then blank spaces are added.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._draw_continuation_row-Tuple{PrettyTables.Display, IO, TextFormat, Crayon, Crayon, Vector{Int64}, Vector{Int64}, Symbol}" href="#PrettyTables._draw_continuation_row-Tuple{PrettyTables.Display, IO, TextFormat, Crayon, Crayon, Vector{Int64}, Vector{Int64}, Symbol}"><code>PrettyTables._draw_continuation_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_draw_continuation_row(display::Display, io::IO, tf::TextFormat, text_crayon::Crayon, border_crayon::Crayon, cols_width::Vector{Int}, vlines::Vector{Int}, alignment::Symbol)</code></pre><p>Draw the continuation row when the table has filled the vertical space available. This function prints in each column the character <code>⋮</code> with the alignment in <code>alignment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._draw_line!-Tuple{PrettyTables.Display, IO, Char, Char, Char, Char, Crayon, Vector{Int64}, Vector{Int64}}" href="#PrettyTables._draw_line!-Tuple{PrettyTables.Display, IO, Char, Char, Char, Char, Crayon, Vector{Int64}, Vector{Int64}}"><code>PrettyTables._draw_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_draw_line!(display::Display, io::IO, left::Char, intersection::Char, right::Char, row::Char, border_crayon::Crayon, cols_width::Vector{Int}, vlines::Vector{Int})</code></pre><p>Draw a vertical line in internal line buffer of <code>display</code> and then flush to the io <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._eol-Tuple{PrettyTables.Display}" href="#PrettyTables._eol-Tuple{PrettyTables.Display}"><code>PrettyTables._eol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_eol(display::Display)</code></pre><p>Return <code>true</code> if the cursor is at the end of line or <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._fit_str_to_display" href="#PrettyTables._fit_str_to_display"><code>PrettyTables._fit_str_to_display</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_fit_str_to_display!(display::Display, str::Char, final_line_print::Bool = false, lstr::Int = -1)</code></pre><p>Return the string and the suffix to be printed in the display. It ensures that the return data will fit the <code>display</code>.</p><p>The parameter <code>final_line_print</code> must be set to <code>true</code> if this is the last string that will be printed in the line. This is necessary for the algorithm to select whether or not to include the continuation character.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p><p>The line buffer can be flushed to an <code>io</code> using the function <code>_nl!</code>.</p><p><strong>Return</strong></p><ul><li>The new string, which is <code>str</code> cropped to fit the display.</li><li>The suffix to be appended to the cropped string.</li><li>The number of columns that will be used to print the string and the suffix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L106-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._get_composed_ansi_format-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractString" href="#PrettyTables._get_composed_ansi_format-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractString"><code>PrettyTables._get_composed_ansi_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_get_composed_ansi_format(ansi::Vector{T}) where T&lt;:AbstractString</code></pre><p>Given a vector with a set of ANSI escape sequences, return a composed escape sequence that leads to the same formatting.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function only works with the minimal set used by <code>Markdown</code> in <code>stdlib</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L359-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._nl!-Tuple{PrettyTables.Display, IO}" href="#PrettyTables._nl!-Tuple{PrettyTables.Display, IO}"><code>PrettyTables._nl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_nl!(display::Display, io::IO)</code></pre><p>Flush the internal line buffer of <code>display</code> into <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._p!" href="#PrettyTables._p!"><code>PrettyTables._p!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_p!(display::Display, crayon::Crayon, str::Char, final_line_print::Bool = false, lstr::Int = -1)
_p!(display::Display, crayon::Crayon, str::String, final_line_print::Bool = false, lstr::Int = -1)</code></pre><p>Print <code>str</code> into the internal line buffer of <code>display</code> using the Crayon <code>crayon</code> with the display information in <code>display</code>. The parameter <code>final_line_print</code> must be set to <code>true</code> if this is the last string that will be printed in the line. This is necessary for the algorithm to select whether or not to include the continuation character.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p><p>The line buffer can be flushed to an <code>io</code> using the function <code>_nl!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L244-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_html-Tuple{Any}" href="#PrettyTables._parse_cell_html-Tuple{Any}"><code>PrettyTables._parse_cell_html</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_html(cell::T; kwargs...)</code></pre><p>Parse the table <code>cell</code> of type <code>T</code>.</p><p>This function must return a string that will be printed to the IO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/cell_parse.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_latex-Tuple{Any}" href="#PrettyTables._parse_cell_latex-Tuple{Any}"><code>PrettyTables._parse_cell_latex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_latex(cell::T; kwargs...)</code></pre><p>Parse the table <code>cell</code> of type <code>T</code>.</p><p>This function must return a string that will be printed to the IO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/latex/cell_parse.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_text-Tuple{Any}" href="#PrettyTables._parse_cell_text-Tuple{Any}"><code>PrettyTables._parse_cell_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_text(cell::T; kwargs...)</code></pre><p>Parse the table <code>cell</code> of type <code>T</code> and return a vector of <code>String</code> with the parsed cell text, one component per line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/cell_parse.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._pc!" href="#PrettyTables._pc!"><code>PrettyTables._pc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_pc!(cond::Bool, display::Display, io::IO, crayon::Crayon, str_true::Union{Char,String}, str_false::Union{Char,String}, final_line_print::Bool = false, lstr_true::Int = -1, lstr_false::Int = -1)</code></pre><p>If <code>cond == true</code> then print <code>str_true</code>. Otherwise, print <code>str_false</code>. Those strings will be printed into the internal line buffer of <code>display</code> using the Crayon <code>crayon</code> with the display information in <code>display</code>. The parameter <code>final_line_print</code> must be set to <code>true</code> if this is the last string that will be printed in the line. This is necessary for the algorithm to select whether or not to include the continuation character.</p><p>The size of the strings can be passed to <code>lstr_true</code> and <code>lstr_false</code> to save computational burden. If they are <code>-1</code>, then the string lengths will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/display.jl#L289-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._print_title-Tuple{IO, Vector{String}, Bool, Crayon}" href="#PrettyTables._print_title-Tuple{IO, Vector{String}, Bool, Crayon}"><code>PrettyTables._print_title</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_print_title(buf::IO, title_tokens::Vector{String}, has_color::Bool, title_crayon::Crayon)</code></pre><p>Print the table title to the buffer <code>buf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/title.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._printable_textwidth-Tuple{AbstractString}" href="#PrettyTables._printable_textwidth-Tuple{AbstractString}"><code>PrettyTables._printable_textwidth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_printable_textwidth(str::AbstractString)</code></pre><p>Compute the width of the string <code>str</code> neglecting all ANSI escape sequences that are not printable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_cell_text-Tuple{Any, Int64, Int64, Int64, Bool, Bool, String, Int64, Crayon, Symbol, Ref{Any}}" href="#PrettyTables._process_cell_text-Tuple{Any, Int64, Int64, Int64, Bool, Bool, String, Int64, Crayon, Symbol, Ref{Any}}"><code>PrettyTables._process_cell_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_cell_text(data::Any, i::Int, j::Int, l::Int, data_cell::Bool, data_str::String, data_len::Int, col_width::Int, crayon::Crayon, alignment::Symbol, highlighters::Ref{Any})</code></pre><p>Process the cell by applying the right alignment and also verifying the highlighters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/cell_parse.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_hlines-Tuple{Symbol, AbstractVector, Int64, Bool}" href="#PrettyTables._process_hlines-Tuple{Symbol, AbstractVector, Int64, Bool}"><code>PrettyTables._process_hlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_hlines(hlines::Union{Symbol,AbstractVector}, body_hlines::AbstractVector, num_printed_rows::Int, noheader::Bool)</code></pre><p>Process the horizontal lines in <code>hlines</code> and <code>body_hlines</code> considering the number of filtered rows <code>num_filtered_rows</code> and if the header is present (<code>noheader</code>).</p><p>It returns a vector of <code>Int</code> stating where the horizontal lines must be drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/misc.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_vlines-Tuple{Symbol, Int64}" href="#PrettyTables._process_vlines-Tuple{Symbol, Int64}"><code>PrettyTables._process_vlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_vlines(vlines::AbstractVector, num_printed_cols::Int)</code></pre><p>Process the vertical lines <code>vlines</code> considerering the number of printed columns <code>num_printed_cols</code>.</p><p>It returns a vector of <code>Int</code> stating where the vertical lines must be drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/misc.jl#L202-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._reapply_ansi_format!-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractString" href="#PrettyTables._reapply_ansi_format!-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractString"><code>PrettyTables._reapply_ansi_format!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_reapply_ansi_format!(lines::Vector{T}) where T&lt;:AbstractString</code></pre><p>For each line in <code>lines</code>, reapply the ANSI format left by the previous line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L411-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._render_text-Tuple{Val{:print}, Any}" href="#PrettyTables._render_text-Tuple{Val{:print}, Any}"><code>PrettyTables._render_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_render_text(T, v; compact_printing::Bool = true, isstring::Bool = false, limit_printing::Bool = true, linebreaks::Bool = false)</code></pre><p>Render the value <code>v</code> to strings using the rendered <code>T</code> to be displayed in the text back-end.</p><p><code>T</code> can be:</p><ul><li><code>Val(:print)</code>: the function <code>print</code> will be used.</li><li><code>Val(:show)</code>: the function <code>show</code> will be used.</li></ul><p>This function must return a vector of strings in which each element is a line inside the rendered cell.</p><p>If <code>linebreaks</code> is <code>true</code>, then the rendered should split the created string into multiple tokens.</p><p>In case <code>show</code> is used, if <code>isstring</code> is <code>false</code>, then it means that the original data is not a string even if <code>v</code> is a string. Hence, the surrounding quotes added by <code>show</code> will be removed. This is required to correctly handle formatters.</p><p>If <code>limit_printing</code> is <code>true</code>, then <code>v</code> will be converted to string using the property <code>:limit =&gt; true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L90-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_aligned" href="#PrettyTables._str_aligned"><code>PrettyTables._str_aligned</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_str_aligned(data::String, alignment::Symbol, field_size::Integer, lstr::Integer = -1)</code></pre><p>Returns the string <code>data</code> with a specific <code>alignment</code> in a field with size <code>field_size</code>.</p><p><code>alignment</code> can be <code>:l</code> or <code>:L</code> for left alignment, <code>:c</code> or <code>:C</code> for center alignment, or <code>:r</code> or <code>:R</code> for right alignment. It defaults to <code>:r</code> if <code>alignment</code> is any other symbol.</p><p>This function also returns the new size of the aligned string.</p><p>If the string is larger than <code>field_size</code>, then it will be cropped and <code>⋯</code> will be added as the last character.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L189-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_autowrap" href="#PrettyTables._str_autowrap"><code>PrettyTables._str_autowrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_str_autowrap(tokens_raw::Vector{String}, width::Int = 0)</code></pre><p>Autowrap the tokens in <code>tokens_raw</code> considering a field with a specific <code>width</code>. It returns a new vector with the new wrapped tokens.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_compute_alignment_and_crop" href="#PrettyTables._str_compute_alignment_and_crop"><code>PrettyTables._str_compute_alignment_and_crop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_str_compute_alignment_and_crop( data::String, alignment::Symbol, field_size::Integer, lstr::Integer = -1 )</code></pre><p>Return if the string <code>data</code> must be cropped or aligned given a field with field size <code>field_size</code> and a specific <code>alignment</code>.</p><p><code>alignment</code> can be <code>:l</code> or <code>:L</code> for left alignment, <code>:c</code> or <code>:C</code> for center alignment, or <code>:r</code> or <code>:R</code> for right alignment. It defaults to <code>:r</code> if <code>alignment</code> is any other symbol.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p><p><strong>Returns</strong></p><ul><li>The number of characters that must be cropped.</li><li>The left padding.</li><li>The right padding.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/string.jl#L302-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._tokenize_title-Tuple{AbstractString, Int64, Int64, Symbol, Bool, Bool}" href="#PrettyTables._tokenize_title-Tuple{AbstractString, Int64, Int64, Symbol, Bool, Bool}"><code>PrettyTables._tokenize_title</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_tokenize_title(title::AbstractString, display_width::Int, table_width::Int, title_alignment::Symbol, title_autowrap::Bool, title_same_width_as_table::Bool)</code></pre><p>Split the table title into tokens considering the line break character.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/title.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._update_column_width-NTuple{5, Int64}" href="#PrettyTables._update_column_width-NTuple{5, Int64}"><code>PrettyTables._update_column_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_update_column_width(column_width::Int, largest_cell_width::Int, column_width_specification::Int, maximum_column_width::Int, minimum_column_width::Int)</code></pre><p>Compute the column width <code>column_width</code> considering the largest cell width in the column <code>largest_cell_width</code>, the user specification in <code>column_width_specification</code>, and the maximum and minimum allowed column width in <code>maximum_column_width</code> and <code>minimum_column_width</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/misc.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.append_suffix_to_line!-Tuple{CustomTextCell, Int64, String}" href="#PrettyTables.append_suffix_to_line!-Tuple{CustomTextCell, Int64, String}"><code>PrettyTables.append_suffix_to_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append_suffix_to_line!(c::CustomTextCell, l::Int, suffix::String)</code></pre><p>Append the <code>suffix</code> to the line <code>l</code> of the custom cell text <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.apply_line_padding!-Tuple{CustomTextCell, Int64, Int64, Int64}" href="#PrettyTables.apply_line_padding!-Tuple{CustomTextCell, Int64, Int64, Int64}"><code>PrettyTables.apply_line_padding!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_line_padding!(c::CustomTextCell, l::Int, left_pad::Int, right_pad::Int)</code></pre><p>Apply to the line <code>l</code> of the custom text cell <code>c</code> the padding with <code>left_pad</code> spaces in the left and <code>right_pad</code> spaces in the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}" href="#PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}"><code>PrettyTables.clear_pt_conf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_pt_conf!(conf::PrettyTablesConf)</code></pre><p>Clear all configurations in <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/configuration.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.compact_type_str-Tuple{Any}" href="#PrettyTables.compact_type_str-Tuple{Any}"><code>PrettyTables.compact_type_str</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compact_type_str(T)</code></pre><p>Return a string with a compact representation of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/misc.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.crop_line!-Tuple{CustomTextCell, Int64, Int64}" href="#PrettyTables.crop_line!-Tuple{CustomTextCell, Int64, Int64}"><code>PrettyTables.crop_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crop_line!(c::CustomTextCell, l::Int, num::Int)</code></pre><p>Crop <code>num</code> characters from the line <code>l</code> of the custom text cell <code>c</code>. The number of cropped characters must consider the left and right alignment paddings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_latex_sn-Tuple{Int64}" href="#PrettyTables.ft_latex_sn-Tuple{Int64}"><code>PrettyTables.ft_latex_sn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_latex_sn(m_digits, [columns])</code></pre><p>Format the numbers of the elements in the <code>columns</code> to a scientific notation using LaTeX. The number is first printed using <code>sprintf1</code> functions with the <code>g</code> modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument <code>m_digits</code>.</p><p>If <code>m_digits</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>m_digits</code> is a <code>Integer</code>, and <code>columns</code> is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if <code>m_digits</code> is a <code>String</code> and <code>columns</code> is a <code>Vector</code>, then the format will be applied only to the columns in <code>columns</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This formatter will be applied only to the cells that are of type <code>Number</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/predefined_formatters.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_nomissing-Tuple{Missing, Int64, Int64}" href="#PrettyTables.ft_nomissing-Tuple{Missing, Int64, Int64}"><code>PrettyTables.ft_nomissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_nomissing(v, i::Int, j::Int)</code></pre><p>Replace <code>missing</code> with an empty string. If <code>v</code> is not <code>Missing</code>, then <code>v</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/predefined_formatters.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_nonothing-Tuple{Nothing, Int64, Int64}" href="#PrettyTables.ft_nonothing-Tuple{Nothing, Int64, Int64}"><code>PrettyTables.ft_nonothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_nonothing(v, i::Int, j::Int)</code></pre><p>Replace <code>nothing</code> with an empty string. If <code>v</code> is not <code>Nothing</code>, then <code>v</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/predefined_formatters.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_printf-Tuple{String}" href="#PrettyTables.ft_printf-Tuple{String}"><code>PrettyTables.ft_printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_printf(ftv_str, [columns])</code></pre><p>Apply the formats <code>ftv_str</code> (see the function <code>sprintf1</code> of the package <strong>Formatting.jl</strong>) to the elements in the columns <code>columns</code>.</p><p>If <code>ftv_str</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>ftv_str</code> is a <code>String</code>, and <code>columns</code> is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if <code>ftv_str</code> is a <code>String</code> and <code>columns</code> is a <code>Vector</code>, then the format will be applied only to the columns in <code>columns</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This formatter will be applied only to the cells that are of type <code>Number</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/predefined_formatters.jl#L12-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_round-Tuple{Int64}" href="#PrettyTables.ft_round-Tuple{Int64}"><code>PrettyTables.ft_round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_round(digits, [columns])</code></pre><p>Round the elements in the <code>columns</code> to the number of <code>digits</code>.</p><p>If <code>digits</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>digits</code> is a <code>Number</code>, and <code>columns</code> is not specified (or is empty), then the rounding will be applied to the entire table. Otherwise, if <code>digits</code> is a <code>Number</code> and <code>columns</code> is a <code>Vector</code>, then the elements in the columns <code>columns</code> will be rounded to the number of digits <code>digits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/predefined_formatters.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.get_printable_cell_line-Tuple{CustomTextCell, Int64}" href="#PrettyTables.get_printable_cell_line-Tuple{CustomTextCell, Int64}"><code>PrettyTables.get_printable_cell_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_printable_cell_line(c::CustomTextCell, l::Int)</code></pre><p>Return the printable line <code>l</code> of the custom text cell <code>c</code>. The printable cell line must consider the left and right alignment paddings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.get_rendered_line-Tuple{CustomTextCell, Int64}" href="#PrettyTables.get_rendered_line-Tuple{CustomTextCell, Int64}"><code>PrettyTables.get_rendered_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_rendered_line(c::CustomTextCell, l::Int)</code></pre><p>Return the rendered line <code>l</code> of the custom text cell <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_cell-Tuple{Number, Number, Crayon}" href="#PrettyTables.hl_cell-Tuple{Number, Number, Crayon}"><code>PrettyTables.hl_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_cell(i::Number, j::Number, crayon::Crayon)</code></pre><p>Highlight the cell <code>(i,j)</code> with the <code>crayon</code>.</p><pre><code class="language-none">hl_cell(cells::AbstractVector{NTuple(2,Int)}, crayon::Crayon)</code></pre><p>Highlights all the <code>cells</code> with the <code>crayon</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_cell-Tuple{Number, Number, HTMLDecoration}" href="#PrettyTables.hl_cell-Tuple{Number, Number, HTMLDecoration}"><code>PrettyTables.hl_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_cell(i::Number, j::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the cell <code>(i, j)</code> with the <code>decoration</code> (see <a href="#PrettyTables.HTMLDecoration"><code>HTMLDecoration</code></a>).</p><pre><code class="language-none">hl_cell(cells::AbstractVector{NTuple(2,Int)}, decoration::HTMLDecoration)</code></pre><p>Highlights all the <code>cells</code> with the <code>decoration</code> (see <a href="#PrettyTables.HTMLDecoration"><code>HTMLDecoration</code></a>).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_col-Tuple{Number, Crayon}" href="#PrettyTables.hl_col-Tuple{Number, Crayon}"><code>PrettyTables.hl_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_col(i::Number, crayon::Crayon)</code></pre><p>Highlight the entire column <code>i</code> with the <code>crayon</code>.</p><pre><code class="language-none">hl_col(cols::AbstractVector{Int}, crayon::Crayon)</code></pre><p>Highlights all the columns in <code>cols</code> with the <code>crayon</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_col-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_col-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_col(i::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the entire column <code>i</code> with the <code>decoration</code>.</p><pre><code class="language-none">hl_col(cols::AbstractVector{Int}, decoration::HTMLDecoration)</code></pre><p>Highlights all the columns in <code>cols</code> with the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_geq-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_geq-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_geq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_geq(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that are <code>≥ n</code> using the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function returns a <code>HTMLHighlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_geq-Tuple{Number}" href="#PrettyTables.hl_geq-Tuple{Number}"><code>PrettyTables.hl_geq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_geq(n::Number)</code></pre><p>Highlight all elements that <code>≥ n</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_gt-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_gt-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_gt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_gt(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that are <code>&gt; n</code> using the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function returns a <code>HTMLHighlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_gt-Tuple{Number}" href="#PrettyTables.hl_gt-Tuple{Number}"><code>PrettyTables.hl_gt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_gt(n::Number)</code></pre><p>Highlight all elements that are <code>&gt; n</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_leq-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_leq-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_leq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_leq(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that are <code>≤ n</code> using the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function returns a <code>HTMLHighlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L112-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_leq-Tuple{Number}" href="#PrettyTables.hl_leq-Tuple{Number}"><code>PrettyTables.hl_leq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_leq(n::Number)</code></pre><p>Highlight all elements that are <code>≤ n</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_lt-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_lt-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_lt(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that are <code>&lt; n</code> using the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function returns a <code>HTMLHighlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_lt-Tuple{Number}" href="#PrettyTables.hl_lt-Tuple{Number}"><code>PrettyTables.hl_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_lt(n::Number)</code></pre><p>Highlight all elements that are <code>&lt; n</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_row-Tuple{Number, Crayon}" href="#PrettyTables.hl_row-Tuple{Number, Crayon}"><code>PrettyTables.hl_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_row(i::Number, crayon::Crayon)</code></pre><p>Highlight the entire row <code>i</code> with the <code>crayon</code>.</p><pre><code class="language-none">hl_row(rows::AbstractVector{Int}, crayon::Crayon)</code></pre><p>Highlights all the rows in <code>rows</code> with the <code>crayon</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_row-Tuple{Number, HTMLDecoration}" href="#PrettyTables.hl_row-Tuple{Number, HTMLDecoration}"><code>PrettyTables.hl_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_row(i::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the entire row <code>i</code> with the <code>decoration</code>.</p><pre><code class="language-none">hl_row(rows::AbstractVector{Int}, decoration::HTMLDecoration)</code></pre><p>Highlights all the rows in <code>rows</code> with the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_value-Tuple{Any, HTMLDecoration}" href="#PrettyTables.hl_value-Tuple{Any, HTMLDecoration}"><code>PrettyTables.hl_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_value(v::Any, decoration::HTMLDecoration)</code></pre><p>Highlight all the values that matches <code>data[i,j] == v</code> using the <code>decoration</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function returns a <code>HTMLHighlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/html/predefined_highlighters.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_value-Tuple{Any}" href="#PrettyTables.hl_value-Tuple{Any}"><code>PrettyTables.hl_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_value(v::Any)</code></pre><p>Highlight all the values that matches <code>data[i,j] == v</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function return a <code>Highlighter</code> to be used with the text backend.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/predefined_highlighters.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.include_pt_in_file-Tuple{AbstractString, AbstractString, Vararg{Any}}" href="#PrettyTables.include_pt_in_file-Tuple{AbstractString, AbstractString, Vararg{Any}}"><code>PrettyTables.include_pt_in_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">include_pt_in_file(filename::AbstractString, mark::AbstractString, args...; kwargs...)</code></pre><p>Include a table in the file <code>filename</code> using the <code>mark</code>.</p><p>This function will print a table using the arguments <code>args</code> and keywords <code>kwargs</code> in the function <code>pretty_table</code> (<strong>the IO must not be passed to <code>args</code> here</strong>). Then, it will search inside the file <code>filename</code> for the following section:</p><pre><code class="language-none">&lt;PrettyTables mark&gt;
...
&lt;/PrettyTables&gt;</code></pre><p>and will <strong>replace everything between the marks</strong> with the printed table. If the closing tag is in a separate line, then all characters before it will be kept. This is important to add comment tags.</p><p>If the user wants to also remove the opening and ending tags, then pass the keyword <code>remove_tags = true</code>.</p><p>The keyword <code>tag_append</code> can be used to pass a string that can be used to add a text after the opening tag. This is important for HTML where the comments have openning and closing tags. Thus, if <code>tag_append = &quot; --&gt;&quot;</code>, then the following can be used to add a table into HTML files:</p><pre><code class="language-none">&lt;!-- &lt;PrettyTables mark&gt; --&gt;
...
&lt;!-- &lt;/PrettyTables&gt; --&gt;</code></pre><p>By default, this function will copy the original file to <code>filename_backup</code>. If this is not desired, then pass the keyword <code>backup_file = false</code> to the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/files.jl#L12-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.parse_cell_text-Tuple{CustomTextCell}" href="#PrettyTables.parse_cell_text-Tuple{CustomTextCell}"><code>PrettyTables.parse_cell_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_cell_text(c::CustomTextCell; kwargs...)</code></pre><p>Parse the cell text and return a vector of <code>String</code> with the printable cell text, where each element in the vector is a new line.</p><p>The returned data must contain <strong>only</strong> the printable characters.</p><p>The following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of <code>pretty_table</code>, and the user must choose whether or not support them.</p><ul><li><code>autowrap::Bool</code>: If <code>true</code>, the user wants to wrap the text in the cell. In   this case, the option <code>column_width</code> contains the column width so that the   text can be wrapped into multiple lines.</li><li><code>cell_first_line_only::Bool</code>: If <code>true</code>, the user only wants the first line.</li><li><code>column_width::Integer</code>: The column width.</li><li><code>compact_printing::Bool</code>: If <code>true</code>, the user wants compact printing (see   <code>:compact</code> options of <code>IOContext</code>).</li><li><code>limit_printing::Bool</code>: If <code>true</code>, the user wants the cells to be converted   using the option <code>:limit =&gt; true</code> in <code>IOContext</code>.</li><li><code>linebreaks::Bool</code>: If <code>true</code>, the user wants line breaks inside the cells.</li><li><code>renderer::Union{Val{:print}, Val{:show}}</code>: The render that the user wants to   convert the cells to strings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L58-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.pretty_table-Tuple{Any}" href="#PrettyTables.pretty_table-Tuple{Any}"><code>PrettyTables.pretty_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pretty_table([io::IO | String | HTML,] table;  kwargs...)</code></pre><p>Print to <code>io</code> the <code>table</code>.</p><p>If <code>io</code> is omitted, then it defaults to <code>stdout</code>. If <code>String</code> is passed in the place of <code>io</code>, then a <code>String</code> with the printed table will be returned by the function. If <code>HTML</code> is passed in the place of <code>io</code>, then an <code>HTML</code> object is returned with the printed table.</p><p>When printing, it will be verified if <code>table</code> complies with <strong>Tables.jl</strong> API. If it is compliant, then this interface will be used to print the table. If it is not compliant, then only the following types are supported:</p><ol><li><code>AbstractVector</code>: any vector can be printed.</li><li><code>AbstractMatrix</code>: any matrix can be printed.</li><li><code>Dict</code>: any <code>Dict</code> can be printed. In this case, the special keyword  <code>sortkeys</code> can be used to select whether or not the user wants to print the  dictionary with the keys sorted. If it is <code>false</code>, then the elements will be  printed on the same order returned by the functions <code>keys</code> and <code>values</code>.  Notice that this assumes that the keys are sortable, if they are not, then  an error will be thrown.</li></ol><p><strong>Keywords</strong></p><ul><li><code>alignment::Union{Symbol, Vector{Symbol}}</code>: Select the alignment of the   columns (see the section <code>Alignment</code>).</li><li><code>backend::Union{Symbol, T_BACKENDS}</code>: Select which back-end will be used to   print the table (see the section <code>Backend</code>). Notice that the   additional configuration in <code>kwargs...</code> depends on the selected backend.</li><li><code>cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}</code>:   A tuple of functions with the signature <code>f(data, i, j)</code> that overrides the   alignment of the cell <code>(i, j)</code> to the value returned by <code>f</code>. It can also be a   single function, when it is assumed that only one alignment function is   required, or <code>nothing</code>, when no cell alignment modification will be   performed. If the function <code>f</code> does not return a valid alignment symbol as   shown in section <code>Alignment</code>, then it will be discarded. For   convenience, it can also be a dictionary of type <code>(i, j) =&gt; a</code> that   overrides the alignment of the cell <code>(i, j)</code> to <code>a</code>. <code>a</code> must be a symbol   like specified in the section <code>Alignment</code>. (<strong>Default</strong> = <code>nothing</code>)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than one alignment function is passed to <code>cell_alignment</code>, then the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.</p></div></div><ul><li><code>cell_first_line_only::Bool</code>: If <code>true</code>, then only the first line of each cell   will be printed. (<strong>Default</strong> = <code>false</code>)</li><li><code>compact_printing::Bool</code>: Select if the option <code>:compact</code> will be used when   printing the data. (<strong>Default</strong> = <code>true</code>)</li><li><code>filters_row::Union{Nothing, Tuple}</code>: Filters for the rows (see the section   <code>Filters</code>).</li><li><code>filters_col::Union{Nothing, Tuple}</code>: Filters for the columns (see the section   <code>Filters</code>).</li><li><code>formatters::Union{Nothing, Function, Tuple}</code>: See the section   <code>Formatters</code>.</li><li><code>header::Union{Symbol, Vector{Symbol}}</code>: The header must be a tuple of   vectors. Each one must have the number of elements equal to the number of   columns in the table. The first vector is considered the header and the   others are the subheaders. If it is <code>nothing</code>, then a default value based on   the type will be used. If a single vector is passed, then it will be   considered the header. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>header_alignment::Union{Symbol, Vector{Symbol}}</code>: Select the alignment of the   header columns (see the section <code>Alignment</code>). If the symbol that   specifies the alignment is <code>:s</code> for a specific column, then the same   alignment in the keyword <code>alignment</code> for that column will be used.   (<strong>Default</strong> = <code>:s</code>)</li><li><code>header_cell_alignment::Union{Nothing, Dict{Tuple{Int, Int}, Symbol}, Function, Tuple}</code>:   This keyword has the same structure of <code>cell_alignment</code> but in this case it   operates in the header. Thus, <code>(i, j)</code> will be a cell in the header matrix   that contains the header and sub-headers. This means that the <code>data</code> field   in the functions will be the same value passed in the keyword <code>header</code>.   (<strong>Default</strong> = <code>nothing</code>)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than one alignment function is passed to <code>header_cell_alignment</code>,   then the functions will be evaluated in the same order of the tuple. The   first one that returns a valid alignment symbol for each cell is applied,   and the rest is discarded.</p></div></div><ul><li><code>limit_printing::Bool</code>: If <code>true</code>, then the cells will be converted using the   property <code>:limit =&gt; true</code> of <code>IOContext</code>. (<strong>Default</strong> = <code>true</code>)</li><li><code>renderer::Symbol</code>: A symbol that indicates which function should be used to   convert an object to a string. It can be <code>:print</code> to use the function   <code>print</code> or <code>:show</code> to use the function <code>show</code>. Notice that this selection is   applicable only to the table data. Headers, sub-headers, and row name column   are always rendered with print. (<strong>Default</strong> = <code>:print</code>)</li><li><code>row_names::Union{Nothing, AbstractVector}</code>: A vector containing the row names   that will be appended to the left of the table. If it is <code>nothing</code>, then the   column with the row names will not be shown. Notice that the size of this   vector must match the number of rows in the table. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>row_name_alignment::Symbol</code>: Alignment of the column with the rows name (see   the section <code>Alignment</code>).</li><li><code>row_name_column_title::AbstractString</code>: Title of the column with the row   names. (<strong>Default</strong> = &quot;&quot;)</li><li><code>row_number_column_title::AbstractString</code>: Title of the column with the row   numbers. (<strong>Default</strong> = &quot;Row&quot;)</li><li><code>show_row_number::Bool</code>: If <code>true</code>, then a new column will be printed showing   the row number. (<strong>Default</strong> = <code>false</code>)</li><li><code>title::AbstractString</code>: The title of the table. If it is empty, then no title   will be printed. (<strong>Default</strong> = &quot;&quot;)</li><li><code>title_alignment::Symbol</code>: Alignment of the title, which must be a symbol as   explained in the section <code>Alignment</code>. This argument is ignored in the   LaTeX backend. (<strong>Default</strong> = :l)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Notice that all back-ends have the keyword <code>tf</code> to specify the table printing format. Thus, if the keyword <code>backend</code> is not present or if it is <code>nothing</code>, then the back-end will be automatically inferred from the type of the keyword <code>tf</code>. In this case, if <code>tf</code> is also not present, then it just fall-back to the text back-end unless <code>HTML</code> is passed as the first argument. In this case, the default back-end is set to HTML.</p></div></div><p>If <code>String</code> is used, then the keyword <code>color</code> selects whether or not the table will be converted to string with or without colors. The default value is <code>false</code>. Notice that this option only has effect in text backend.</p><p><strong>Alignment</strong></p><p>The keyword <code>alignment</code> can be a <code>Symbol</code> or a vector of <code>Symbol</code>.</p><p>If it is a symbol, we have the following behavior:</p><ul><li><code>:l</code> or <code>:L</code>: the text of all columns will be left-aligned;</li><li><code>:c</code> or <code>:C</code>: the text of all columns will be center-aligned;</li><li><code>:r</code> or <code>:R</code>: the text of all columns will be right-aligned;</li><li>Otherwise it defaults to <code>:r</code>.</li></ul><p>If it is a vector, then it must have the same number of symbols as the number of columns in <code>data</code>. The <em>i</em>-th symbol in the vector specify the alignment of the -i*-th column using the same symbols as described previously.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In HTML backend, the user can select <code>:n</code> ou <code>:N</code> to print the cell without any alignment annotation.</p></div></div><p><strong>Filters</strong></p><p>It is possible to specify filters to filter the data that will be printed. There are two types of filters: the row filters, which are specified by the keyword <code>filters_row</code>, and the column filters, which are specified by the keyword <code>filters_col</code>.</p><p>The filters are a tuple of functions that must have the following signature:</p><pre><code class="language-julia">f(data,i)::Bool</code></pre><p>in which <code>data</code> is a pointer to the matrix that is being printed and <code>i</code> is the i-th row in the case of the row filters or the i-th column in the case of column filters. If this function returns <code>true</code> for <code>i</code>, then the i-th row (in case of <code>filters_row</code>) or the i-th column (in case of <code>filters_col</code>) will be printed. Otherwise, it will be omitted.</p><p>A set of filters can be passed inside of a tuple. Notice that, in this case, <strong>all filters</strong> for a specific row or column must be return <code>true</code> so that it can be printed, <em>i.e</em> the set of filters has an <code>AND</code> logic.</p><p>If the keyword is set to <code>nothing</code>, which is the default, then no filtering will be applied to the data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The filters do not change the row and column numbering for the others modifiers such as column width specification, formatters, and highlighters. Thus, for example, if only the 4-th row is printed, then it will also be referenced inside the formatters and highlighters as 4 instead of 1.</p></div></div><hr/><p><strong>Pretty table text back-end</strong></p><p>This back-end produces text tables. This back-end can be used by selecting <code>back-end = :text</code>.</p><p><strong>Keywords</strong></p><ul><li><code>border_crayon::Crayon</code>: Crayon to print the border.</li><li><code>header_crayon::Union{Crayon, Vector{Crayon}}</code>: Crayon to print the header.</li><li><code>subheader_crayon::Union{Crayon, Vector{Crayon}}</code>: Crayon to print   sub-headers.</li><li><code>rownum_header_crayon::Crayon</code>: Crayon for the header of the column with the   row numbers.</li><li><code>text_crayon::Crayon</code>: Crayon to print default text.</li><li><code>omitted_cell_summary_crayon::Crayon</code>: Crayon used to print the omitted cell   summary.</li><li><code>alignment_anchor_fallback::Symbol</code>: This keyword controls the line alignment   when using the regex alignment anchors if a match is not found. If it is   <code>:l</code>, then the left of the line will be aligned with the anchor. If it is   <code>:c</code>, then the line center will be aligned with the anchor. Otherwise, the   end of the line will be aligned with the anchor. (<strong>Default</strong> = <code>:l</code>)</li><li><code>alignment_anchor_fallback_override::Dict{Int, Symbol}</code>: A <code>Dict{Int, Symbol}</code>   to override the behavior of <code>fallback_alignment_anchor</code> for a specific   column. Example: <code>Dict(3 =&gt; :c)</code> changes the fallback alignment anchor   behavior for <code>:c</code> only for the column 3.</li><li><code>alignment_anchor_regex::Dict{Int, AbstractVector{Regex}}</code>: A dictionary   <code>Dict{Int, AbstractVector{Regex}}</code> with a set of regexes that is used to   align the values in the columns (keys). The characters at the first regex   match (or anchor) of each line in every cell of the column will be aligned.   The regex match is searched in the same order as the regexes appear on the   vector. The regex matching is applied after the cell conversion to string,   which includes the formatters. If no match is found for a specific line,   then the alignment of this line depends on the options   <code>alignment_anchor_fallback</code> and <code>alignment_anchor_fallback_override</code>. If the   key <code>0</code> is present, then the related regexes will be used to align all the   columns. In this case, all the other keys will be neglected. Example:   <code>Dict(2 =&gt; [r&quot;\.&quot;])</code> aligns the decimal point of the cells in the second   column. (<strong>Default</strong> = <code>Dict{Int, Vector{Regex}}()</code>)</li><li><code>autowrap::Bool</code>: If <code>true</code>, then the text will be wrapped on spaces to fit   the column. Notice that this function requires <code>linebreaks = true</code> and the   column must have a fixed size (see <code>columns_width</code>).</li><li><code>body_hlines::Vector{Int}</code>: A vector of <code>Int</code> indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 1 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in <code>hlines</code>, but   the indices here are related to the printed rows of the body. Thus, if <code>1</code>   is added to <code>body_hlines</code>, then a horizontal line will be drawn after the   first data row. (<strong>Default</strong> = <code>Int[]</code>)</li><li><code>body_hlines_format::Union{Nothing, NTuple{4, Char}}</code>: A tuple of 4 characters   specifying the format of the horizontal lines that will be drawn by   <code>body_hlines</code>. The characters must be the left intersection, the middle   intersection, the right intersection, and the row. If it is <code>nothing</code>, then   it will use the same format specified in <code>tf</code>. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers specifying   the width of each column. If the width is equal or lower than 0, then it   will be automatically computed to fit the large cell in the column. If it is   a single integer, then this number will be used as the size of all columns.   (<strong>Default</strong> = 0)</li><li><code>crop::Symbol</code>: Select the printing behavior when the data is bigger than the   available display size (see <code>display_size</code>). It can be <code>:both</code> to crop on   vertical and horizontal direction, <code>:horizontal</code> to crop only on horizontal   direction, <code>:vertical</code> to crop only on vertical direction, or <code>:none</code> to do   not crop the data at all. If the <code>io</code> has <code>:limit =&gt; true</code>, then <code>crop</code> is   set to <code>:both</code> by default. Otherwise, it is set to <code>:none</code> by default.</li><li><code>crop_num_lines_at_beginning::Int</code>: Number of lines to be left at the   beginning of the printing when vertically cropping the output. Notice that   the lines required to show the title are automatically computed.   (<strong>Default</strong> = 0)</li><li><code>crop_subheader::Bool</code>: If <code>true</code>, then the sub-header size will not be taken   into account when computing the column size. Hence, the print algorithm can   crop it to save space. This has no effect if the user selects a fixed column   width. (<strong>Default</strong> = <code>false</code>)</li><li><code>continuation_row_alignment::Symbol</code>: A symbol that defines the alignment of   the cells in the continuation row. This row is printed if the table is   vertically cropped. (<strong>Default</strong> = <code>:c</code>)</li><li><code>display_size::Tuple{Int, Int}</code>: A tuple of two integers that defines the   display size (num. of rows, num. of columns) that is available to print the   table. It is used to crop the data depending on the value of the keyword   <code>crop</code>. Notice that if a dimension is not positive, then it will be treated   as unlimited. (<strong>Default</strong> = <code>displaysize(io)</code>)</li><li><code>ellipsis_line_skip::Integer</code>: An integer defining how many lines will be   skipped from showing the ellipsis that indicates the text was cropped.   (<strong>Default</strong> = 0)</li><li><code>equal_columns_width::Bool</code>: If <code>true</code>, then all the columns will have the   same width. (<strong>Default</strong> = <code>false</code>)</li><li><code>highlighters::Union{Highlighter, Tuple}</code>: An instance of <code>Highlighter</code> or a   tuple with a list of text highlighters (see the section <code>Text   highlighters</code>).</li><li><code>hlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where   the horizontal lines will be drawn. It can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or   a vector of integers. (<strong>Default</strong> = <code>nothing</code>)<ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be   obtained from the table format in the variable <code>tf</code> (see   <a href="#PrettyTables.TextFormat"><code>TextFormat</code></a>).</li><li>If it is <code>:all</code>, then all horizontal lines will be drawn.</li><li>If it is <code>:none</code>, then no horizontal line will be drawn.</li><li>If it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if <code>0</code> is in <code>hlines</code>, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the <strong>printed rows</strong>.   Thus, it is affected by filters, and by the option to suppress the   header <code>noheader</code>. Finally, for convenience, the top and bottom lines   can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector,   respectively, and the line after the header can be drawn by adding the   symbol <code>:header</code>.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The values of <code>body_hlines</code> will be appended to this vector. Thus, horizontal lines can be drawn even if <code>hlines</code> is <code>:none</code>.</p></div></div><ul><li><code>linebreaks::Bool</code>: If <code>true</code>, then <code>\n</code> will break the line inside the   cells. (<strong>Default</strong> = <code>false</code>)</li><li><code>maximum_columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers   specifying the maximum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the maximum width of all columns. Notice that the parameter   <code>columns_width</code> has precedence over this one. (<strong>Default</strong> = 0)</li><li><code>minimum_columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers   specifying the minimum width of each column. If the width is equal or lower   than 0, then it will be ignored. If it is a single integer, then this number   will be used as the minimum width of all columns. Notice that the parameter   <code>columns_width</code> has precedence over this one. (<strong>Default</strong> = 0)</li><li><code>newline_at_end::Bool</code>: If <code>false</code>, then the table will not end with a newline   character. (<strong>Default</strong> = <code>true</code>)</li><li><code>noheader::Bool</code>: If <code>true</code>, then the header will not be printed. Notice that   all keywords and parameters related to the header and sub-headers will be   ignored. (<strong>Default</strong> = <code>false</code>)</li><li><code>nosubheader::Bool</code>: If <code>true</code>, then the sub-header will not be printed,   <em>i.e.</em> the header will contain only one line. Notice that this option has no   effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</li><li><code>overwrite::Bool</code>: If <code>true</code>, then the same number of lines in the printed   table will be deleted from the output <code>io</code>. This can be used to update the   table in the display continuously. (<strong>Default</strong> = <code>false</code>)</li><li><code>row_number_alignment::Symbol</code>: Select the alignment of the row number column   (see the section <code>Alignment</code>). (<strong>Default</strong> = <code>:r</code>)</li><li><code>show_omitted_cell_summary::Bool</code>: If <code>true</code>, then a summary will be printed   after the table with the number of columns and rows that were omitted.   (<strong>Default</strong> = <code>true</code>)</li><li><code>tf::TextFormat</code>: Table format used to print the table (see   <a href="#PrettyTables.TextFormat"><code>TextFormat</code></a>). (<strong>Default</strong> = <code>tf_unicode</code>)</li><li><code>title_autowrap::Bool</code>: If <code>true</code>, then the title text will be wrapped   considering the title size. Otherwise, lines larger than the title size will   be cropped. (<strong>Default</strong> = <code>false</code>)</li><li><code>title_crayon::Crayon</code>: Crayon to print the title.</li><li><code>title_same_width_as_table::Bool</code>: If <code>true</code>, then the title width will match   that of the table. Otherwise, the title size will be equal to the display   width. (<strong>Default</strong> = <code>false</code>)</li><li><code>vcrop_mode::Symbol</code>: This variable defines the vertical crop behavior. If it   is <code>:bottom</code>, then the data, if required, will be cropped in the bottom. On   the other hand, if it is <code>:middle</code>, then the data will be cropped in the   middle if necessary. (<strong>Default</strong> = <code>:bottom</code>)</li><li><code>vlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where   the vertical lines will be drawn. It can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a   vector of integers. (<strong>Default</strong> = <code>nothing</code>)<ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be   obtained from the table format in the variable <code>tf</code> (see   <a href="#PrettyTables.TextFormat"><code>TextFormat</code></a>).</li><li>If it is <code>:all</code>, then all vertical lines will be drawn.</li><li>If it is <code>:none</code>, then no vertical line will be drawn.</li><li>If it is a vector of integers, then the vertical lines will be drawn only   after the columns in the vector. Notice that the top line will be drawn   if <code>0</code> is in <code>vlines</code>. Furthermore, it is important to mention that the   column number in this variable is related to the <strong>printed column</strong>.   Thus, it is affected by filters, and by the options <code>row_names</code> and   <code>show_row_number</code>. Finally, for convenience, the left and right vertical   lines can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this   vector, respectively, and the line after the header can be drawn by   adding the symbol <code>:header</code>.</li></ul></li></ul><p>The keywords <code>header_crayon</code> and <code>subheader_crayon</code> can be a <code>Crayon</code> or a <code>Vector{Crayon}</code>. In the first case, the <code>Crayon</code> will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.</p><p><strong>Crayons</strong></p><p>A <code>Crayon</code> is an object that handles a style for text printed on terminals. It is defined in the package <a href="https://github.com/KristofferC/Crayons.jl">Crayons.jl</a>. There are many options available to customize the style, such as foreground color, background color, bold text, etc.</p><p>A <code>Crayon</code> can be created in two different ways:</p><pre><code class="language-julia-repl">julia&gt; Crayon(foreground = :blue, background = :black, bold = :true)

julia&gt; crayon&quot;blue bg:black bold&quot;</code></pre><p>For more information, see the package documentation.</p><p><strong>Text highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <code>Highlighter</code> that contains three fields:</p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should   return <code>true</code> if the element <code>(i, j)</code> in <code>data</code> must be highlighter, or   <code>false</code> otherwise.</li><li><code>fd::Function</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is   the highlighter. This function must return the <code>Crayon</code> to be applied to the   cell that must be highlighted.</li><li><code>crayon::Crayon</code>: The <code>Crayon</code> to be applied to the highlighted cell if the   default <code>fd</code> is used.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, and <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the cell <code>(i, j)</code> will be highlighted.</p><p>If the function <code>f</code> returns true, then the function <code>fd(h, data, i, j)</code> will be called and must return a <code>Crayon</code> that will be applied to the cell.</p><p>A highlighter can be constructed using three helpers:</p><pre><code class="language-none">Highlighter(f::Function; kwargs...)</code></pre><p>where it will construct a <code>Crayon</code> using the keywords in <code>kwargs</code> and apply it to the highlighted cell,</p><pre><code class="language-none">Highlighter(f::Function, crayon::Crayon)</code></pre><p>where it will apply the <code>crayon</code> to the highlighted cell, and</p><pre><code class="language-none">Highlighter(f::Function, fd::Function)</code></pre><p>where it will apply the <code>Crayon</code> returned by the function <code>fd</code> to the highlighted cell.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i, j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Pretty table HTML backend</strong></p><p>This backend produces HTML tables. This backend can be used by selecting <code>backend = Val(:html)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>allow_html_in_cells::Bool</code>: By default, special characters like <code>&lt;</code>, <code>&gt;</code>,   <code>&quot;</code>, etc. are replaced in HTML backend to generate valid code. However, this   algorithm blocks the usage of HTML code inside of the cells. If this keyword   is <code>true</code>, then the escape algorithm <strong>will not</strong> be applied, allowing HTML   code inside all the cells. In this case, the user must ensure that the   output code is valid. (<strong>Default</strong> = <code>false</code>)</li><li><code>highlighters::Union{HTMLHighlighter, Tuple}</code>: An instance of   <a href="#PrettyTables.HTMLHighlighter"><code>HTMLHighlighter</code></a> or a tuple with a list of HTML highlighters (see   the section <code>HTML highlighters</code>).</li><li><code>linebreaks::Bool</code>: If <code>true</code>, then <code>\n</code> will be replaced by <code>&lt;br&gt;</code>.   (<strong>Default</strong> = <code>false</code>)</li><li><code>minify::Bool</code>: If <code>true</code>, then output will be displayed minified, <em>i.e.</em>   without unnecessary indentation or newlines. (<strong>Default</strong> = <code>false</code>)</li><li><code>noheader::Bool</code>: If <code>true</code>, then the header will not be printed. Notice that   all keywords and parameters related to the header and sub-headers will be   ignored. (<strong>Default</strong> = <code>false</code>)</li><li><code>nosubheader::Bool</code>: If <code>true</code>, then the sub-header will not be printed,   <em>i.e.</em> the header will contain only one line. Notice that this option has no   effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</li><li><code>standalone::Bool</code>: If <code>true</code>, then a complete HTML page will be generated.   Otherwise, only the content between the tags <code>&lt;table&gt;</code> and <code>&lt;/table&gt;</code> will   be printed (with the tags included). (<strong>Default</strong> = <code>true</code>)</li><li><code>tf::HTMLTableFormat</code>: An instance of the structure <a href="#PrettyTables.HTMLTableFormat"><code>HTMLTableFormat</code></a>   that defines the general format of the HTML table.</li></ul><p><strong>HTML highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <a href="#PrettyTables.HTMLHighlighter"><code>HTMLHighlighter</code></a>. It contains the following two public fields:</p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should   return <code>true</code> if the element <code>(i,j)</code> in <code>data</code> must be highlighted, or   <code>false</code> otherwise.</li><li><code>fd::Function</code>: Function with the signature <code>f(h, data, i, j)</code> in which <code>h</code> is   the highlighter. This function must return the <code>HTMLDecoration</code> to be   applied to the cell that must be highlighted.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, and <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the highlight style will be applied to the <code>(i, j)</code> element. Otherwise, the default style will be used.</p><p>If the function <code>f</code> returns true, then the function <code>fd(h, data, i, j)</code> will be called and must return an element of type <a href="#PrettyTables.HTMLDecoration"><code>HTMLDecoration</code></a> that contains the decoration to be applied to the cell.</p><p>A HTML highlighter can be constructed using two helpers:</p><pre><code class="language-none">HTMLHighlighter(f::Function, decoration::HTMLDecoration)

HTMLHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply a fixed decoration to the highlighted cell specified in <code>decoration</code> whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i, j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Pretty table LaTeX backend</strong></p><p>This backend produces LaTeX tables. This backend can be used by selecting <code>backend = Val(:latex)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>body_hlines::Vector{Int}</code>: A vector of <code>Int</code> indicating row numbers in which   an additional horizontal line should be drawn after the row. Notice that   numbers lower than 1 and equal or higher than the number of printed rows   will be neglected. This vector will be appended to the one in <code>hlines</code>, but   the indices here are related to the printed rows of the body. Thus, if <code>1</code>   is added to <code>body_hlines</code>, then a horizontal line will be drawn after the   first data row. (<strong>Default</strong> = <code>Int[]</code>)</li><li><code>highlighters::Union{LatexHighlighter, Tuple}</code>: An instance of   <code>LatexHighlighter</code> or a tuple with a list of LaTeX highlighters (see the   section <code>LaTeX highlighters</code>).</li><li><code>hlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where   the horizontal lines will be drawn. It can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or   a vector of integers. (<strong>Default</strong> = <code>nothing</code>)<ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be   obtained from the table format in the variable <code>tf</code> (see   <a href="#PrettyTables.LatexTableFormat"><code>LatexTableFormat</code></a>).</li><li>If it is <code>:all</code>, then all horizontal lines will be drawn.</li><li>If it is <code>:none</code>, then no horizontal line will be drawn.</li><li>If it is a vector of integers, then the horizontal lines will be drawn   only after the rows in the vector. Notice that the top line will be   drawn if <code>0</code> is in <code>hlines</code>, and the header and subheaders are   considered as only 1 row. Furthermore, it is important to mention that   the row number in this variable is related to the <strong>printed rows</strong>.   Thus, it is affected by filters, and by the option to suppress the   header <code>noheader</code>. Finally, for convenience, the top and bottom lines   can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector,   respectively, and the line after the header can be drawn by adding the   symbol <code>:header</code>.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The values of <code>body_hlines</code> will be appended to this vector. Thus, horizontal lines can be drawn even if <code>hlines</code> is <code>:none</code>.</p></div></div><ul><li><code>label::AbstractString</code>: The label of the table. If empty, then no label will   be added. (<strong>Default</strong> = &quot;&quot;)</li><li><code>longtable_footer::Union{Nothing, AbstractString}</code>: The string that will be   drawn in the footer of the tables before a page break. This only works if   <code>table_type</code> is <code>:longtable</code>. If it is <code>nothing</code>, then no footer will be   used. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>noheader::Bool</code>: If <code>true</code>, then the header will not be printed. Notice that   all keywords and parameters related to the header and sub-headers will be   ignored. (<strong>Default</strong> = <code>false</code>)</li><li><code>nosubheader::Bool</code>: If <code>true</code>, then the sub-header will not be printed,   <em>i.e.</em> the header will contain only one line. Notice that this option has no   effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</li><li><code>row_number_alignment::Symbol</code>: Select the alignment of the row number column   (see the section <code>Alignment</code>). (<strong>Default</strong> = <code>:r</code>)</li><li><code>table_type::Union{Nothing, Symbol}</code>: Select which LaTeX environment will be   used to print the table. Currently supported options are <code>:tabular</code> for   <code>tabular</code> or <code>:longtable</code> for <code>longtable</code>. If it is <code>nothing</code> then the   default option of the table format will be used. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>tf::LatexTableFormat</code>: An instance of the structure   <a href="#PrettyTables.LatexTableFormat"><code>LatexTableFormat</code></a> that defines the general format of the LaTeX table.</li><li><code>vlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where   the vertical lines will be drawn. It can be <code>:all</code>, <code>:none</code> or a vector of   integers. In the first case (the default behavior), all vertical lines will   be drawn. In the second case, no vertical line will be drawn. In the third   case, the vertical lines will be drawn only after the columns in the vector.   Notice that the left border will be drawn if <code>0</code> is in <code>vlines</code>.   Furthermore, it is important to mention that the column number in this   variable is related to the <strong>printed columns</strong>. Thus, it is affected by   filters, and by the columns added using the variable <code>show_row_number</code>.   Finally, for convenience, the left and right border can be drawn by adding   the symbols <code>:begin</code> and <code>:end</code> to this vector, respectively.   (<strong>Default</strong> = <code>:none</code>)</li><li><code>wrap_table::Union{Nothing, String}</code>: This variable controls whether to wrap   the table in a environment defined by the variable <code>wrap_table_environment</code>.   Defaults to <code>true</code>. When <code>false</code>, the printed table begins with   <code>\begin{tabular}</code>. This option does not work with <code>:longtable</code>. If it is   <code>nothing</code> then the default option of the table format will be used.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>wrap_table_environment::Union{Nothing, String}</code>: Environment that will be   used to wrap the table if the option <code>wrap_table</code> is <code>true</code>. If it is   <code>nothing</code> then the default option of the table format will be used.   (<strong>Default</strong> = <code>nothing</code>)</li></ul><p><strong>LaTeX highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <a href="#PrettyTables.LatexHighlighter"><code>LatexHighlighter</code></a>. It contains the following two fields:</p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should   return <code>true</code> if the element <code>(i, j)</code> in <code>data</code> must be highlighted, or   <code>false</code> otherwise.</li><li><code>fd::Functions</code>: A function with the signature <code>f(data, i, j, str)::String</code> in   which <code>data</code> is the matrix, <code>(i, j)</code> is the element position in the table,   and <code>str</code> is the data converted to string. This function must return a   string that will be placed in the cell.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the highlight style will be applied to the <code>(i, j)</code> element. Otherwise, the default style will be used.</p><p>If the function <code>f</code> returns true, then the function <code>fd(data, i, j, str)</code> will be called and must return the LaTeX string that will be placed in the cell.</p><p>There are two helpers that can be used to create LaTeX highlighters:</p><pre><code class="language-none">LatexHighlighter(f::Function, envs::Union{String,Vector{String}})

LatexHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply recursively all the LaTeX environments in <code>envs</code> to the highlighted text whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><p>Thus, for example:</p><pre><code class="language-none">LatexHighlighter((data, i, j) -&gt; true, [&quot;textbf&quot;, &quot;small&quot;])</code></pre><p>will wrap all the cells in the table in the following environment:</p><pre><code class="language-none">\textbf{\small{&lt;Cell text&gt;}}</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i, j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Formatters</strong></p><p>The keyword <code>formatters</code> can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:</p><pre><code class="language-none">f(v, i, j)</code></pre><p>where <code>v</code> is the value in the cell, <code>i</code> is the row number, and <code>j</code> is the column number. Thus, it must return the formatted value of the cell <code>(i, j)</code> that has the value <code>v</code>. Notice that the returned value will be converted to string after using the function <code>sprint</code>.</p><p>This keyword can also be a single function, meaning that only one formatter is available, or <code>nothing</code>, meaning that no formatter will be used.</p><p>For example, if we want to multiply all values in odd rows of the column 2 by π, then the formatter should look like:</p><pre><code class="language-none">formatters = (v, i, j) -&gt; (j == 2 &amp;&amp; isodd(i)) ? v * π : v</code></pre><p>If multiple formatters are available, then they will be applied in the same order as they are located in the tuple. Thus, for the following <code>formatters</code>:</p><pre><code class="language-none">formatters = (f1, f2, f3)</code></pre><p>each element <code>v</code> in the table (i-th row and j-th column) will be formatted by:</p><pre><code class="language-none">v = f1(v,i,j)
v = f2(v,i,j)
v = f3(v,i,j)</code></pre><p>Thus, the user must be ensure that the type of <code>v</code> between the calls are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/print.jl#L16-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf, Vararg{Any}}" href="#PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf, Vararg{Any}}"><code>PrettyTables.pretty_table_with_conf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...)</code></pre><p>Call <code>pretty_table</code> using the default configuration in <code>conf</code>. The <code>args...</code> and <code>kwargs...</code> can be the same as those passed to <code>pretty_tables</code>. Notice that all the configurations in <code>kwargs...</code> will overwrite the ones in <code>conf</code>.</p><p>The object <code>conf</code> can be created by the function <code>set_pt_conf</code> in which the keyword parameters can be any one supported by the function <code>pretty_table</code> as shown in the following.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/configuration.jl#L16-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.reset!-Tuple{CustomTextCell}" href="#PrettyTables.reset!-Tuple{CustomTextCell}"><code>PrettyTables.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset!(c::CustomTextCell)</code></pre><p>Reset all fields in the custom text cell <code>c</code>.</p><p>This function is not required for the API. It is called before parsing the custom text cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/backends/text/custom_text_cells/custom_text_cell.jl#L88-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}" href="#PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}"><code>PrettyTables.set_pt_conf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_pt_conf!(conf; kwargs...)</code></pre><p>Apply the configurations in <code>kwargs</code> to the object <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/configuration.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.set_pt_conf-Tuple{}" href="#PrettyTables.set_pt_conf-Tuple{}"><code>PrettyTables.set_pt_conf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_pt_conf(;kwargs...)</code></pre><p>Create a new configuration object based on the arguments in <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/configuration.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@pt-Tuple" href="#PrettyTables.@pt-Tuple"><code>PrettyTables.@pt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pt(expr...)</code></pre><p>Pretty print tables in <code>expr</code> to <code>stdout</code> using the global configurations selected with the macro <code>@ptconf</code>.</p><p>Multiple tables can be printed by passing multiple expressions like:</p><pre><code class="language-none">@pt table1 table2 table3</code></pre><p>The user can select the table header by passing the expression:</p><pre><code class="language-none">:header = [&lt;Vector with the header&gt;]</code></pre><p>Notice that the header is valid only for the next printed table. Hence:</p><pre><code class="language-none">@pt :header = header1 table1 :header = header2 table2 table3</code></pre><p>will print <code>table1</code> using <code>header1</code>, <code>table2</code> using <code>header2</code>, and <code>table3</code> using the default header.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>When more than one table is passed to this macro, then multiple calls to <code>pretty_table</code> will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @ptconf tf = tf_simple

julia&gt; @pt :header = [&quot;Time&quot;,&quot;Velocity&quot;] [1:1:10 ones(10)] :header = [&quot;Time&quot;,&quot;Position&quot;] [1:1:10 1:1:10]
======= ===========
  Time   Velocity
======= ===========
   1.0        1.0
   2.0        1.0
   3.0        1.0
   4.0        1.0
   5.0        1.0
   6.0        1.0
   7.0        1.0
   8.0        1.0
   9.0        1.0
  10.0        1.0
======= ===========
======= ===========
  Time   Position
======= ===========
     1          1
     2          2
     3          3
     4          4
     5          5
     6          6
     7          7
     8          8
     9          9
    10         10
======= ===========

julia&gt; @pt ones(3,3) + I + [1 2 3; 4 5 6; 7 8 9]
========= ======== =========
  Col. 1   Col. 2   Col. 3
========= ======== =========
     3.0      3.0      4.0
     5.0      7.0      7.0
     8.0      9.0     11.0
========= ======== =========</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/helpers.jl#L58-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@ptconf-Tuple" href="#PrettyTables.@ptconf-Tuple"><code>PrettyTables.@ptconf</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ptconf(expr...)</code></pre><p>Add configurations in <code>expr</code> to be used with the macro <code>@pt</code>.</p><p>The expression format must be:</p><pre><code class="language-none">keyword1 = value1 keyword2 = value2 ...</code></pre><p>in which the keywords can be any other possible keyword that can be used in the function <code>pretty_table</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If a keyword is not supported by the function <code>pretty_table</code>, then no error message is printed when calling <code>@ptconf</code>. However, an error will be thrown when <code>@pt</code> is called.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/helpers.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@ptconfclean-Tuple{}" href="#PrettyTables.@ptconfclean-Tuple{}"><code>PrettyTables.@ptconfclean</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ptconfclean()</code></pre><p>Clean all global configurations to pretty print tables using the macro <code>@pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/aae6fae45d922e395b5a39b5ba81f93b2f03e51e/src/helpers.jl#L15-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/html_examples/">« HTML back-end</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 20 December 2021 12:54">Monday 20 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
