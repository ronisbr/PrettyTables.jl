<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Text · Pretty Tables</title><meta name="title" content="Text · Pretty Tables"/><meta property="og:title" content="Text · Pretty Tables"/><meta property="twitter:title" content="Text · Pretty Tables"/><meta name="description" content="Documentation for Pretty Tables."/><meta property="og:description" content="Documentation for Pretty Tables."/><meta property="twitter:description" content="Documentation for Pretty Tables."/><meta property="og:url" content="https://ronisbr.github.io/PrettyTables.jl/stable/man/text_backend/"/><meta property="twitter:url" content="https://ronisbr.github.io/PrettyTables.jl/stable/man/text_backend/"/><link rel="canonical" href="https://ronisbr.github.io/PrettyTables.jl/stable/man/text_backend/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Pretty Tables logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Pretty Tables</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><span class="tocitem">Back Ends</span><ul><li class="is-active"><a class="tocitem" href>Text</a><ul class="internal"><li><a class="tocitem" href="#Crayons"><span>Crayons</span></a></li><li><a class="tocitem" href="#Cropping"><span>Cropping</span></a></li><li><a class="tocitem" href="#Text-Highlighters"><span>Text Highlighters</span></a></li><li><a class="tocitem" href="#Text-Table-Formats"><span>Text Table Formats</span></a></li><li><a class="tocitem" href="#Custom-Text-Cells"><span>Custom Text Cells</span></a></li></ul></li><li><a class="tocitem" href="../html_backend/">HTML</a></li><li><a class="tocitem" href="../latex_backend/">LaTeX</a></li><li><a class="tocitem" href="../markdown_backend/">Markdown</a></li></ul></li><li><a class="tocitem" href="../alignment/">Alignment</a></li><li><a class="tocitem" href="../formatters/">Formatters</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../text_examples/">Text Back End</a></li><li><a class="tocitem" href="../html_examples/">HTML Back End</a></li></ul></li><li><a class="tocitem" href="../../lib/library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Back Ends</a></li><li class="is-active"><a href>Text</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Text</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ronisbr/PrettyTables.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ronisbr/PrettyTables.jl/blob/master/docs/src/man/text_backend.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Text-Back-end"><a class="docs-heading-anchor" href="#Text-Back-end">Text Back end</a><a id="Text-Back-end-1"></a><a class="docs-heading-anchor-permalink" href="#Text-Back-end" title="Permalink"></a></h1><p>The following options are available when the text back end is used. Those can be passed as keywords when calling the function <code>pretty_table</code>:</p><ul><li><code>alignment_anchor_fallback::Symbol</code>: This keyword controls the line alignment when using   the regex alignment anchors if a match is not found. If it is <code>:l</code>, the left of the line   will be aligned with the anchor. If it is <code>:c</code>, the line center will be aligned with the   anchor. Otherwise, the end of the line will be aligned with the anchor.   (<strong>Default</strong> = <code>:l</code>)</li><li><code>alignment_anchor_fallback_override::Dict{Int, Symbol}</code>: A <code>Dict{Int, Symbol}</code> to override   the behavior of <code>fallback_alignment_anchor</code> for a specific column. Example: <code>Dict(3 =&gt;   :c)</code> changes the fallback alignment anchor behavior for <code>:c</code> only for the column 3.</li><li><code>alignment_anchor_regex::Dict{Int, AbstractVector{Regex}}</code>: A dictionary <code>Dict{Int,   AbstractVector{Regex}}</code> with a set of regexes that is used to align the values in the   columns (keys). The characters at the first regex match (or anchor) of each line in   every cell of the column will be aligned.  The regex match is searched in the same order   as the regexes appear on the vector. The regex matching is applied after the cell   conversion to string, which includes the formatters. If no match is found for a specific   line, the alignment of this line depends on the options <code>alignment_anchor_fallback</code> and   <code>alignment_anchor_fallback_override</code>. If the key <code>0</code> is present, the related regexes   will be used to align all the columns. In this case, all the other keys will be   neglected. Example: <code>Dict(2 =&gt; [r&quot;\.&quot;])</code> aligns the decimal point of the cells in the   second column.   (<strong>Default</strong> = <code>Dict{Int, Vector{Regex}}()</code>)</li><li><code>autowrap::Bool</code>: If <code>true</code>, the text will be wrapped on spaces to fit the column. Notice   that this function requires <code>linebreaks = true</code> and the column must have a fixed size   (see <code>columns_width</code>).</li><li><code>body_hlines::Vector{Int}</code>: A vector of <code>Int</code> indicating row numbers in which an   additional horizontal line should be drawn after the row. Notice that numbers lower than   0 and equal or higher than the number of printed rows will be neglected. This vector   will be appended to the one in <code>hlines</code>, but the indices here are related to the printed   rows of the body. Thus, if <code>1</code> is added to <code>body_hlines</code>, a horizontal line will be   drawn after the first data row.   (<strong>Default</strong> = <code>Int[]</code>)</li><li><code>body_hlines_format::Union{Nothing, NTuple{4, Char}}</code>: A tuple of 4 characters specifying   the format of the horizontal lines that will be drawn by <code>body_hlines</code>. The characters   must be the left intersection, the middle intersection, the right intersection, and the   row. If it is <code>nothing</code>,  it will use the same format specified in <code>tf</code>.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers specifying the width   of each column. If the width is equal or lower than 0, it will be automatically computed   to fit the large cell in the column. If it is a single integer, this number will be used   as the size of all columns.   (<strong>Default</strong> = 0)</li><li><code>crop::Symbol</code>: Select the printing behavior when the data is bigger than the available   display size (see <code>display_size</code>). It can be <code>:both</code> to crop on vertical and horizontal   direction, <code>:horizontal</code> to crop only on horizontal direction, <code>:vertical</code> to crop only   on vertical direction, or <code>:none</code> to do not crop the data at all. If the <code>io</code> has   <code>:limit =&gt; true</code>, <code>crop</code> is set to <code>:both</code> by default. Otherwise, it is set to <code>:none</code>   by default.</li><li><code>crop_subheader::Bool</code>: If <code>true</code>, the sub-header size will not be taken into account when   computing the column size. Hence, the print algorithm can crop it to save space. This   has no effect if the user selects a fixed column width.   (<strong>Default</strong> = <code>false</code>)</li><li><code>continuation_row_alignment::Symbol</code>: A symbol that defines the alignment of the cells in   the continuation row. This row is printed if the table is vertically cropped.   (<strong>Default</strong> = <code>:c</code>)</li><li><code>display_size::Tuple{Int, Int}</code>: A tuple of two integers that defines the display size   (num. of rows, num. of columns) that is available to print the table. It is used to crop   the data depending on the value of the keyword <code>crop</code>. Notice that if a dimension is not   positive, it will be treated as unlimited.   (<strong>Default</strong> = <code>displaysize(io)</code>)</li><li><code>ellipsis_line_skip::Integer</code>: An integer defining how many lines will be skipped from   showing the ellipsis that indicates the text was cropped.   (<strong>Default</strong> = 0)</li><li><code>equal_columns_width::Bool</code>: If <code>true</code>, all the columns will have the same width.   (<strong>Default</strong> = <code>false</code>)</li><li><code>highlighters::Union{Highlighter, Tuple}</code>: An instance of <code>Highlighter</code> or a tuple with a   list of text highlighters (see the section <a href="#Text-Highlighters">Text Highlighters</a>).</li><li><code>hlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where the   horizontal lines will be drawn. It can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a vector of   integers.   (<strong>Default</strong> = <code>nothing</code>)<ul><li>If it is <code>nothing</code>, which is the default, the configuration will be obtained from the   table format in the variable <code>tf</code> (see <a href="../../lib/library/#PrettyTables.TextFormat"><code>TextFormat</code></a>).</li><li>If it is <code>:all</code>, all horizontal lines will be drawn.</li><li>If it is <code>:none</code>, no horizontal line will be drawn.</li><li>If it is a vector of integers, the horizontal lines will be drawn only after the rows   in the vector. Notice that the top line will be drawn if <code>0</code> is in <code>hlines</code>, and the   header and subheaders are considered as only 1 row. Furthermore, it is important to   mention that the row number in this variable is related to the <strong>printed rows</strong>.   Thus, it is affected by the option to suppress the header <code>show_header</code>.  Finally,   for convenience, the top and bottom lines can be drawn by adding the symbols   <code>:begin</code> and <code>:end</code> to this vector, respectively, and the line after the header can   be drawn by adding the symbol <code>:header</code>.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The values of <code>body_hlines</code> will be appended to this vector. Thus, horizontal lines can be drawn even if <code>hlines</code> is <code>:none</code>.</p></div></div><ul><li><code>linebreaks::Bool</code>: If <code>true</code>, <code>\\n</code> will break the line inside the cells.   (<strong>Default</strong> = <code>false</code>)</li><li><code>maximum_columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers specifying the   maximum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the maximum width of all columns.   Notice that the parameter <code>columns_width</code> has precedence over this one.   (<strong>Default</strong> = 0)</li><li><code>minimum_columns_width::Union{Int, AbstractVector{Int}}</code>: A set of integers specifying the   minimum width of each column. If the width is equal or lower than 0, it will be ignored.   If it is a single integer, this number will be used as the minimum width of all columns.   Notice that the parameter <code>columns_width</code> has precedence over this one.   (<strong>Default</strong> = 0)</li><li><code>newline_at_end::Bool</code>: If <code>false</code>, the table will not end with a newline character.   (<strong>Default</strong> = <code>true</code>)</li><li><code>overwrite::Bool</code>: If <code>true</code>, the same number of lines in the printed table will be   deleted from the output <code>io</code>. This can be used to update the table in the display   continuously.   (<strong>Default</strong> = <code>false</code>)</li><li><code>reserved_display_lines::Int</code>: Number of lines to be left at the beginning of the printing   when vertically cropping the output. Notice that the lines required to show the title   are automatically computed.   (<strong>Default</strong> = 0)</li><li><code>row_number_alignment::Symbol</code>: Select the alignment of the row number column (see the   section <a href="../alignment/#Alignment">Alignment</a>).   (<strong>Default</strong> = <code>:r</code>)</li><li><code>show_omitted_cell_summary::Bool</code>: If <code>true</code>, a summary will be printed after the table   with the number of columns and rows that were omitted.   (<strong>Default</strong> = <code>true</code>)</li><li><code>tf::TextFormat</code>: Table format used to print the table (see <a href="../../lib/library/#PrettyTables.TextFormat"><code>TextFormat</code></a>).   (<strong>Default</strong> = <code>tf_unicode</code>)</li><li><code>title_autowrap::Bool</code>: If <code>true</code>, the title text will be wrapped considering the title   size. Otherwise, lines larger than the title size will be cropped.   (<strong>Default</strong> = <code>false</code>)</li><li><code>title_same_width_as_table::Bool</code>: If <code>true</code>, the title width will match that of the   table. Otherwise, the title size will be equal to the display width.   (<strong>Default</strong> = <code>false</code>)</li><li><code>vcrop_mode::Symbol</code>: This variable defines the vertical crop behavior. If it is   <code>:bottom</code>, the data, if required, will be cropped in the bottom. On the other hand, if   it is <code>:middle</code>, the data will be cropped in the middle if necessary.   (<strong>Default</strong> = <code>:bottom</code>)</li><li><code>vlines::Union{Nothing, Symbol, AbstractVector}</code>: This variable controls where the   vertical lines will be drawn. It can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a vector of   integers.   (<strong>Default</strong> = <code>nothing</code>)<ul><li>If it is <code>nothing</code>, which is the default, the configuration will be obtained from the   table format in the variable <code>tf</code> (see <a href="../../lib/library/#PrettyTables.TextFormat"><code>TextFormat</code></a>).</li><li>If it is <code>:all</code>, all vertical lines will be drawn.</li><li>If it is <code>:none</code>, no vertical line will be drawn.</li><li>If it is a vector of integers, the vertical lines will be drawn only after the columns   in the vector. Notice that the top line will be drawn if <code>0</code> is in <code>vlines</code>.   Furthermore, it is important to mention that the column number in this variable is   related to the <strong>printed column</strong>.  Thus, it is affected by the options <code>row_labels</code>   and <code>show_row_number</code>.  Finally, for convenience, the left and right vertical lines   can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector, respectively,   and the line after the header can be drawn by adding the symbol <code>:header</code>.</li></ul></li></ul><p>The following keywords related to crayons are available to customize the output decoration:</p><ul><li><code>border_crayon::Crayon</code>: Crayon to print the border.</li><li><code>header_crayon::Union{Crayon, Vector{Crayon}}</code>: Crayon to print the header.</li><li><code>omitted_cell_summary_crayon::Crayon</code>: Crayon used to print the omitted cell summary.</li><li><code>row_label_crayon::Crayon</code>: Crayon to print the row labels.</li><li><code>row_label_header_crayon::Crayon</code>: Crayon to print the header of the column with the row   labels.</li><li><code>row_number_header_crayon::Crayon</code>: Crayon for the header of the column with the row   numbers.</li><li><code>subheader_crayon::Union{Crayon, Vector{Crayon}}</code>: Crayon to print sub-headers.</li><li><code>text_crayon::Crayon</code>: Crayon to print default text.</li><li><code>title_crayon::Crayon</code>: Crayon to print the title.</li></ul><p>The keywords <code>header_crayon</code> and <code>subheader_crayon</code> can be a <code>Crayon</code> or a <code>Vector{Crayon}</code>. In the first case, the <code>Crayon</code> will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the renderer <code>show</code> is used, all strings will be printed with surrounding quotes. However, if a formatter modifies a value and return a string, those surrounding quotes will be removed if the original value is not a string.</p></div></div><h2 id="Crayons"><a class="docs-heading-anchor" href="#Crayons">Crayons</a><a id="Crayons-1"></a><a class="docs-heading-anchor-permalink" href="#Crayons" title="Permalink"></a></h2><p>A <code>Crayon</code> is an object that handles a style for text printed on terminals. It is defined in the package <a href="https://github.com/KristofferC/Crayons.jl">Crayons.jl</a>. There are many options available to customize the style, such as foreground color, background color, bold text, etc.</p><p>A <code>Crayon</code> can be created in two different ways:</p><pre><code class="language-julia-repl hljs">julia&gt; Crayon(foreground = :blue, background = :black, bold = :true)

julia&gt; crayon&quot;blue bg:black bold&quot;</code></pre><p>For more information, see the <a href="https://github.com/KristofferC/Crayons.jl/blob/master/README.md">Crayon.jl documentation</a>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The Crayon.jl package is re-exported by PrettyTables.jl. Hence, you do not need <code>using Crayons</code> to create a <code>Crayon</code>.</p></div></div><h2 id="Cropping"><a class="docs-heading-anchor" href="#Cropping">Cropping</a><a id="Cropping-1"></a><a class="docs-heading-anchor-permalink" href="#Cropping" title="Permalink"></a></h2><p>The keyword <code>crop</code> can be used to define how the output will be cropped if the display has limits. The default behavior depends on the property <code>:limit</code> of the <code>io</code>. If <code>io</code> has <code>:limit =&gt; true</code>, the default value of <code>crop</code> is <code>:both</code>.  Otherwise, if <code>:limit =&gt; false</code> or it is not defined at all, <code>crop</code> defaults to <code>:none</code>.</p><p>If <code>pretty_table</code> is called without <code>io</code>, <code>stdout</code> is wrapped in a <code>IOContext</code> with <code>:limit =&gt; true</code>.</p><p>The display size can be configured by the keyword <code>display_size</code>, which is a tuple of two <code>Int</code> with the number of rows and columns, respectively. If this keyword is not specified, it is automatically obtained using the function <code>displaysize(io)</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = Any[
           1    false      1.0     0x01
           2     true      2.0     0x02
           3    false      3.0     0x03
           4     true      4.0     0x04
           5    false      5.0     0x05
           6     true      6.0     0x06
       ];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, display_size = (11, 30))</code><code class="nohighlight hljs ansi" style="display:block;">┌────────┬────────┬────────┬────────┐
│<span class="sgr1"> Col. 1 </span>│<span class="sgr1"> Col. 2 </span>│<span class="sgr1"> Col. 3 </span>│<span class="sgr1"> Col. 4 </span>│
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
│      4 │   true │    4.0 │      4 │
│      5 │  false │    5.0 │      5 │
│      6 │   true │    6.0 │      6 │
└────────┴────────┴────────┴────────┘</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, display_size = (11, 30), crop = :none)</code><code class="nohighlight hljs ansi" style="display:block;">┌────────┬────────┬────────┬────────┐
│<span class="sgr1"> Col. 1 </span>│<span class="sgr1"> Col. 2 </span>│<span class="sgr1"> Col. 3 </span>│<span class="sgr1"> Col. 4 </span>│
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
│      4 │   true │    4.0 │      4 │
│      5 │  false │    5.0 │      5 │
│      6 │   true │    6.0 │      6 │
└────────┴────────┴────────┴────────┘</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In vertical cropping, the header and the first table row is <strong>always</strong> printed.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The highlighters will work even in partially printed data.</p></div></div><p>If the user selects a fixed size for the columns (using the keyword <code>columns_width</code>), enables line breaks (using the keyword <code>linebreaks</code>), and sets <code>autowrap = true</code>, the algorithm wraps the text on spaces to automatically fit the space.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = [&quot;One very very very big long long line&quot;; &quot;Another very very very big big long long line&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;One very very very big long long line&quot;
 &quot;Another very very very big big long long line&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(
           data;
           autowrap = true,
           columns_width = 10,
           linebreaks = true,
           show_row_number = true
       )</code><code class="nohighlight hljs ansi" style="display:block;">┌─────┬────────────┐
│<span class="sgr1"> Row </span>│<span class="sgr1">     Col. 1 </span>│
├─────┼────────────┤
│   1 │   One very │
│     │  very very │
│     │   big long │
│     │  long line │
│   2 │    Another │
│     │  very very │
│     │   very big │
│     │   big long │
│     │  long line │
└─────┴────────────┘</code></pre><p>It is also possible to change the vertical cropping behavior to crop the table in the middle instead of the bottom. This can be accomplished by passing the option <code>vcrop_mode = :middle</code> to <code>pretty_table</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = Any[
           1    false      1.0     0x01
           2     true      2.0     0x02
           3    false      3.0     0x03
           4     true      4.0     0x04
           5    false      5.0     0x05
           6     true      6.0     0x06
       ]</code><code class="nohighlight hljs ansi" style="display:block;">6×4 Matrix{Any}:
 1  false  1.0  0x01
 2   true  2.0  0x02
 3  false  3.0  0x03
 4   true  4.0  0x04
 5  false  5.0  0x05
 6   true  6.0  0x06</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, display_size = (11, 30), vcrop_mode = :middle)</code><code class="nohighlight hljs ansi" style="display:block;">┌────────┬────────┬────────┬────────┐
│<span class="sgr1"> Col. 1 </span>│<span class="sgr1"> Col. 2 </span>│<span class="sgr1"> Col. 3 </span>│<span class="sgr1"> Col. 4 </span>│
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
│      4 │   true │    4.0 │      4 │
│      5 │  false │    5.0 │      5 │
│      6 │   true │    6.0 │      6 │
└────────┴────────┴────────┴────────┘</code></pre><h2 id="Text-Highlighters"><a class="docs-heading-anchor" href="#Text-Highlighters">Text Highlighters</a><a id="Text-Highlighters-1"></a><a class="docs-heading-anchor-permalink" href="#Text-Highlighters" title="Permalink"></a></h2><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword.  Each highlighter is an instance of the structure <code>Highlighter</code> that contains three fields:</p><ul><li><code>f::Function</code>: Function with the signature <code>f(data, i, j)</code> in which should return <code>true</code>   if the element <code>(i, j)</code> in <code>data</code> must be highlighted, or <code>false</code> otherwise.</li><li><code>fd::Function</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is the   highlighter. This function must return the <code>Crayon</code> to be applied to the cell that must   be highlighted.</li><li><code>crayon::Crayon</code>: The <code>Crayon</code> to be applied to the highlighted cell if the default <code>fd</code>   is used.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="nohighlight hljs">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, and <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, the cell <code>(i, j)</code> will be highlighted.</p><p>If the function <code>f</code> returns true, the function <code>fd(h, data, i, j)</code> will be called and must return a <code>Crayon</code> that will be applied to the cell.</p><p>A highlighter can be constructed using three helpers:</p><pre><code class="language-julia hljs">Highlighter(f::Function; kwargs...)</code></pre><p>where it will construct a <code>Crayon</code> using the keywords in <code>kwargs</code> and apply it to the highlighted cell,</p><pre><code class="language-julia hljs">Highlighter(f::Function, crayon::Crayon)</code></pre><p>where it will apply the <code>crayon</code> to the highlighted cell, and</p><pre><code class="language-julia hljs">Highlighter(f::Function, fd::Function)</code></pre><p>where it will apply the <code>Crayon</code> returned by the function <code>fd</code> to the highlighted cell.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i, j)</code>, the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../formatters/#Formatters">Formatters</a>, the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]

julia&gt; h1 = Highlighter(f      = (data, i, j) -&gt; (data[i, j] &lt; 0.5),
                        crayon = crayon&quot;red bold&quot; )

julia&gt; h2 = Highlighter((data,i,j) -&gt; (data[i, j] &gt; 0.5),
                        bold       = true,
                        foreground = :blue )

julia&gt; h3 = Highlighter(f      = (data, i, j) -&gt; (data[i, j] == 0.5),
                        crayon = Crayon(bold = true, foreground = :yellow) )

julia&gt; pretty_table(data, highlighters = (h1, h2, h3), compact_printing = false)</code></pre><p><img src="../../assets/ex_highlighters_00001.png" alt/></p><pre><code class="language-julia-repl hljs">julia&gt; data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]

julia&gt; hl_odd = Highlighter(f      = (data, i, j) -&gt; i % 2 == 0,
                            crayon = Crayon(background = :light_blue))

julia&gt; pretty_table(data, highlighters = hl_odd, formatters = ft_printf(&quot;%10.5f&quot;))</code></pre><p><img src="../../assets/ex_highlighters_00002.png" alt/></p><p>There are a set of pre-defined highlighters (with names <code>hl_*</code>) to make the usage simpler. They are defined in the file <code>./src/backends/text/predefined_highlighters.jl</code>.</p><h2 id="Text-Table-Formats"><a class="docs-heading-anchor" href="#Text-Table-Formats">Text Table Formats</a><a id="Text-Table-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Text-Table-Formats" title="Permalink"></a></h2><p>The following table formats are available when using the text back end:</p><p><code>tf_unicode</code> (<strong>Default</strong>)</p><pre><code class="language-text hljs">┌────────┬────────┬────────┬────────┐
│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
└────────┴────────┴────────┴────────┘</code></pre><p><code>tf_ascii_dots</code></p><pre><code class="language-text hljs">.....................................
: Col. 1 : Col. 2 : Col. 3 : Col. 4 :
:........:........:........:........:
:      1 :  false :    1.0 :      1 :
:      2 :   true :    2.0 :      2 :
:      3 :  false :    3.0 :      3 :
:........:........:........:........:</code></pre><p><code>tf_ascii_rounded</code></p><pre><code class="language-text hljs">.--------.--------.--------.--------.
| Col. 1 | Col. 2 | Col. 3 | Col. 4 |
:--------+--------+--------+--------:
|      1 |  false |    1.0 |      1 |
|      2 |   true |    2.0 |      2 |
|      3 |  false |    3.0 |      3 |
&#39;--------&#39;--------&#39;--------&#39;--------&#39;</code></pre><p><code>tf_borderless</code></p><pre><code class="language-text hljs">  Col. 1   Col. 2   Col. 3   Col. 4

       1    false      1.0        1
       2     true      2.0        2
       3    false      3.0        3</code></pre><p><code>tf_compact</code></p><pre><code class="language-text hljs"> -------- -------- -------- --------
  Col. 1   Col. 2   Col. 3   Col. 4
 -------- -------- -------- --------
       1    false      1.0        1
       2     true      2.0        2
       3    false      3.0        3
 -------- -------- -------- --------</code></pre><p><code>tf_markdown</code></p><pre><code class="language-text hljs">| Col. 1 | Col. 2 | Col. 3 | Col. 4 |
|--------|--------|--------|--------|
|      1 |  false |    1.0 |      1 |
|      2 |   true |    2.0 |      2 |
|      3 |  false |    3.0 |      3 |</code></pre><p><code>tf_matrix</code></p><pre><code class="language-text hljs">┌                     ┐
│ 1   false   1.0   1 │
│ 2    true   2.0   2 │
│ 3   false   3.0   3 │
└                     ┘</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In this case, the table format <code>matrix</code> was printed with the option <code>show_header = false</code>.</p></div></div><p><code>tf_mysql</code></p><pre><code class="language-text hljs">+--------+--------+--------+--------+
| Col. 1 | Col. 2 | Col. 3 | Col. 4 |
+--------+--------+--------+--------+
|      1 |  false |    1.0 |      1 |
|      2 |   true |    2.0 |      2 |
|      3 |  false |    3.0 |      3 |
+--------+--------+--------+--------+</code></pre><p><code>tf_simple</code></p><pre><code class="language-text hljs">========= ======== ======== =========
  Col. 1   Col. 2   Col. 3   Col. 4
========= ======== ======== =========
       1    false      1.0        1
       2     true      2.0        2
       3    false      3.0        3
========= ======== ======== =========</code></pre><p><code>tf_unicode_rounded</code></p><pre><code class="language-text hljs">╭────────┬────────┬────────┬────────╮
│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
╰────────┴────────┴────────┴────────╯</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The format <code>unicode_rounded</code> should look awful on your browser, but it should be printed fine on your terminal.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]</code><code class="nohighlight hljs ansi" style="display:block;">7×3 Matrix{Any}:
 0.0       1.0        0.0
 0.258819  0.965926   0.267949
 0.5       0.866025   0.57735
 0.707107  0.707107   1.0
 0.866025  0.5        1.73205
 0.965926  0.258819   3.73205
 1.0       0.0       Inf</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, tf = tf_ascii_dots)</code><code class="nohighlight hljs ansi" style="display:block;">..................................
:<span class="sgr1">   Col. 1 </span>:<span class="sgr1">   Col. 2 </span>:<span class="sgr1">   Col. 3 </span>:
:..........:..........:..........:
:      0.0 :      1.0 :      0.0 :
: 0.258819 : 0.965926 : 0.267949 :
:      0.5 : 0.866025 :  0.57735 :
: 0.707107 : 0.707107 :      1.0 :
: 0.866025 :      0.5 :  1.73205 :
: 0.965926 : 0.258819 :  3.73205 :
:      1.0 :      0.0 :      Inf :
:..........:..........:..........:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, tf = tf_compact)</code><code class="nohighlight hljs ansi" style="display:block;"> ---------- ---------- ----------
 <span class="sgr1">   Col. 1 </span> <span class="sgr1">   Col. 2 </span> <span class="sgr1">   Col. 3 </span>
 ---------- ---------- ----------
       0.0        1.0        0.0
  0.258819   0.965926   0.267949
       0.5   0.866025    0.57735
  0.707107   0.707107        1.0
  0.866025        0.5    1.73205
  0.965926   0.258819    3.73205
       1.0        0.0        Inf
 ---------- ---------- ----------</code></pre><p>It is also possible to define you own custom table by creating a new instance of the structure <a href="../../lib/library/#PrettyTables.TextFormat"><code>TextFormat</code></a>. For example, let&#39;s say that you want a table like <code>simple</code> that does not print the bottom line:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]</code><code class="nohighlight hljs ansi" style="display:block;">7×3 Matrix{Any}:
 0.0       1.0        0.0
 0.258819  0.965926   0.267949
 0.5       0.866025   0.57735
 0.707107  0.707107   1.0
 0.866025  0.5        1.73205
 0.965926  0.258819   3.73205
 1.0       0.0       Inf</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tf = TextFormat(
           up_right_corner     = &#39;=&#39;,
           up_left_corner      = &#39;=&#39;,
           bottom_left_corner  = &#39;=&#39;,
           bottom_right_corner = &#39;=&#39;,
           up_intersection     = &#39; &#39;,
           left_intersection   = &#39;=&#39;,
           right_intersection  = &#39;=&#39;,
           middle_intersection = &#39; &#39;,
           bottom_intersection = &#39; &#39;,
           column              = &#39; &#39;,
           row                 = &#39;=&#39;,
           hlines              = [:begin, :header]
       )</code><code class="nohighlight hljs ansi" style="display:block;">TextFormat(&#39;=&#39;, &#39;=&#39;, &#39;=&#39;, &#39;=&#39;, &#39; &#39;, &#39;=&#39;, &#39;=&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39;=&#39;, [:begin, :header], :all)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, tf = tf)</code><code class="nohighlight hljs ansi" style="display:block;">=========== ========== ===========
 <span class="sgr1">   Col. 1 </span> <span class="sgr1">   Col. 2 </span> <span class="sgr1">   Col. 3 </span>
=========== ========== ===========
       0.0        1.0        0.0
  0.258819   0.965926   0.267949
       0.5   0.866025    0.57735
  0.707107   0.707107        1.0
  0.866025        0.5    1.73205
  0.965926   0.258819    3.73205
       1.0        0.0        Inf</code></pre><p>or that does not print the header line:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = Any[f(a) for a = 0:15:90, f in (sind, cosd, tand)]</code><code class="nohighlight hljs ansi" style="display:block;">7×3 Matrix{Any}:
 0.0       1.0        0.0
 0.258819  0.965926   0.267949
 0.5       0.866025   0.57735
 0.707107  0.707107   1.0
 0.866025  0.5        1.73205
 0.965926  0.258819   3.73205
 1.0       0.0       Inf</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tf = TextFormat(
           up_right_corner     = &#39;=&#39;,
           up_left_corner      = &#39;=&#39;,
           bottom_left_corner  = &#39;=&#39;,
           bottom_right_corner = &#39;=&#39;,
           up_intersection     = &#39; &#39;,
           left_intersection   = &#39;=&#39;,
           right_intersection  = &#39;=&#39;,
           middle_intersection = &#39; &#39;,
           bottom_intersection = &#39; &#39;,
           column              = &#39; &#39;,
           row                 = &#39;=&#39;,
           hlines              = [:begin, :end]
       )</code><code class="nohighlight hljs ansi" style="display:block;">TextFormat(&#39;=&#39;, &#39;=&#39;, &#39;=&#39;, &#39;=&#39;, &#39; &#39;, &#39;=&#39;, &#39;=&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39;=&#39;, [:begin, :end], :all)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(data, tf = tf)</code><code class="nohighlight hljs ansi" style="display:block;">=========== ========== ===========
 <span class="sgr1">   Col. 1 </span> <span class="sgr1">   Col. 2 </span> <span class="sgr1">   Col. 3 </span>
       0.0        1.0        0.0
  0.258819   0.965926   0.267949
       0.5   0.866025    0.57735
  0.707107   0.707107        1.0
  0.866025        0.5    1.73205
  0.965926   0.258819    3.73205
       1.0        0.0        Inf
=========== ========== ===========</code></pre><p>For more information, see the documentation of the structure <a href="../../lib/library/#PrettyTables.TextFormat"><code>TextFormat</code></a>.</p><h2 id="Custom-Text-Cells"><a class="docs-heading-anchor" href="#Custom-Text-Cells">Custom Text Cells</a><a id="Custom-Text-Cells-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Text-Cells" title="Permalink"></a></h2><p><strong>PrettyTables.jl</strong> escapes all ANSI sequences by default so that every character in the cell is printable. This behavior let us to easily compute the cell size, which is essential to many features like alignment and cropping.  However, there are specific cases in which the user wants to render a cell with escape sequences that does not produce printable characters. In this case, the user must create a custom text cell.</p><p>A custom text cell is an object of a type derived from <a href="../../lib/library/#PrettyTables.CustomTextCell"><code>CustomTextCell</code></a>.  Let&#39;s suppose that we want to create a custom cell called <code>MyTextCell</code>. This object must comply with the API by defining the following functions:</p><pre><code class="language-julia hljs">append_suffix_to_line!(c::MyTextCell, l::Int, suffix::String)</code></pre><p>Append the <code>suffix</code> to the line <code>l</code> of the custom cell text <code>c</code>.</p><pre><code class="language-julia hljs">apply_line_padding!(c::MyTextCell, l::Int, left_pad::Int, right_pad::Int)</code></pre><p>Apply to the line <code>l</code> of the custom text cell <code>c</code> the padding with <code>left_pad</code> spaces in the left and <code>right_pad</code> spaces in the right.</p><pre><code class="language-julia hljs">crop_line!(c::MyTextCell, l::Int, num::Int)</code></pre><p>Crop <code>num</code> characters from the line <code>l</code> of the custom text cell <code>c</code>.</p><pre><code class="language-julia hljs">get_printable_cell_line(c::MyTextCell, l::Int)</code></pre><p>Return the printable line <code>l</code> of the custom text cell <code>c</code>.</p><pre><code class="language-julia hljs">get_rendered_line(c::MyTextCell, l::Int)</code></pre><p>Return the rendered line <code>l</code> of the custom text cell <code>l</code>.</p><pre><code class="language-julia hljs">parse_cell_text(c::CustomTextCell; kwargs...)</code></pre><p>Parse the cell text and return a vector of <code>String</code> with the printable cell text, where each element in the vector is a new line.</p><p>The returned data must contain <strong>only</strong> the printable characters.</p><p>The following keyword arguments are passed to this function, which is called during the cell parsing phase. Those options are related to the input configuration of <code>pretty_table</code>, and the user must choose whether or not support them.</p><ul><li><code>autowrap::Bool</code>: If <code>true</code>, the user wants to wrap the text in the cell. In this case,   the option <code>column_width</code> contains the column width so that the text can be wrapped into   multiple lines.</li><li><code>cell_first_line_only::Bool</code>: If <code>true</code>, the user only wants the first line.</li><li><code>column_width::Integer</code>: The column width.</li><li><code>compact_printing::Bool</code>: If <code>true</code>, the user wants compact printing (see <code>:compact</code>   options of <code>IOContext</code>).</li><li><code>limit_printing::Bool</code>: If <code>true</code>, the user wants the cells to be converted using the   option <code>:limit =&gt; true</code> in <code>IOContext</code>.</li><li><code>linebreaks::Bool</code>: If <code>true</code>, the user wants line breaks inside the cells.</li><li><code>renderer::Union{Val{:print}, Val{:show}}</code>: The render that the user wants to convert the   cells to strings.</li></ul><pre><code class="language-julia hljs">reset!(c::CustomTextCell)</code></pre><p>Reset all fields in the custom text cell <code>c</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The <code>reset!</code> function is not required for the API. It is called before parsing the custom text cell.</p></div></div><h3 id="UrlTextCell"><a class="docs-heading-anchor" href="#UrlTextCell">UrlTextCell</a><a id="UrlTextCell-1"></a><a class="docs-heading-anchor-permalink" href="#UrlTextCell" title="Permalink"></a></h3><p>There is one custom text cell bundled with <strong>PrettyTables.jl</strong> called <a href="#UrlTextCell"><code>UrlTextCell</code></a>. This type adds support for rendering <a href="https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda">implicit hyperlinks</a> using the escape sequence <code>\e]8</code>. Hence, the user can render a text that has a hyperlink associated with it.</p><p>A <a href="#UrlTextCell"><code>UrlTextCell</code></a> can be created with the following function:</p><pre><code class="language-julia hljs">UrlTextCell(text::String, url::String</code></pre><p>which creates a URL cell with a specific <code>text</code> that points to an <code>url</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; table = [
      1 &quot;Ronan Arraes Jardim Chagas&quot; UrlTextCell(&quot;Ronan Arraes Jardim Chagas&quot;, &quot;https://ronanarraes.com&quot;)
      2 &quot;Google&quot; UrlTextCell(&quot;Google&quot;, &quot;https://google.com&quot;)
      3 &quot;Apple&quot; UrlTextCell(&quot;Apple&quot;, &quot;https://apple.com&quot;)
      4 &quot;Emojis!&quot; UrlTextCell(&quot;😃&quot;^20, &quot;https://emojipedia.org/github/&quot;)
  ]

julia&gt; pretty_table(table)</code></pre><p><img src="../../assets/ex_UrlTextCell.png" alt/></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is not supported by all terminal emulators.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../html_backend/">HTML »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 26 May 2024 18:12">Sunday 26 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
